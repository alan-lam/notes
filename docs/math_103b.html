<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
    -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
    <title>Abstract Algebra II</title>
    <link href="math_103b.css" rel="stylesheet">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </head>
  <body>
    <nav class="navbar navbar-expand-sm navbar-light bg-light fixed-top">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNavDropdown">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home</a>
          </li>
          <!-- <li class="nav-item">
            <a class="nav-link" href="#" target="_blank">Cheat Sheets</a>
          </li> -->
        </ul>
      </div>
    </nav>
    <div class="toc">
      <ul>
        <a class="toc_link" href="#rings"><li>Rings</li></a>
        <a class="toc_link" href="#integral_domains"><li>Integral Domains</li></a>
        <a class="toc_link" href="#ideals"><li>Ideals</li></a>
      </ul>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-md-9">
          <h1>Abstract Algebra II</h1>
          <div class="content" id="rings">
            <div class="proof">
              <p>A <b>ring</b> is a set `R` with two operations `+, *` such that `(R, +)` is an abelian group, `*` is associative, and `+,*` follow distributivity rules</p>
              <p>Subring Test: `a, b in S => a-b in S, ab in S` where `S sube R`</p>
              <p>An <b>integral domain</b> is a commutative ring with unity and no zero-divisors</p>
              <p>Check if S is an integral domain: `ab = 0 => a = 0` or `b = 0` for `a, b in S`</p>
              <p>A <b>field</b> is a commutative ring with unity in which every nonzero element has a multiplicative inverse (`i.e.` every nonzero element is a unit)</p>
              <p>Subfield Test: `a, b (b != 0) in K => a-b in K, ab^(-1) in K` where `K sube F`</p>
              <p>An <b>ideal</b> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</p>
              <p>Ideal Test: `a, b in A => a-b in A` and `a in A, r in R => ra in A` and `ar in A` where `A sube R`</p>
            </div>
            <h3>Rings</h3>
            <ul>
              <li><p>Rings are modeled on the integers</p></li>
              <li><p>(`ZZ`, +) is an abelian group</p></li>
              <li><p>`ZZ` also has multiplication which satisfies</p></li>
              <li style="list-style-type: none";><p>`a*(b + c) = a*b + a*c`</p></li>
              <li style="list-style-type: none";><p>`(b + c)*a = b*a + c*a`</p></li>
              <li style="list-style-type: none";><p>`a*(b*c) = (a*b)*c`</p></li>
              <li><p><b>Def: A <u>ring</u> is a set `R` with two operations `+`, `*` such that (`R`, `+`) is an abelian group and</b></p></li>
              <li style="list-style-type: none";><p><b>1) `a*(b*c) = (a*b)*c` (`*` is associative)</b></p></li>
              <li style="list-style-type: none";><p><b>2) `a*(b + c) = a*b + a*c`, `(b + c)*a = b*a + c*a` for all `a, b, c in R`</b></p></li>
              <li><p>Ex: the set of integer multiples of 3 is a ring, `3ZZ`</p></li>
              <li><p>Ex: the real numbers, `RR`</p></li>
              <li><p>Ex: the set of real valued functions `f:[a,b]->ZZ`</p></li>
              <li><p>Ex: let V be a finite dimensional real vector space. Then `End_RR (V) = {phi: V -> V}` forms a ring</p></li>
              <li style="list-style-type: none";><p>the multiplication operation is function composition</p></li>
            </ul>
            <h5>Properties of Rings</h5>
            <ul>
              <li><p>The second 3 rings (`1in RR`; `f(x) = 1, AA x in [a,b]`; `i``d_v`) have a <u>multiplicative identity</u></p></li>
              <li style="list-style-type: none";><p>`a*1 = 1*a = a` (1 is the multiplicative identity)</p></li>
              <li style="list-style-type: none";><p>But `3a*3b != 3a`</p></li>
              <li><p>In `RR` and `{f:[a,b]->RR}`, multiplication is commutative</p></li>
              <li><p>`RR` is the only one of these rings with the property that every nonzero element of `RR` has a multiplicative inverse</p></li>
              <li><p>`AA a in RR`, `EE b in RR` `s.t. a*b = b*a = 1`</p></li>
              <li><p>Rings with a `1` element are said to be <u>unital</u></p></li>
              <li><p>`1` is called a "unity"</p></li>
              <li><p>Given a ring `R`, the elements of `R` which have a multiplicative inverse (2-sided) are called the <u>units</u> of `R`</p></li>
            </ul>
            <h5>Terminology</h5>
            <ul>
              <li><p>Given a commutative ring `R`, `a, b in R`, we say `a` divides `b` `a`|`b` if `EE c in R` `s.t. a*c = b`</p></li>
              <li><p>Since rings are additive groups under addition, given `n in ZZ^+`, we can make sense of `n*a = sum_(i=1)^n a`</p></li>
              <li><p>We define `-n*a = -sum_(i=1)^n a` when `n` is positive</p></li>
              <li><p>`0*a = 0`</p></li>
            </ul>
            <h5>Propositions</h5>
            <ul>
              <li><p>Suppose `a, b, c in R`. Then we have the following properties of multiplication</p></li>
              <li><p>`a*0 = 0*a = 0` (`0 in R`, the additive identity)</p></li>
              <li><p>`a*(-b) = -a*b`</p></li>
              <li><p>`(-a)(-b) = a*b`</p></li>
              <li><p>`a*(b-c) = a*b-a*c`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m+n)*a = (m*a) + (n*a)`</p></li>
              <li><p>given any integer `m in ZZ`, `m*(a*b) = (m*a)*b = (a)*(m*b)`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m*a)*(n*b) = (m*n)*(a*b)`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(a+b) = n*a + n*b`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(-a) = -(n*a)`</p></li>
              <li style="list-style-type: none";><p>If `R` is unital, then</p></li>
              <li><p>`(-1)*a = -a` where `-1 in R`</p></li>
              <li><p>`(-1)(-1) = 1`</p></li>
              <li><p>unity is unique</p></li>
              <li><p>if `a` has a left multiplicative inverse and a right multiplicative inverse, then they are equal</p></li>
              <li><p>multiplicative inverses are unique</p></li>
            </ul>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `a*0 = 0*a = 0`</p></li>
                <li><p>`0+0 = 0`</p></li>
                <li><p>`a*(0 + 0 = 0)`</p></li>
                <li><p>`= a*0 + a*0 = a*0`</p></li>
                <li><p>`=> a*0 = 0`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `a*(-b) = -a*b`</p></li>
                <li><p>`a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`a*(b + (-b)) = a*b + a(-b) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `a*(-b) = -(a*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `(-a)(-b) = a*b`</p></li>
                <li><p>`-a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`-a*(b + (-b)) = -a*b + (-a)*(-b)`</p></li>
                <li><p>By uniqueness of the additive inverse, `(-a)*(-b) = a*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `a*(b - c) = a*b - b*c`</p></li>
                <li><p>`a*(b - c) = a*(b + (-c))`</p></li>
                <li><p>`= a*b + a*(-c)`</p></li>
                <li><p>`= a*b + (-a*c) = a*b - a*c`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `(m + n)*a = (m*a) + (n*a)`</p></li>
                <li><p>When `m, n > 0, (m*a) + (n*a) = sum_(i=1)^m a + sum_(j=1)^n a = sum_(k=1)^(m+n) a = (m + n)*a`</p></li>
                <li><p>Suppose `n < 0`, then we can write `n = -n'` where `n' > 0`. `(m + n)*a = (m - n') * a`</p></li>
                <li style="list-style-type: none";><p>1) When `m > n'`, we can write `m - n' = m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m - n')*a = sum_(i = 1)^(m-n') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a = (m*a) - (n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (-n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (n*a)`</p></li>
                <li style="list-style-type: none";><p>2) If `m < n'`, we can write `m - n' = -m'` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m + n)*a = (m - n')*a = (-m')*a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>Notice: `sum_(i = 1)^(m') a = sum_(i = 1)^(n') a - sum_(j = 1)^m a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^(m') a + (- sum_(i=1)^(m') a) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `- sum_(i = 1)^(m') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^m a - sum_(j = 1)^(n') a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>`(m*a) - (n*a) = (m*a) + (-n'*a) = (m*a) + (n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `m*(a*b) = (m*a)*b = (a)*(m*b)`</p></li>
                <li><p>If `m = 0,`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*b = 0*b = 0`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b) = 0*a*b = 0`</p></li>
                <li style="list-style-type: none";><p>`(a)*(m*b) = (a)*(0*b) = 0`</p></li>
                <li><p>Suppose `m` is positive. Then `m*(a*b) = sum_(i = 1)^m a*b = (sum_(i = 1)^m a)*b = (m*a)*b`</p></li>
                <li><p>If `m` is negative, we can write `m = -m` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (m + m')*(a*b) = m*(a*b) + m'*(a*b) = m*(a*b) + a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b) + a(m'*b) = a*(m*b + m'*b) = a*((m+m')*b)) = 0`</p></li>
                <li style="list-style-type: none";></li><p>By uniqueness of the additive inverse, `a*(m*b) = m*(a*b)`</p>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `(m*a)*(n*b) = (m*n)*(a*b)`</p></li>
                <li><p>If `m, n` are both positive, `(m*a)*(n*b) = (sum_(i = 1)^m a)*(sum_(j = 1)^n b) = sum_(k = 1)^(m*n) a*b = (m*n)*(a*b)`</p></li>
                <li><p>If `m, n` are both negative, `EE m', n' > 0` `s.t. m = -m', n = -n'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) = (-m'*a)*(-n'*b) = -(m'*a)*(-(n'*b)) = (m'*a)*(n'*b)`</p></li>
                <li style="list-style-type: none";><p>`= (m'*n')*(a*b) = ((-m')*(-n'))*(a*b) = (m*n)*(a*b)`</p></li>
                <li><p>If `m` is negative and `n` is positive, there exists `m' > 0` `s.t. m = -m'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) + (m'*a)*(n*b) = ((m*a) + (m'*a))*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*a)*(n*b)) = 0`</p></li>
                <li style="list-style-type: none";><p>`(m'*a)*(n*b) = (m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) + (m'*n)*(a*b) = (m*n + m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*n)*(a*b) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `(m*n)*(a*b) = -(m'*a)*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) = (-m'*a)*(n*b) = (m*a)*(n*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `n*(a + b) = n*a + n*b`</p></li>
                <li><p>If `n` is positive, `n*(a + b) = sum_(i = 1)^n (a + b) = sum_(i = 1)^n a + sum_(i = 1)^n b = (n*a) = (n*b)`</p></li>
                <li><p>If `n` is negative, we can write it as `-n'` where `n' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (n + n')*(a + b) = n*(a + b) + n'*(a + b) = n*(a + b) + n'*a + n'*b`</p></li>
                <li style="list-style-type: none";><p>But `n*a + n*b + n'*a + n'*b = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `n*(a + b) = n*a + n*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS `n*(-a) = -(n*a)`</p></li>
                <li><p>`0 = n*(a + (-a)) = (n*a) + n*(-a)`</p></li>
                <li><p>Also know `(n*a) + (-n*a) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `n*(-a) = (-n*a) = -(n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS unity is unique</p></li>
                <li><p>Suppose `1, 1'` are both unity elements of `R`</p></li>
                <li><p>On one hand, `1` is a mult. identity `=> 1*1' = 1'`</p></li>
                <li><p>On the other hand, `1'` is a mult. identity `=> 1*1' = 1`</p></li>
                <li><p>`=> 1 = 1'`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p>WTS if `a` has a left mult. inverse and a right mult. inverse, then they are equal</p></li>
                <li><p>Suppose `b` is a left mult. inverse of `a` and `c` is a right mult. inverse of `a`</p></li>
                <li><p>`b*a = 1, a*c = 1`</p></li>
                <li><p>`b = b*1 = b*(a*c) = (b*a)*c = 1*c = c`</p></li>
              </ul>
            </div>
            <h5>Subrings</h5>
            <ul>
              <li><p><b>Def: A <u>subring</u> of a ring `R` is a subset `S sube R` which is a ring with the operations of `+` and `*` restricted to `S`</b></p></li>
              <li><p>Unwinding this definition, we see that `+: SxxS->R`, `(s_1, s_2)|->s_1 + s_2` must have image contained in `S` (closed under addition) and `*: SxxS->R`, `(s_1, s_2)|->s_1*s_2` must have image contained in `S` (closed under multiplication)</p></li>
              <li><p>We must have `0 in S` and for every `s in S, -s in S` (closed under taking additive inverses)</p></li>
              <li><p><b>In fact, we see that `S` is a subring if and only if `s_1 - s_2 in S` and `s_1*s_2 in S`, `AA s_1, s_2 in S`</b></p></li>
              <li><p>Ex: `3ZZ sube ZZ` is a subring of `ZZ`</p></li>
              <li><p>Ex: `QQ sube RR` is a subring of `RR`</p></li>
              <li><p>Ex: `{lambda Id}_(lambda in R) sube End_RR(V)` where `V` is a finite dimensional real vector space</p></li>
            </ul>
            <h5>Exercises</h5>
            <ul>
              <li><p>Let `R_1, ..., R_n` be rings. The direct sum of `R_1, ..., R_n`, `R_1 o+ R_2 o+ ... o+ R_n` is the set which is the Cartesian product `prod_(i = 1)^n R_i` with ring operations performed component-wise</p></li>
              <li><p>`(a_1, ..., a_n) + (b_1, ..., b_n) = (a_1 + b_1, ..., a_n + b_n)`</p></li>
              <li><p>`(a_1, ..., a_n) * (b_1, ..., b_n) = (a_1 * b_1, ..., a_n * b_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R_1, ..., R_n` are rings with nonzero elements. Show that `R = R_1 o+ ... o+ R_n` has unity `<=>` each `R_i` has a unity</b></p></li>
                <li><p>Proof: (`=>`) Assume `R` has unity, say `(e_1, ..., e_n)`. We want to show that each `R_i` has a unity element. We need to show that `e_i` is the mult. identity of `R_i` for each `i`.</p></li>
                <li><p>Need to show: given `r_i in R_i`, `e_i*r_i = r_i*e_i = r_i`</p></li>
                <li><p>Consider a function `f:R_j->R_1 o+ ... o+ R_n, r_j |-> (0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>We know that `(0, ..., 0, r_j, 0, ..., 0) * (e_1, ..., e_n) = (0, ..., 0, r_j, 0, ..., 0) = (e_1, ..., e_n)*(0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>`=> (0*e_1, ..., r_j*e_j, ..., 0*e_n) = (e_1*0, ..., e_j*r_j, ..., 0*e_n)`</p></li>
                <li><p>`=> (0, ..., 0, r_j*e_j, 0, ..., 0) = (0, ..., 0, e_j*r_j, 0, ..., 0)`</p></li>
                <li><p>This shows that `e_j*r_j = r_j = r_j*e_j, AA r in R_j => e_j` is a mult identity of `R_j`</p></li>
                <li><p>(`lArr`) Assume that each `R_i` has a mult. identity. We need to show that `R` does too.</p></li>
                <li><p>Say `e_i` is the mult. identity of `R_i`. We claim that `(e_1, ..., e_n)` is the mult. identity of `R`. We must show that `(e_1, ..., e_n)*(r_1, ..., r_n) = (r_1, ..., r_n)*(e_1, ..., e_n) = (r_1, ..., r_n), AA (r_1, ..., r_n) in R`</p></li>
                <li><p>`(e_1, ..., e_n)*(r_1, ..., r_n) = (e_1*r_1, ..., e_n*r_n) = (r_1, ..., r_n)`</p></li>
                <li><p>`(r_1, ..., r_n)*(e_1, ..., e_n) = (r_1*e_1, ..., r_n*e_n) = (r_1, ..., r_n)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is a positive even integer `n` `s.t. a^n = a` for all `a in R`. Show that `-a = a` for all `a in R`.</b></p></li>
                <li><p>Proof: We can write `n = 2k` for some positive integer `k`</p></li>
                <li style="list-style-type: none";><p>`-a = (-a)^n = (-a)^(2k) = ((-a)^2)^k = (a^2)^k = a^(2k) = a^n = a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is an integer `n > 1` such that `x^n = x, AA x in R`. If `m` is a positive integer such that `a^m = 0` for some `a`, show that `a = 0`</b></p></li>
                <li><p>Proof: Case 1: `m <= n`</p></li>
                <li style="list-style-type: none";><p>`a = a^n = a^m * a^(n-m) = 0 * a^(n-m) = 0`</p></li>
                <li><p>Case 2: `m > n`</p></li>
                <li style="list-style-type: none";><p>Choose `m` to be the smallest positive integer `s.t. a^m = 0`</p></li>
                <li style="list-style-type: none";><p>Suppose for a contradiction `m > n`</p></li>
                <li style="list-style-type: none";><p>`0 = a^m = a^n * a^(m-n) = a*a^(m-n) = a^(m-n+1)`</p></li>
                <li style="list-style-type: none";><p>Since m was chosen to be the smallest positive integer with this property, `m-n+1 >= m => -n + 1 >= 0 => 1 >= n`</p></li>
                <li style="list-style-type: none";><p>This contradicts the assumption that `n > 1`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="integral_domains">
            <h3>Integral Domains</h3>
            <ul>
              <li><p>`ZZ` has more structure than an arbitrary ring does</p></li>
              <li><p>`ZZ` is a commutative ring</p></li>
              <li><p>`ZZ` has a mult. identity</p></li>
              <li><p>`ZZ` has the property that if `a, b != 0`, then `ab != 0`</p></li>
              <li><p><b>Def: A <u>zero-divisor</u> in a commutative ring is a nonzero element `z in R` `s.t.` there exists a nonzero element `y in R` `s.t.` `zy = 0`</b></p></li>
              <li><p><b>Def: An <u>integral domain</u> is a unital commutative ring `R` `s.t.` if `a, b in R` `s.t. ab = 0`, then either `a = 0` or `b = 0`</b></p></li>
              <li><p>We almost have division in integral domains: we have cancellation</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `R` be a domain. Suppose that `a != 0 in R`. Then `ab = ac => b= c`</b></p></li>
                <li><p>Proof: `ab = ac => ab - ac = 0 => a(b-c) = 0`</p></li>
                <li><p>Since `a != 0`, `b-c = 0 => b = c`</p></li>
              </div>
              <li><p>Ex: `QQ` is a domain</p></li>
              <li><p>Ex: the Gaussian integers `ZZ[i] = {a + bi | a, b in ZZ}` is a domain</p></li>
              <li><p>Ex: `CC[x]` - the ring of polynomials in a single indeterminate `x` with coefficients `in CC` is a domain</p></li>
              <li><p>NonEx: `ZZ // (4ZZ)` is not a domain because `[2]_4 * [2]_4 = [4]_4 = [0]_4`</p></li>
              <li><p><b>Def: A <u>field</u> is a domain `F` `s.t.` every nonzero element of `F` has a mult. inverse</b></p></li>
              <li><p>Ex: `RR` is a field</p></li>
              <li><p>Ex: `CC(t) = {f(t)/g(t) | f(t), g(t) in CC(t)}` the ring of rational functions whose coefficients are in `CC` is a field</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `D` be a finite integral domain. Then `D` is a field.</b></p></li>
                <li><p>Proof: Need to show that every nonzero element has a mult. inverse</p></li>
                <li><p>Let `a != 0 in D`. Consider the function `phi_a: D->D`, `y |-> ay`</p></li>
                <li><p>If we show that `phi_a` is surjective, then we are done</p></li>
                <li><p>Since `D` is finite, by the pigeonhole principle, `phi_a` is surjective `<=> phi_a` is injective</p></li>
                <li><p>Therefore, it suffices to show that `phi_a` is injective</p></li>
                <li><p>Suppose `b, c in D` `s.t.` `phi_a(b) = phi_a(c) => ab = ac`</p></li>
                <li><p>Since `a != 0` and `D` is a domain, we conclude that `b = c => phi_a` is injective</p></li>
                <li><p>Since `phi_a` is surjective, if we fix `1 in D`, we can find an element `b in D` `s.t.` `phi_a(b) = ab = 1 => b` is the mult. inverse of `a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Corollary: `ZZ // pZZ` is a field `<=> p` is prime</b></p></li>
                <li><p>Proof: (`=>`) Suppose `ZZ // pZZ` is a field but `p` is not prime</p></li>
                <li><p>Then `p = qr`, `1 < q, r < p`</p></li>
                <li><p>Then `[q]_p*[r]_p = [p]_p = [0]_p => ZZ // pZZ` has zero-divisors, which contradicts `ZZ // pZZ` is a field</p></li>
                <li><p>(`lArr`) If `p` is prime, then we must show `ZZ // pZZ` is a domain by the previous result</p></li>
                <li><p>Suppose `[a]_p * [b]_p = [0]_p <=> ab = pk` for some integer `k`</p></li>
                <li><p>`p` prime `=> p|ab <=> p|a` or `p|b <=> [a]_p = [0]_p` or `[b]_p = [0]_p => ZZ // pZZ` is a domain</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain and `S` is a subring of `R` which contains `1 in R`, then `S` itself is an integral domain</b></p></li>
                <li><p>Proof: `S` is commutative &#10003;</p></li>
                <li><p>`S` has a mult. identity &#10003;</p></li>
                <li><p>If `s_1, s_2 in S` `s.t.` `s_1*s_2 = 0 in S`, this same equation holds in `R`</p></li>
                <li><p>Since `R` is a domain, `s_1s_2 = 0 => s_1 = 0 or s_2 = 0`</p></li>
              </div>
              <li><p>Ex: Notice that in `ZZ // nZZ`, `n[a]_n = [na]_n = [0]_n`</p></li>
              <li style="list-style-type: none";><p>Multiplication by `n` kills all elements of `ZZ // nZZ`</p></li>
              <li><p>Ex: Consider `CC` (along with all subrings `R` of `CC` containing `1`). There does not exist a positive integer `n` `s.t.` `n*z = 0` `AA z in CC` and `n*z = 0` `AA z in R`</p></li>
              <li style="list-style-type: none";><p>The only integer which kills all of `CC` (or `R`) is `0`</p></li>
              <li><p>The integer `n` in these examples is called the characteristic of the ring</p></li>
              <li><p><b>Def: the <u>characteristic</u> of a ring `R` is the least nonnegative integer `n` `s.t.` `n*r = 0` `AA r in R`</b></p></li>
              <li><p>`char(ZZ // nZZ) = n`, `char(CC) = 0`</p></li>
              <li><p>When `R` is a unital commutative ring, we can relate `char(R)` to the order of `1 in R` (as an abelian group under `+`)</p></li>
              <li><p>If `1` has infinite order in `R`, then `char(R) = 0`</p></li>
              <li><p>If `1` has finite order, say `n`, then `char(R) = n`</p></li>
              <li style="list-style-type: none";><p>Since `o``rd(1) = n, n*1 = 0`</p></li>
              <li style="list-style-type: none";><p>`n*r = (n*1)r = 0` `AA r in R`</p></li>
              <li style="list-style-type: none";><p>`=> n` kills everything in `R`</p></li>
              <li style="list-style-type: none";><p>Therefore, `n >= char(R)`</p></li>
              <li style="list-style-type: none";><p>We know that `char(R)*1 = 0 => n|char(R) => n <= char(R)`</p></li>
              <li style="list-style-type: none";><p>So `n = char(R)`</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `char(R) = 0` or `char(R) = p` for some prime number `p`</b></p></li>
                <li><p>Proof: Suppose that `R` is an integral domain and `char(R) != 0`. Suppose for a contradiction `char(R)` is not prime.</p></li>
                <li><p>If `char(R)` is not prime, `EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Notice that `(n*1)*(q*1) = (nq)*1 = p*1 = 0` where `(n*1)` and `(q*1)` are not equal to `0`</p></li>
                <li><p>This contradicts the fact that `R` is a domain</p></li>
              </div>
              <li><p>If `char(R) = n`, then the subring generated by `1` in `R` is isomorphic to `ZZ // nZZ`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R` is a commutative ring without zero divisors. (`R` is not necessarily unital.) Show that `char(R)` is `0` or prime.</b></p></li>
                <li><p>Proof: Suppose `R` is commutative with no zero divisors. Let `p = char(R)` and suppose `p != 0`. Suppose for a contradiction that `p` is not prime.</p></li>
                <li><p>`=> EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Claim: we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>Suppose not. Then for all `r in R`, `n*r = 0` and `q*r = 0`</p></li>
                <li><p>But `1 < n, q < p = char(R)`</p></li>
                <li><p>This contradicts the fact that `p` is the least nonnegative integer `s.t.` `p*r = 0` `AA r in R`</p></li>
                <li><p>Thus, we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>`(n*a) * (q*b) = (n*q)*(a*b) = p*(a*b) = 0`</p></li>
                <li><p>This contradicts the assumption that `R` does not have zero divisors</p></li>
              </div>
              <div class="proof">
                <li><p><b>Suppose `R` is a commutative ring with prime characteristic `p`. Show that `(x + y)^p = x^p + y^p, AA x, y in R` and `(x + y)^(p^n) = x^(p^n) + y^(p^n)`, for all positive integers `n`</b></p></li>
                <li><p>Proof: `(x + y)^p = sum_(i = 0)^p ((p), (i)) x^iy^(p-i) = ((p), (0))x^0y^(p) + ((p), (1))xy^(p-1) + ... + ((p), (p-1))x^(p-1)y + ((0), (p))x^p`</p></li>
                <li><p>`= y^p + pxy^(p-1) + ((p), (2))x^2y^(p-2) + ... + ((p), (p-2))x^(p-2)y^2 + px^(p-1)y + x^p`</p></li>
                <li><p>It suffices to show that `((p), (i))` is divisible by `p`</p></li>
                <li><p>`((p), (i)) = (p!) / ((p-i)!p!) = (p * ... * (p-i+1) * (p-i) * ... * 1) / ((p-i)*...*1*i!)`</p></li>
                <li><p>` = (p*...*(p-i+1)) / (i!) = p(((p-1)*...*(p-i+1)) / (i!))`</p></li>
                <li><p>`=> p` divides `((p), (i))`</p></li>
                <li><p>So `y^p + p(_) + ... + p(_) + x^p = y^p + x^p`</p></li>
                <li><p>Base Case: We just proved `(x+y)^(p^1) = x^(p^1) + y^(p^1)` for all `x, y in R`</p></li>
                <li><p>Inductive Hypothesis: Assume that for some integer `k >= 1`, `(x+y)^(p^k) = x^(p^k) + y^(p^k)`</p></li>
                <li><p>`(x+y)^(p^(k+1)) = ((x+y)^(p^k))^p = (x^(p^k) + y^(p^k))^p = ((x^(p^k))^p + (y^(p^k))^p)`</p></li>
                <li><p>`= x^(p^(k+1)) + y^(p^(k+1))`</p></li>
                <li><p>By induction, `(x+y)^(p^n) = x^(p^n) + y^(p^n), AA n in ZZ^+`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a finite commutative ring with unity. Prove that every nonzero element of `R` is either a zero-divisor or a unit</b></p></li>
                <li><p>Proof: Let `a != 0` be a non zero-divisor. We claim that `a` is a unit</p></li>
                <li><p>Define `phi_a: R -> R`, `x |-> ax`. We claim that `phi_a` is injective</p></li>
                <li><p>Suppose `x, y in R` `s.t.` `phi_a (x) = phi_a (y)`</p></li>
                <li><p>Then `ax = ay <=> a(x-y) = 0`</p></li>
                <li><p>Since `a` is not a zero divisor and `a != 0`, `x-y = 0 <=> x = y`</p></li>
                <li><p>By the Pigeonhole Principle, `phi_a` is also surjective</p></li>
                <li><p>If we fix `1 in R`, we can find `b in R` `s.t.` `phi_a (b) = 1 <=> ab = 1 => a` is a unit</p></li>
              </div>
              <li><p>Let `R` be an integral domain. A subdomain `S` of `R` is a subring of `R` `s.t.` `S` contains the `1` element of `R`.</p></li>
              <div class="proof">
                <li><p><b>Exercise: Let `P = {n*1 | n in ZZ} sube R`. Show that `P` is contained in every subdomain. What is the order of `P`?</b></p></li>
                <li><p>Proof: Let `S` be a subdomain of `R`. We claim that `P sube S`</p></li>
                <li><p>Any element of `P` has the form `n*1` for some integer `n`</p></li>
                <li><p>Case 1 `(n = 0)`: `0*1 = 0 in S`</p></li>
                <li><p>Case 2 `(n > 0)`: `n*1 = sum_(i = 1)^n 1 in S` because `S` is closed under addition</p></li>
                <li><p>Case 3 `(n < 0)`: `n = -n', n' > 0`. `n'*1 in S => -n'*1 in S` so `S` is closed under taking additive inverses</p></li>
                <li><p>Therefore `P sube S`</p></li>
                <li><p>Claim: the order of `P = char(R)`</p></li>
                <li><p>If `n*1 = 0 in R, n*1 = 0 in P`</p></li>
                <li><p>`n = char(R), o rd(P) | char(R) => o rd(P) <= char(R)`</p></li>
                <li><p>`o rd(P)*1 = 0 in P => o rd(P)*1 = 0 in R => char(R) <= o rd(P)`</p></li>
              </div>
              <li><p>A ring element `a` is idempotent if `a^2 = a`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Prove that the only idempotent elements of an integral domain are `0` and `1`</b></p></li>
                <li><p>Proof: If `a` is idempotent, then `a^2 = a <=> a^2 - a = 0 <=> a(a-1) = 0`</p></li>
                <li><p>`<=> a = 1` or `a = 0`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ideals">
            <h3>Ideals</h3>
            <ul>
              <li><p>From group theory, the cosets of a normal subgroup `N` in a group `G` form a group themselves</p></li>
              <li><p>It turns out that, with rings, the quotient of a ring by an arbitrary subring need not be a ring itself</p></li>
              <li><p><b>Definition: A (two-sided) <u>ideal</u> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</b></p></li>
              <li><p><b>Definition: An <u>ideal</u> of a commutative ring `R` is a subset `I sube R` `s.t.` `I` is a subgroup of the additive group of `R` and `rI sube I` for all `r in R`</b></p></li>
              <li><p>Ex: Fix a ring `R`. The set consisting of `{0}` is an ideal generated by a single element</p></li>
              <li><p>Ex: `I = {f in CC[t]` `|` `t|f} = (t) = {tf}`</p></li>
              <li style="list-style-type: none";><p>Let `f, g in I => EE f', g' in CC[t]` `s.t.` `f = f't, g = g't`</p></li>
              <li style="list-style-type: none";><p>`f + g = f't + g't = t(f' + g')`</p></li>
              <li style="list-style-type: none";><p>Let `h in CC[t], f in I => EE f' in CC[t]` `s.t.` `f = f't`</p></li>
              <li style="list-style-type: none";><p>Then `hf = h*f't = t(hf') in I`</p></li>
              <li><p>This is an example of a principle ideal: an ideal generated by a single element</p></li>
              <li><p>Ex: Given a ring `R` and elements `a_1, ..., a_n in R`, we can consider the set of all `R`-linear combinations of `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>`{r_1a_1 + ... + r_na_n | r_i in R} = (a_1, ..., a_n)` is the ideal generated by `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>Let `sum_(i = 1)^n r_ia_i, sum_(i = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i = sum_(i = 1)^n (r_i-s_i)a_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>Let `r in R, sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `r*sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`r*sum_(i = 1)^n r_ia_i = sum_(i = 1)^n rr_ia_i in (a_1, ..., a_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Given two ideals `I, J in R`, let `I+J = {i + j | i in I, j in J}`. Show that `I+J` is an ideal</b></p></li>
                <li><p>Proof: Let `i_1 + j_1 in I + J` and `i_2 + j_2 in I + J` for `i_1, i_2 in I` and `j_1, j_2 in J`</p></li>
                <li><p>`(i_1 + j_1) - (i_2 + j_2) = (i_1 - i_2) + (j_1 - j_2) in I + J`</p></li>
                <li><p>Let `i + j in I + J`. Let `r in R`.</p></li>
                <li><p>`r(i + j) = ri + rj in I + J` and `(i + j)r = ir + ij in I + J`</p></li>
              </div>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>
