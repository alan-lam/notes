<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
    -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
    <title>Abstract Algebra II</title>
    <link href="math_103b.css" rel="stylesheet">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </head>
  <body>
    <nav class="navbar navbar-expand-sm navbar-light bg-light fixed-top">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNavDropdown">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home</a>
          </li>
          <!-- <li class="nav-item">
            <a class="nav-link" href="#" target="_blank">Cheat Sheets</a>
          </li> -->
        </ul>
      </div>
    </nav>
    <div class="toc">
      <ul>
        <a class="toc_link" href="#rings"><li>Rings</li></a>
        <a class="toc_link" href="#integral_domains"><li>Integral Domains</li></a>
        <a class="toc_link" href="#ideals"><li>Ideals</li></a>
        <a class="toc_link" href="#quotient_rings"><li>Quotient Rings</li></a>
        <a class="toc_link" href="#ring_homomorphisms"><li>Ring Homomorphisms</li></a>
      </ul>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-md-9">
          <h1>Abstract Algebra II</h1>
          <div class="proof">
            <p>A <b>ring</b> is a set `R` with two operations `+, *` such that `(R, +)` is an abelian group, `*` is associative, and `+,*` follow distributivity rules</p>
            <p>Subring Test: `a, b in S => a-b in S, ab in S` where `S sube R`</p>
            <p>An <b>integral domain</b> is a commutative ring with unity and no zero-divisors</p>
            <p>Check if S is an integral domain: `ab = 0 => a = 0` or `b = 0` for `a, b in S`</p>
            <p>A <b>field</b> is a commutative ring with unity in which every nonzero element has a multiplicative inverse (`i.e.` every nonzero element is a unit)</p>
            <p>Subfield Test: `a, b (b != 0) in K => a-b in K, ab^(-1) in K` where `K sube F`</p>
            <p>An <b>ideal</b> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</p>
            <p>Ideal Test: `a, b in A => a-b in A` and `a in A, r in R => ra in A` and `ar in A` where `A sube R`</p>
          </div>
          <div class="content" id="rings">
            <h3>Rings</h3>
            <ul>
              <li><p>Rings are modeled on the integers</p></li>
              <li><p>(`ZZ`, +) is an abelian group</p></li>
              <li><p>`ZZ` also has multiplication which satisfies</p></li>
              <li style="list-style-type: none";><p>`a*(b + c) = a*b + a*c`</p></li>
              <li style="list-style-type: none";><p>`(b + c)*a = b*a + c*a`</p></li>
              <li style="list-style-type: none";><p>`a*(b*c) = (a*b)*c`</p></li>
              <li><p><b>Def: A <u>ring</u> is a set `R` with two operations `+`, `*` such that (`R`, `+`) is an abelian group and</b></p></li>
              <li style="list-style-type: none";><p><b>1) `a*(b*c) = (a*b)*c` (`*` is associative)</b></p></li>
              <li style="list-style-type: none";><p><b>2) `a*(b + c) = a*b + a*c`, `(b + c)*a = b*a + c*a` for all `a, b, c in R`</b></p></li>
              <li><p>Ex: the set of integer multiples of 3 is a ring, `3ZZ`</p></li>
              <li><p>Ex: the real numbers, `RR`</p></li>
              <li><p>Ex: the set of real valued functions `f:[a,b]->ZZ`</p></li>
              <li><p>Ex: let V be a finite dimensional real vector space. Then `End_RR (V) = {phi: V -> V}` forms a ring</p></li>
              <li style="list-style-type: none";><p>the multiplication operation is function composition</p></li>
            </ul>
            <h5>Properties of Rings</h5>
            <ul>
              <li><p>The second 3 rings (`1in RR`; `f(x) = 1, AA x in [a,b]`; `i``d_v`) have a <u>multiplicative identity</u></p></li>
              <li style="list-style-type: none";><p>`a*1 = 1*a = a` (1 is the multiplicative identity)</p></li>
              <li style="list-style-type: none";><p>But `3a*3b != 3a`</p></li>
              <li><p>In `RR` and `{f:[a,b]->RR}`, multiplication is commutative</p></li>
              <li><p>`RR` is the only one of these rings with the property that every nonzero element of `RR` has a multiplicative inverse</p></li>
              <li><p>`AA a in RR`, `EE b in RR` `s.t. a*b = b*a = 1`</p></li>
              <li><p>Rings with a `1` element are said to be <u>unital</u></p></li>
              <li><p>`1` is called a "unity"</p></li>
              <li><p>Given a ring `R`, the elements of `R` which have a multiplicative inverse (2-sided) are called the <u>units</u> of `R`</p></li>
            </ul>
            <h5>Terminology</h5>
            <ul>
              <li><p>Given a commutative ring `R`, `a, b in R`, we say `a` divides `b` `a`|`b` if `EE c in R` `s.t. a*c = b`</p></li>
              <li><p>Since rings are additive groups under addition, given `n in ZZ^+`, we can make sense of `n*a = sum_(i=1)^n a`</p></li>
              <li><p>We define `-n*a = -sum_(i=1)^n a` when `n` is positive</p></li>
              <li><p>`0*a = 0`</p></li>
            </ul>
            <h5>Propositions</h5>
            <ul>
              <li><p>Suppose `a, b, c in R`. Then we have the following properties of multiplication</p></li>
              <li><p>`a*0 = 0*a = 0` (`0 in R`, the additive identity)</p></li>
              <li><p>`a*(-b) = -a*b`</p></li>
              <li><p>`(-a)(-b) = a*b`</p></li>
              <li><p>`a*(b-c) = a*b-a*c`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m+n)*a = (m*a) + (n*a)`</p></li>
              <li><p>given any integer `m in ZZ`, `m*(a*b) = (m*a)*b = (a)*(m*b)`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m*a)*(n*b) = (m*n)*(a*b)`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(a+b) = n*a + n*b`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(-a) = -(n*a)`</p></li>
              <li style="list-style-type: none";><p>If `R` is unital, then</p></li>
              <li><p>`(-1)*a = -a` where `-1 in R`</p></li>
              <li><p>`(-1)(-1) = 1`</p></li>
              <li><p>unity is unique</p></li>
              <li><p>if `a` has a left multiplicative inverse and a right multiplicative inverse, then they are equal</p></li>
              <li><p>multiplicative inverses are unique</p></li>
            </ul>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*0 = 0*a = 0`</b></p></li>
                <li><p>`0+0 = 0`</p></li>
                <li><p>`a*(0 + 0 = 0)`</p></li>
                <li><p>`= a*0 + a*0 = a*0`</p></li>
                <li><p>`=> a*0 = 0`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(-b) = -a*b`</b></p></li>
                <li><p>`a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`a*(b + (-b)) = a*b + a(-b) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `a*(-b) = -(a*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(-a)(-b) = a*b`</b></p></li>
                <li><p>`-a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`-a*(b + (-b)) = -a*b + (-a)*(-b)`</p></li>
                <li><p>By uniqueness of the additive inverse, `(-a)*(-b) = a*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(b - c) = a*b - b*c`</b></p></li>
                <li><p>`a*(b - c) = a*(b + (-c))`</p></li>
                <li><p>`= a*b + a*(-c)`</p></li>
                <li><p>`= a*b + (-a*c) = a*b - a*c`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m + n)*a = (m*a) + (n*a)`</b></p></li>
                <li><p>When `m, n > 0, (m*a) + (n*a) = sum_(i=1)^m a + sum_(j=1)^n a = sum_(k=1)^(m+n) a = (m + n)*a`</p></li>
                <li><p>Suppose `n < 0`, then we can write `n = -n'` where `n' > 0`. `(m + n)*a = (m - n') * a`</p></li>
                <li style="list-style-type: none";><p>1) When `m > n'`, we can write `m - n' = m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m - n')*a = sum_(i = 1)^(m-n') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a = (m*a) - (n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (-n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (n*a)`</p></li>
                <li style="list-style-type: none";><p>2) If `m < n'`, we can write `m - n' = -m'` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m + n)*a = (m - n')*a = (-m')*a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>Notice: `sum_(i = 1)^(m') a = sum_(i = 1)^(n') a - sum_(j = 1)^m a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^(m') a + (- sum_(i=1)^(m') a) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `- sum_(i = 1)^(m') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^m a - sum_(j = 1)^(n') a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>`(m*a) - (n*a) = (m*a) + (-n'*a) = (m*a) + (n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `m*(a*b) = (m*a)*b = (a)*(m*b)`</b></p></li>
                <li><p>If `m = 0,`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*b = 0*b = 0`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b) = 0*a*b = 0`</p></li>
                <li style="list-style-type: none";><p>`(a)*(m*b) = (a)*(0*b) = 0`</p></li>
                <li><p>Suppose `m` is positive. Then `m*(a*b) = sum_(i = 1)^m a*b = (sum_(i = 1)^m a)*b = (m*a)*b`</p></li>
                <li><p>If `m` is negative, we can write `m = -m` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (m + m')*(a*b) = m*(a*b) + m'*(a*b) = m*(a*b) + a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b) + a(m'*b) = a*(m*b + m'*b) = a*((m+m')*b)) = 0`</p></li>
                <li style="list-style-type: none";></li><p>By uniqueness of the additive inverse, `a*(m*b) = m*(a*b)`</p>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m*a)*(n*b) = (m*n)*(a*b)`</b></p></li>
                <li><p>If `m, n` are both positive, `(m*a)*(n*b) = (sum_(i = 1)^m a)*(sum_(j = 1)^n b) = sum_(k = 1)^(m*n) a*b = (m*n)*(a*b)`</p></li>
                <li><p>If `m, n` are both negative, `EE m', n' > 0` `s.t. m = -m', n = -n'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) = (-m'*a)*(-n'*b) = -(m'*a)*(-(n'*b)) = (m'*a)*(n'*b)`</p></li>
                <li style="list-style-type: none";><p>`= (m'*n')*(a*b) = ((-m')*(-n'))*(a*b) = (m*n)*(a*b)`</p></li>
                <li><p>If `m` is negative and `n` is positive, there exists `m' > 0` `s.t. m = -m'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) + (m'*a)*(n*b) = ((m*a) + (m'*a))*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*a)*(n*b)) = 0`</p></li>
                <li style="list-style-type: none";><p>`(m'*a)*(n*b) = (m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) + (m'*n)*(a*b) = (m*n + m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*n)*(a*b) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `(m*n)*(a*b) = -(m'*a)*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) = (-m'*a)*(n*b) = (m*a)*(n*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(a + b) = n*a + n*b`</b></p></li>
                <li><p>If `n` is positive, `n*(a + b) = sum_(i = 1)^n (a + b) = sum_(i = 1)^n a + sum_(i = 1)^n b = (n*a) = (n*b)`</p></li>
                <li><p>If `n` is negative, we can write it as `-n'` where `n' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (n + n')*(a + b) = n*(a + b) + n'*(a + b) = n*(a + b) + n'*a + n'*b`</p></li>
                <li style="list-style-type: none";><p>But `n*a + n*b + n'*a + n'*b = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `n*(a + b) = n*a + n*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(-a) = -(n*a)`</b></p></li>
                <li><p>`0 = n*(a + (-a)) = (n*a) + n*(-a)`</p></li>
                <li><p>Also know `(n*a) + (-n*a) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `n*(-a) = (-n*a) = -(n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS unity is unique</b></p></li>
                <li><p>Suppose `1, 1'` are both unity elements of `R`</p></li>
                <li><p>On one hand, `1` is a mult. identity `=> 1*1' = 1'`</p></li>
                <li><p>On the other hand, `1'` is a mult. identity `=> 1*1' = 1`</p></li>
                <li><p>`=> 1 = 1'`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS if `a` has a left mult. inverse and a right mult. inverse, then they are equal</b></p></li>
                <li><p>Suppose `b` is a left mult. inverse of `a` and `c` is a right mult. inverse of `a`</p></li>
                <li><p>`b*a = 1, a*c = 1`</p></li>
                <li><p>`b = b*1 = b*(a*c) = (b*a)*c = 1*c = c`</p></li>
              </ul>
            </div>
            <h5>Subrings</h5>
            <ul>
              <li><p><b>Def: A <u>subring</u> of a ring `R` is a subset `S sube R` which is a ring with the operations of `+` and `*` restricted to `S`</b></p></li>
              <li><p>Unwinding this definition, we see that `+: SxxS->R`, `(s_1, s_2)|->s_1 + s_2` must have image contained in `S` (closed under addition) and `*: SxxS->R`, `(s_1, s_2)|->s_1*s_2` must have image contained in `S` (closed under multiplication)</p></li>
              <li><p>We must have `0 in S` and for every `s in S, -s in S` (closed under taking additive inverses)</p></li>
              <li><p><b>In fact, we see that `S` is a subring if and only if `s_1 - s_2 in S` and `s_1*s_2 in S`, `AA s_1, s_2 in S`</b></p></li>
              <li><p>Ex: `3ZZ sube ZZ` is a subring of `ZZ`</p></li>
              <li><p>Ex: `QQ sube RR` is a subring of `RR`</p></li>
              <li><p>Ex: `{lambda Id}_(lambda in R) sube End_RR(V)` where `V` is a finite dimensional real vector space</p></li>
            </ul>
            <h5>Exercises</h5>
            <ul>
              <li><p>Let `R_1, ..., R_n` be rings. The direct sum of `R_1, ..., R_n`, `R_1 o+ R_2 o+ ... o+ R_n` is the set which is the Cartesian product `prod_(i = 1)^n R_i` with ring operations performed component-wise</p></li>
              <li><p>`(a_1, ..., a_n) + (b_1, ..., b_n) = (a_1 + b_1, ..., a_n + b_n)`</p></li>
              <li><p>`(a_1, ..., a_n) * (b_1, ..., b_n) = (a_1 * b_1, ..., a_n * b_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R_1, ..., R_n` are rings with nonzero elements. Show that `R = R_1 o+ ... o+ R_n` has unity `<=>` each `R_i` has a unity</b></p></li>
                <li><p>(`=>`) Assume `R` has unity, say `(e_1, ..., e_n)`. We want to show that each `R_i` has a unity element. We need to show that `e_i` is the mult. identity of `R_i` for each `i`.</p></li>
                <li><p>Need to show: given `r_i in R_i`, `e_i*r_i = r_i*e_i = r_i`</p></li>
                <li><p>Consider a function `f:R_j->R_1 o+ ... o+ R_n, r_j |-> (0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>We know that `(0, ..., 0, r_j, 0, ..., 0) * (e_1, ..., e_n) = (0, ..., 0, r_j, 0, ..., 0) = (e_1, ..., e_n)*(0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>`=> (0*e_1, ..., r_j*e_j, ..., 0*e_n) = (e_1*0, ..., e_j*r_j, ..., 0*e_n)`</p></li>
                <li><p>`=> (0, ..., 0, r_j*e_j, 0, ..., 0) = (0, ..., 0, e_j*r_j, 0, ..., 0)`</p></li>
                <li><p>This shows that `e_j*r_j = r_j = r_j*e_j, AA r in R_j => e_j` is a mult identity of `R_j`</p></li>
                <li><p>(`lArr`) Assume that each `R_i` has a mult. identity. We need to show that `R` does too.</p></li>
                <li><p>Say `e_i` is the mult. identity of `R_i`. We claim that `(e_1, ..., e_n)` is the mult. identity of `R`. We must show that `(e_1, ..., e_n)*(r_1, ..., r_n) = (r_1, ..., r_n)*(e_1, ..., e_n) = (r_1, ..., r_n), AA (r_1, ..., r_n) in R`</p></li>
                <li><p>`(e_1, ..., e_n)*(r_1, ..., r_n) = (e_1*r_1, ..., e_n*r_n) = (r_1, ..., r_n)`</p></li>
                <li><p>`(r_1, ..., r_n)*(e_1, ..., e_n) = (r_1*e_1, ..., r_n*e_n) = (r_1, ..., r_n)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is a positive even integer `n` `s.t. a^n = a` for all `a in R`. Show that `-a = a` for all `a in R`.</b></p></li>
                <li><p>We can write `n = 2k` for some positive integer `k`</p></li>
                <li style="list-style-type: none";><p>`-a = (-a)^n = (-a)^(2k) = ((-a)^2)^k = (a^2)^k = a^(2k) = a^n = a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is an integer `n > 1` such that `x^n = x, AA x in R`. If `m` is a positive integer such that `a^m = 0` for some `a`, show that `a = 0`</b></p></li>
                <li><p>Case 1: `m <= n`</p></li>
                <li style="list-style-type: none";><p>`a = a^n = a^m * a^(n-m) = 0 * a^(n-m) = 0`</p></li>
                <li><p>Case 2: `m > n`</p></li>
                <li style="list-style-type: none";><p>Choose `m` to be the smallest positive integer `s.t. a^m = 0`</p></li>
                <li style="list-style-type: none";><p>Suppose for a contradiction `m > n`</p></li>
                <li style="list-style-type: none";><p>`0 = a^m = a^n * a^(m-n) = a*a^(m-n) = a^(m-n+1)`</p></li>
                <li style="list-style-type: none";><p>Since m was chosen to be the smallest positive integer with this property, `m-n+1 >= m => -n + 1 >= 0 => 1 >= n`</p></li>
                <li style="list-style-type: none";><p>This contradicts the assumption that `n > 1`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="integral_domains">
            <h3>Integral Domains</h3>
            <ul>
              <li><p>`ZZ` has more structure than an arbitrary ring does</p></li>
              <li><p>`ZZ` is a commutative ring</p></li>
              <li><p>`ZZ` has a mult. identity</p></li>
              <li><p>`ZZ` has the property that if `a, b != 0`, then `ab != 0`</p></li>
              <li><p><b>Def: A <u>zero-divisor</u> in a commutative ring is a nonzero element `z in R` `s.t.` there exists a nonzero element `y in R` `s.t.` `zy = 0`</b></p></li>
              <li><p><b>Def: An <u>integral domain</u> is a unital commutative ring `R` `s.t.` if `a, b in R` `s.t. ab = 0`, then either `a = 0` or `b = 0`</b></p></li>
              <li><p>We almost have division in integral domains: we have cancellation</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `R` be a domain. Suppose that `a != 0 in R`. Then `ab = ac => b= c`</b></p></li>
                <li><p>`ab = ac => ab - ac = 0 => a(b-c) = 0`</p></li>
                <li><p>Since `a != 0`, `b-c = 0 => b = c`</p></li>
              </div>
              <li><p>Ex: `QQ` is a domain</p></li>
              <li><p>Ex: the Gaussian integers `ZZ[i] = {a + bi | a, b in ZZ}` is a domain</p></li>
              <li><p>Ex: `CC[x]` - the ring of polynomials in a single indeterminate `x` with coefficients `in CC` is a domain</p></li>
              <li><p>NonEx: `ZZ // (4ZZ)` is not a domain because `[2]_4 * [2]_4 = [4]_4 = [0]_4`</p></li>
              <li><p><b>Def: A <u>field</u> is a domain `F` `s.t.` every nonzero element of `F` has a mult. inverse</b></p></li>
              <li><p>Ex: `RR` is a field</p></li>
              <li><p>Ex: `CC(t) = {f(t)/g(t) | f(t), g(t) in CC(t)}` the ring of rational functions whose coefficients are in `CC` is a field</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `D` be a finite integral domain. Then `D` is a field.</b></p></li>
                <li><p>Need to show that every nonzero element has a mult. inverse</p></li>
                <li><p>Let `a != 0 in D`. Consider the function `phi_a: D->D`, `y |-> ay`</p></li>
                <li><p>If we show that `phi_a` is surjective, then we are done</p></li>
                <li><p>Since `D` is finite, by the pigeonhole principle, `phi_a` is surjective `<=> phi_a` is injective</p></li>
                <li><p>Therefore, it suffices to show that `phi_a` is injective</p></li>
                <li><p>Suppose `b, c in D` `s.t.` `phi_a(b) = phi_a(c) => ab = ac`</p></li>
                <li><p>Since `a != 0` and `D` is a domain, we conclude that `b = c => phi_a` is injective</p></li>
                <li><p>Since `phi_a` is surjective, if we fix `1 in D`, we can find an element `b in D` `s.t.` `phi_a(b) = ab = 1 => b` is the mult. inverse of `a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Corollary: `ZZ // pZZ` is a field `<=> p` is prime</b></p></li>
                <li><p>(`=>`) Suppose `ZZ // pZZ` is a field but `p` is not prime</p></li>
                <li><p>Then `p = qr`, `1 < q, r < p`</p></li>
                <li><p>Then `[q]_p*[r]_p = [p]_p = [0]_p => ZZ // pZZ` has zero-divisors, which contradicts `ZZ // pZZ` is a field</p></li>
                <li><p>(`lArr`) If `p` is prime, then we must show `ZZ // pZZ` is a domain by the previous result</p></li>
                <li><p>Suppose `[a]_p * [b]_p = [0]_p <=> ab = pk` for some integer `k`</p></li>
                <li><p>`p` prime `=> p|ab <=> p|a` or `p|b <=> [a]_p = [0]_p` or `[b]_p = [0]_p => ZZ // pZZ` is a domain</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain and `S` is a subring of `R` which contains `1 in R`, then `S` itself is an integral domain</b></p></li>
                <li><p>`S` is commutative &#10003;</p></li>
                <li><p>`S` has a mult. identity &#10003;</p></li>
                <li><p>If `s_1, s_2 in S` `s.t.` `s_1*s_2 = 0 in S`, this same equation holds in `R`</p></li>
                <li><p>Since `R` is a domain, `s_1s_2 = 0 => s_1 = 0 or s_2 = 0`</p></li>
              </div>
              <li><p>Ex: Notice that in `ZZ // nZZ`, `n[a]_n = [na]_n = [0]_n`</p></li>
              <li style="list-style-type: none";><p>Multiplication by `n` kills all elements of `ZZ // nZZ`</p></li>
              <li><p>Ex: Consider `CC` (along with all subrings `R` of `CC` containing `1`). There does not exist a positive integer `n` `s.t.` `n*z = 0` `AA z in CC` and `n*z = 0` `AA z in R`</p></li>
              <li style="list-style-type: none";><p>The only integer which kills all of `CC` (or `R`) is `0`</p></li>
              <li><p>The integer `n` in these examples is called the characteristic of the ring</p></li>
              <li><p><b>Def: the <u>characteristic</u> of a ring `R` is the least nonnegative integer `n` `s.t.` `n*r = 0` `AA r in R`</b></p></li>
              <li><p>`char(ZZ // nZZ) = n`, `char(CC) = 0`</p></li>
              <li><p>When `R` is a unital commutative ring, we can relate `char(R)` to the order of `1 in R` (as an abelian group under `+`)</p></li>
              <li><p>If `1` has infinite order in `R`, then `char(R) = 0`</p></li>
              <li><p>If `1` has finite order, say `n`, then `char(R) = n`</p></li>
              <li style="list-style-type: none";><p>Since `o``rd(1) = n, n*1 = 0`</p></li>
              <li style="list-style-type: none";><p>`n*r = (n*1)r = 0` `AA r in R`</p></li>
              <li style="list-style-type: none";><p>`=> n` kills everything in `R`</p></li>
              <li style="list-style-type: none";><p>Therefore, `n >= char(R)`</p></li>
              <li style="list-style-type: none";><p>We know that `char(R)*1 = 0 => n|char(R) => n <= char(R)`</p></li>
              <li style="list-style-type: none";><p>So `n = char(R)`</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `char(R) = 0` or `char(R) = p` for some prime number `p`</b></p></li>
                <li><p>Suppose that `R` is an integral domain and `char(R) != 0`. Suppose for a contradiction `char(R)` is not prime.</p></li>
                <li><p>If `char(R)` is not prime, `EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Notice that `(n*1)*(q*1) = (nq)*1 = p*1 = 0` where `(n*1)` and `(q*1)` are not equal to `0`</p></li>
                <li><p>This contradicts the fact that `R` is a domain</p></li>
              </div>
              <li><p>If `char(R) = n`, then the subring generated by `1` in `R` is isomorphic to `ZZ // nZZ`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R` is a commutative ring without zero divisors. (`R` is not necessarily unital.) Show that `char(R)` is `0` or prime.</b></p></li>
                <li><p>Suppose `R` is commutative with no zero divisors. Let `p = char(R)` and suppose `p != 0`. Suppose for a contradiction that `p` is not prime.</p></li>
                <li><p>`=> EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Claim: we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>Suppose not. Then for all `r in R`, `n*r = 0` and `q*r = 0`</p></li>
                <li><p>But `1 < n, q < p = char(R)`</p></li>
                <li><p>This contradicts the fact that `p` is the least nonnegative integer `s.t.` `p*r = 0` `AA r in R`</p></li>
                <li><p>Thus, we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>`(n*a) * (q*b) = (n*q)*(a*b) = p*(a*b) = 0`</p></li>
                <li><p>This contradicts the assumption that `R` does not have zero divisors</p></li>
              </div>
              <div class="proof">
                <li><p><b>Suppose `R` is a commutative ring with prime characteristic `p`. Show that `(x + y)^p = x^p + y^p, AA x, y in R` and `(x + y)^(p^n) = x^(p^n) + y^(p^n)`, for all positive integers `n`</b></p></li>
                <li><p>`(x + y)^p = sum_(i = 0)^p ((p), (i)) x^iy^(p-i) = ((p), (0))x^0y^(p) + ((p), (1))xy^(p-1) + ... + ((p), (p-1))x^(p-1)y + ((0), (p))x^p`</p></li>
                <li><p>`= y^p + pxy^(p-1) + ((p), (2))x^2y^(p-2) + ... + ((p), (p-2))x^(p-2)y^2 + px^(p-1)y + x^p`</p></li>
                <li><p>It suffices to show that `((p), (i))` is divisible by `p`</p></li>
                <li><p>`((p), (i)) = (p!) / ((p-i)!p!) = (p * ... * (p-i+1) * (p-i) * ... * 1) / ((p-i)*...*1*i!)`</p></li>
                <li><p>` = (p*...*(p-i+1)) / (i!) = p(((p-1)*...*(p-i+1)) / (i!))`</p></li>
                <li><p>`=> p` divides `((p), (i))`</p></li>
                <li><p>So `y^p + p(_) + ... + p(_) + x^p = y^p + x^p`</p></li>
                <li><p>Base Case: We just proved `(x+y)^(p^1) = x^(p^1) + y^(p^1)` for all `x, y in R`</p></li>
                <li><p>Inductive Hypothesis: Assume that for some integer `k >= 1`, `(x+y)^(p^k) = x^(p^k) + y^(p^k)`</p></li>
                <li><p>`(x+y)^(p^(k+1)) = ((x+y)^(p^k))^p = (x^(p^k) + y^(p^k))^p = ((x^(p^k))^p + (y^(p^k))^p)`</p></li>
                <li><p>`= x^(p^(k+1)) + y^(p^(k+1))`</p></li>
                <li><p>By induction, `(x+y)^(p^n) = x^(p^n) + y^(p^n), AA n in ZZ^+`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a finite commutative ring with unity. Prove that every nonzero element of `R` is either a zero-divisor or a unit</b></p></li>
                <li><p>Let `a != 0` be a non zero-divisor. We claim that `a` is a unit</p></li>
                <li><p>Define `phi_a: R -> R`, `x |-> ax`. We claim that `phi_a` is injective</p></li>
                <li><p>Suppose `x, y in R` `s.t.` `phi_a (x) = phi_a (y)`</p></li>
                <li><p>Then `ax = ay <=> a(x-y) = 0`</p></li>
                <li><p>Since `a` is not a zero divisor and `a != 0`, `x-y = 0 <=> x = y`</p></li>
                <li><p>By the Pigeonhole Principle, `phi_a` is also surjective</p></li>
                <li><p>If we fix `1 in R`, we can find `b in R` `s.t.` `phi_a (b) = 1 <=> ab = 1 => a` is a unit</p></li>
              </div>
              <li><p>Let `R` be an integral domain. A subdomain `S` of `R` is a subring of `R` `s.t.` `S` contains the `1` element of `R`.</p></li>
              <div class="proof">
                <li><p><b>Exercise: Let `P = {n*1 | n in ZZ} sube R`. Show that `P` is contained in every subdomain. What is the order of `P`?</b></p></li>
                <li><p>Let `S` be a subdomain of `R`. We claim that `P sube S`</p></li>
                <li><p>Any element of `P` has the form `n*1` for some integer `n`</p></li>
                <li><p>Case 1 `(n = 0)`: `0*1 = 0 in S`</p></li>
                <li><p>Case 2 `(n > 0)`: `n*1 = sum_(i = 1)^n 1 in S` because `S` is closed under addition</p></li>
                <li><p>Case 3 `(n < 0)`: `n = -n', n' > 0`. `n'*1 in S => -n'*1 in S` so `S` is closed under taking additive inverses</p></li>
                <li><p>Therefore `P sube S`</p></li>
                <li><p>Claim: the order of `P = char(R)`</p></li>
                <li><p>If `n*1 = 0 in R, n*1 = 0 in P`</p></li>
                <li><p>`n = char(R), o rd(P) | char(R) => o rd(P) <= char(R)`</p></li>
                <li><p>`o rd(P)*1 = 0 in P => o rd(P)*1 = 0 in R => char(R) <= o rd(P)`</p></li>
              </div>
              <li><p>A ring element `a` is idempotent if `a^2 = a`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Prove that the only idempotent elements of an integral domain are `0` and `1`</b></p></li>
                <li><p>If `a` is idempotent, then `a^2 = a <=> a^2 - a = 0 <=> a(a-1) = 0`</p></li>
                <li><p>`<=> a = 1` or `a = 0`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ideals">
            <h3>Ideals</h3>
            <ul>
              <li><p>From group theory, the cosets of a normal subgroup `N` in a group `G` form a group themselves</p></li>
              <li><p>It turns out that, with rings, the quotient of a ring by an arbitrary subring need not be a ring itself</p></li>
              <li><p><b>Definition: A (two-sided) <u>ideal</u> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</b></p></li>
              <li><p><b>Definition: An <u>ideal</u> of a commutative ring `R` is a subset `I sube R` `s.t.` `I` is a subgroup of the additive group of `R` and `rI sube I` for all `r in R`</b></p></li>
              <li><p>Ex: Fix a ring `R`. The set consisting of `{0}` is an ideal generated by a single element</p></li>
              <li><p>Ex: `I = {f in CC[t]` `|` `t|f} = (t) = {tf}`</p></li>
              <li style="list-style-type: none";><p>Let `f, g in I => EE f', g' in CC[t]` `s.t.` `f = f't, g = g't`</p></li>
              <li style="list-style-type: none";><p>`f + g = f't + g't = t(f' + g')`</p></li>
              <li style="list-style-type: none";><p>Let `h in CC[t], f in I => EE f' in CC[t]` `s.t.` `f = f't`</p></li>
              <li style="list-style-type: none";><p>Then `hf = h*f't = t(hf') in I`</p></li>
              <li><p>This is an example of a principle ideal: an ideal generated by a single element</p></li>
              <li><p>Ex: Given a ring `R` and elements `a_1, ..., a_n in R`, we can consider the set of all `R`-linear combinations of `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>`{r_1a_1 + ... + r_na_n | r_i in R} = (a_1, ..., a_n)` is the ideal generated by `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>Let `sum_(i = 1)^n r_ia_i, sum_(i = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i = sum_(i = 1)^n (r_i-s_i)a_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>Let `r in R, sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `r*sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`r*sum_(i = 1)^n r_ia_i = sum_(i = 1)^n rr_ia_i in (a_1, ..., a_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Given two ideals `I, J in R`, let `I+J = {i + j | i in I, j in J}`. Show that `I+J` is an ideal</b></p></li>
                <li><p>Let `i_1 + j_1 in I + J` and `i_2 + j_2 in I + J` for `i_1, i_2 in I` and `j_1, j_2 in J`</p></li>
                <li><p>`(i_1 + j_1) - (i_2 + j_2) = (i_1 - i_2) + (j_1 - j_2) in I + J`</p></li>
                <li><p>Let `i + j in I + J`. Let `r in R`.</p></li>
                <li><p>`r(i + j) = ri + rj in I + J` and `(i + j)r = ir + ij in I + J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be ideals of a ring `R`. Let `IJ = {sum_(k = 1)^n i_kj_k | i_k in I, j_k in J, n in ZZ^+}`. Show that `IJ` is an ideal</b></p></li>
                <li><p>Let `sum_(k = 1)^n i_kj_k, sum_(l = 1)^m i'_lj'_l in IJ`</p></li>
                <li><p>Then `sum_(k = 1)^n i_kj_k - sum_(l = 1)^m i'_lj'_l = sum_(k = 1)^n i_kj_k + sum_(l = 1)^m (-i'_l)(j'_l) in IJ`</p></li>
                <li><p>Let `r in R`. Let `sum_(k = 1)^n i_kj_k in IJ`</p></li>
                <li><p>`r*sum_(k = 1)^n i_kj_k = sum_(k = 1)^n ri_kj_k = sum_(k = 1)^n (ri_k)j_k in IJ`</p></li>
                <li><p>`(sum_(k = 1)^n i_kj_k)*r = ... = sum_(k = 1)^n i_k(j_kr) in IJ`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be two ideals of `R`. Show that `I nn J` is an ideal</b></p></li>
                <li><p>From group theory, since `I, J` are subgroups of `(R, +)`, `I nn J` is a subgroup of `(R, +)`</p></li>
                <li><p>Let `z in I nn J`. Let `r in R`. We claim that `rz, zr in I nn J`</p></li>
                <li><p>`z in I nn J => z in I => rz in I`</p></li>
                <li><p>`z in I nn J => z in J => rz in J`</p></li>
                <li><p>`=> rz in I nn J` (similarly for `zr`)</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: If `I` and `J` are two ideals in a unital commutative ring, show that `IJ sube I nn J`</b></p></li>
                <li><p>Let `i in I, j in J`</p></li>
                <li><p>`ij = (i)j in J` (`i in R, j in J`)</p></li>
                <li><p>`ij = i(j) in I` (`i in I, j in R`)</p></li>
                <li><p>`=> ij in I nn J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>If `I` and `J` are two ideals in a unital commutative ring `R` `s.t.` `I + J = R`, show that `IJ = I nn J`</b></p></li>
                <li><p>Since `I + J = R`, given any `r in R`, we can write `r = i + j` for some `i in I, j in J`</p></li>
                <li><p>In particular, `1 = i + j` for some `i in I, j in J`</p></li>
                <li><p>Let `z in I nn J`. We claim `z in IJ`</p></li>
                <li><p>`z = 1*z = (i + j)*z = iz + jz`</p></li>
                <li><p>`z in I nn J => z in I, z in J`</p></li>
                <li><p>Since `i in I, z in J, iz in IJ`</p></li>
                <li><p>Since `j in J, z in I, jz in IJ`</p></li>
                <li><p>So `iz + jz in IJ`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="quotient_rings">
            <h3>Quotient Rings</h3>
            <ul>
              <li><p>Let `R` be a ring and let `I` be an ideal</p></li>
              <li><p>Let `R//I = {r + I | r in R}`. We will put a ring structure on `R//I`</p></li>
              <li><p>From group theory, `R` is an abelian group under `+` and `I` is a subgroup</p></li>
              <li><p>Therefore, `R//I` is a group under `+`, which is defined as `(r_1 + I) + (r_2 + I) = (r_1 + r_2 + I)`</p></li>
              <li><p>We define multiplication by `(r_1 + I) * (r_2 + I) = (r_1r_2 + I)`</p></li>
              <div class="proof">
                <li><p>We claim that this is well-defined</p></li>
                <li><p>Suppose `r_1 + I = s_1 + I, r_2 + I = s_2 + I`</p></li>
                <li><p>We need to show that `r_1r_2 + I = s_1s_2 + I`</p></li>
                <li><p>`r_1 + I = s_1 + I <=> r_1 - s_1 in I`</p></li>
                <li><p>`r_2 + I = s_2 + I <=> r_2 - s_2 in I`</p></li>
                <li><p>Notice that `r_1r_2 + I = s_1s_2 + I <=> r_1r_2 - s_1s_2 in I`</p></li>
                <li><p>Since `r_1-s_1, r_2-s_2 in I`, we see that `(r_1-s_1)(r_2-s_2) = r_1r_2 - s_1r_2 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2 + (s_1s_2 - s_1s_2)`</p></li>
                <li><p>`= (r_1r_2 - s_1s_2) - s_1(r_2-s_2) - s_2(r_1-s_1)`</p></li>
                <li><p>`=> r_1r_2 - s_1s_2 in I`</p></li>
              </div>
              <li><p>Ex: `ZZ // nZZ` is the quotient of `ZZ` by the ideal `nZZ`</p></li>
              <li><p>Ex: Let's determine what the cosets of `(t)` in `CC[t]` are. What is `(CC[t])/((t))`?</p></li>
              <li style="list-style-type: none";><p>Given `f(t) in CC[t]`, we can consider the polynomial `f(t) - f(0)` which lies in `(t)`</p></li>
              <li style="list-style-type: none";><p>Therefore, `f(t) + (t) = f(0) + t` as cosets</p></li>
              <div class="proof" id="inzz">
                <li><p>Ex: Classify all ideals in `ZZ`. We claim that every ideal has the form `nZZ` for some `n in ZZ^+`</p></li>
                <li><p>Let `I != (0)` be an ideal of `ZZ`. Let `n` be the least positive integer in `I`</p></li>
                <li><p>We claim `I = nZZ`. It suffices to show that `n | m`, `AA m in I`</p></li>
                <li><p>Let `m != 0 in I`. Assume that `m > 0`. Consider `gcd(m,n)`</p></li>
                <li><p>By the Euclidean algorithm, we can write `gcd(m,n) = am + bn` for some `a, b in ZZ^+`</p></li>
                <li><p>`m, n in I => gcd(m,n) = am + bn in I`</p></li>
                <li><p>Therefore, `gcd(m,n) in I` but `0 < gcd(m,n) <= n => gcd(m,n) = n` (since `n` is the least positive integer in `I`) `=> n|m`</gcd></p></li>
                <li><p>If `m < 0`, then `-m in I` and the argument we just proved shows that `n|-m =>n|m`</0> </p></li>
              </div>
              <li><p>`pZZ` where `p` is prime is a "special type" of ideal</p></li>
              <li><p>Let `a, b in ZZ` `s.t.` `p|ab`. Then `p|a` or `p|b`</p></li>
              <li style="list-style-type: none";><p>`ab in pZZ <=> p|ab => p|a` or `p|b <=> a in pZZ` or `b in pZZ`</p></li>
              <li style="list-style-type: none";><p>So `ab in pZZ => a in pZZ` or `b in pZZ`</p></li>
              <li><p>If `aZZ, bZZ` are two ideals of `ZZ`, then `aZZ * bZZ sube pZZ => aZZ sube pZZ` or `bZZ sube pZZ`</p></li>
              <li><p>Such ideals with this property are called prime ideals</p></li>
              <li><p><b>Definition: An ideal `p sube R` is a <u>prime ideal</u> if `p` is a proper ideal and whenever `ab in p`, we must have `a in p` or `b in p` `AA a, b in R`</b></p></li>
              <div class="proof">
                <li><p><b>`pZZ` is a prime ideal `<=> p` is prime</b></p></li>
                <li><p>(`lArr`) We've already seen that if `p` is prime, then `pZZ` is a prime ideal</p></li>
                <li><p>(`=>`) Suppose `pZZ` is a prime ideal. It suffices to show that if `p = ab` where `a, b > 0`, then `p = a` or `p = b`</p></li>
                <li><p>If `p = ab`, then `ab in pZZ`</p></li>
                <li><p>Since `pZZ` is a prime ideal, we must have either `a in pZZ` or `b in pZZ`</p></li>
                <li><p>`a in pZZ <=> p|a` and `b in pZZ <=> p|b`</p></li>
                <li><p>Either `p|a` or `p|b`</p></li>
                <li><p>Since `a, b, p > 0`, `p|a` and `a|p` `=> a = p`</p></li>
                <li><p>`p|b` and `b|p` `=> b = p`</p></li>
                <li><p>`=> p` is a prime number</p></li>
              </div>
              <li><p><b>Definition: An ideal `m` of a commutative ring `R` is said to be <u>maximal</u> if `m sub R` (`m` is a proper ideal) and, whenever `I` is an ideal `s.t.` `m sube I`, we must have `I = m` or `I = R`</b></p></li>
              <li><p>Ex: Returning to `ZZ`, it turns out that `pZZ` is not only prime, but also maximal when `p` is prime</p></li>
              <div class="proof">
                <li><p><b>We claim `pZZ` is maximal</b></p></li>
                <li><p>Suppose `pZZ sube I` where `I` is an ideal of `ZZ`</p></li>
                <li><p><a href="#inzz">We've already seen that `I = nZZ` for some positive integer `n`</a></p></li>
                <li><p>Therefore, `pZZ sube nZZ`</p></li>
                <li><p>In particular, `p in pZZ sube nZZ => p in nZZ <=> n|p`</p></li>
                <li><p>Since `p` is prime, we either have `n = p` (`=> nZZ = pZZ`) or `n = 1` (`=> nZZ = ZZ`)</p></li>
                <li><p>So `pZZ` is maximal</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a commutative ring with unity, then the following are equivalent</b></p></li>
                <li><p><b>1) `p` is a prime ideal</b></p></li>
                <li><p><b>2) `R // p` is an integral domain</b></p></li>
                <li><p><b>and</b></p></li>
                <li><p><b>3) `M` is a maximal ideal</b></p></li>
                <li><p><b>4) `R // M` is a field</b></p></li>
                <li><p>(`1 => 2`): Suppose `p` is a prime ideal. We already know that `R // p` is a commutative ring with unity. We must show that `R // p` has no zero-divisors</p></li>
                <li><p>Suppose `(x + p)(y + p) = (0 + p) => (xy + p) = (0 + p) <=> xy in p`</p></li>
                <li><p>Since `p` is a prime ideal, `xy in p <=> x in p` or `y in p`</p></li>
                <li><p>If `x in p`, then `x + p = 0 + p`</p></li>
                <li><p>If `y in p`, then `y + p = 0 + p`</p></li>
                <li><p>Then `R // p` is an integral domain</p></li>
                <li><p>(`2 => 1`): Suppose `R // p` is an integral domain. Let `x, y in R` `s.t.` `xy in p`</p></li>
                <li><p>We claim that `x in p` or `y in p`</p></li>
                <li><p>Consider `(x + p)*(y + p) = (xy + p)`</p></li>
                <li><p>Since `xy in p, (xy + p) = (0 + p)`</p></li>
                <li><p>Since `R // p` is an integral domain, we must have either `x + p = 0 + p <=> x in p` or `y + p = 0 + p <=> y in p`</p></li>
                <li><p>Therefore `p` is prime</p></li>
                <li><p>(`3 => 4`): Assume that `M` is a maximal ideal</p></li>
                <li><p>Let `x + M != 0 + M in R // M`</p></li>
                <li><p>We claim that there exists `y + M in R // M` `s.t.` `(x + M)*(y + M) = 1 + M => xy + M = 1 + M`</p></li>
                <li><p>We need to show that we can find `y in R` `s.t.` `xy = 1 (mod M)`</p></li>
                <li><p>Consider the ideal `(x) + M sube R`</p></li>
                <li><p>We know that `(x) + M != M` since `x notin M`</p></li>
                <li><p>Since `(x) + M sup M` and `M` is maximal, `(x) + M = R`</p></li>
                <li><p>We need to use the fact that `(x) + M = R` to produce an element `y` `s.t.` `xy - 1 in M`</p></li>
                <li><p>Since `(x) + M = R`, we can find `y in R, m in M` `s.t.` `xy + m = 1 => xy - 1 = m in M`</p></li>
                <li><p>So `xy = 1 (mod M) <=> y + M` is the multiplicative inverse of `x + M`</p></li>
                <li><p>(`4 => 3`): Suppose `R // M` is a field</p></li>
                <li><p>Let `I` be an ideal of `R` `s.t.` `M sube I`</p></li>
                <li><p>We must show that `I = R <=> 1 in I`</p></li>
                <li><p>Consider `(I + M) // M = {i + M | i in I}`</p></li>
                <li><p>It turns out that `(I + M) // M` is an ideal of `R // M`</p></li>
                <li><p>Let `i_1 + M, i_2 + M in (I + M) // M`</p></li>
                <li><p>Notice that `(i_1 + M) - (i_2 + M) = ((i_1 - i_2) + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M` is a subgroup of `R // M`</p></li>
                <li><p>Let `i + M in (I + M) // M, r + M in R // M`</p></li>
                <li><p>Notice that `(r + M)*(i + M) = (ri + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M = {i + M | i in I}` is an ideal of `R // M`</p></li>
                <li><p>This is not the zero ideal since `I sup M`</p></li>
                <li><p>Therefore, there exists `i + M != 0 + M in (I + M) // M`</p></li>
                <li><p>`R // M` is a field `=> EE j + M in R // M` `s.t.` `(i + M)(j + M) = 1 + M = ij + M`</p></li>
                <li><p>Since `(I + M) // M` is an ideal containing `i + M`, `(i + M)(j + M) = 1 + M in (I + M) // M`</p></li>
                <li><p>Since `(ij + M) = (1 + M), 1 - ij in M`</p></li>
                <li><p>Remember `i in I => ij in 1` and `m sub I => 1 - ij in I`</p></li>
                <li><p>Therefore, `1 - ij = i' in I`, so `1 = ij + i' in I => 1 in I => I = R`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ring_homomorphisms">
            <h3>Ring Homomorphisms</h3>
            <ul>
              <li><p>In group theory, we saw that group homomorphisms allow us to translate data from one group to another</p></li>
              <li><p>`phi(g_1 **_1 g_2) = phi(g_1) **_2 phi(g_2)`</p></li>
              <li><p><b>Definition: Let `R, S` be rings. A <u>ring homomorphism</u> `phi: R -> S` is a function from `R` to `S` `s.t.` `AA r_1, r_2 in R`</b></p></li>
              <li style="list-style-type: none";><p>1) `phi(r_1 + r_2) = phi(r_1) + phi(r_2)`</p></li>
              <li style="list-style-type: none";><p>2) `phi(r_1r_2) = phi(r_1)phi(r_2)`</p></li>
              <li><p><b>Definition: Suppose `R, S` have unity elements. A ring homomorphism is <u>unital</u> if `phi(1_R) = 1_S`</b></p></li>
              <li><p><b>Definition: A <u>ring isomorphism</u> is a ring homomorphism which is both one-to-one and onto</b></p></li>
              <div class="proof">
                <li><p><b>Ex: Let `n` be a positive integer. Then reduction modulo `n` is a ring homomorphism: `pi_n: ZZ -> ZZ // nZZ, a |-> [a]_n`</b></p></li>
                <li><p>Let `a, b in ZZ`</p></li>
                <li><p>Then `pi_n(a + b) = [a + b]_n = [a]_n + [b]_n = pi_n(a) + pi_n(b)`</p></li>
                <li><p>Also `pi_n(ab) = [ab]_n = [a]_n[b]_n = pi_n(a)pi_n(b)`</p></li>
                <li><p>Since `pi_n(1) = [1]_n, pi_n` is also unital</p></li>
              </div>
              <li><p>This is a special case of the natural projection homomorphism:</p></li>
              <li><p>Given a ring `R` and a two-sided ideal `I`, `pi_I: R -> R // I, r |-> r + I`</p></li>
              <div class="proof">
                <li><p><b>Ex: Let `z in CC`. Consider the map `ev_z: CC[t] -> CC, f |-> f(z)`. This is a ring homomorphism</b></p></li>
                <li><p>Let `f, g in CC[t]`.</p></li>
                <li><p>Then `ev_z(f+g) = (f+g)(z) = f(z) + g(z) = ev_z(f) + ev_z(g)`</p></li>
                <li><p>`ev_z(fg) = (fg)(z) = f(z)g(z) = ev_z(f)ev_z(g)`</p></li>
              </div>
              <li><p><b>Definition: Let `phi: R -> S` be a homomorphism of rings. Define the <u>kernel</u> of `phi` to be `ker(phi) = {r in R | phi(r) = 0}`</b></p></li>
              <div class="proof">
                <li><p><b>Find the kernel of `ev_0: CC[t] -> CC, f |-> f(0)`</b></p></li>
                <li><p>We claim that `ker(ev_0) = (t)`</p></li>
                <li><p>Let `f in ker(ev_0) => ev_0(f) = 0 <=> f(0) = 0 => f` has no constant term, so `t|f <=> f in (t)`</p></li>
                <li><p>Let `f in (t)`. Then there exists `f' in CC[t]` `s.t.` `f = tf'`</p></li>
                <li><p>Notice that `ev_0(f) = ev_0(tf') = 0*f'(0) = 0 => tf' = f in ker(ev_0)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Propositions: Let `R, S` be rings. Let `phi: R -> S` be a ring homomorphism. Let `A sube R` be a subring and let `B sube S` be an ideal</b></p></li>
                <li><p><b>`phi(0) = 0`</b></p></li>
                <li><p><b>`phi(r^n) = (phi(r))^n` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>`phi(nr) = n*phi(r)` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p><b>The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p><b>If `R` is commutative, so is `phi(R)`</b></p></li>
                <li><p><b>If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p><b>`phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p><b>If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi(0) = 0`</b></p></li>
                <li><p>`0 + 0 = 0 => phi(0 + 0) = phi(0)`</p></li>
                <li><p>Since `phi` is a ring homomorphism, `phi(0 + 0) = phi(0) + phi(0)`</p></li>
                <li><p>`=> phi(0) + phi(0) = phi(0) => phi(0) = 0`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p>Suppose `A` is an ideal and `phi` is onto</p></li>
                <li><p>Let `s_1, s_2 in phi(A) sube S`</p></li>
                <li><p>Then we can find `a_1, a_2 in A` `s.t.` `phi(a_1) = s_1, phi(a_2) = s_2`</p></li>
                <li><p>Notice that `s_1 - s_2 = phi(a_1) - phi(a_2) = phi(a_1 - a_2)`</p></li>
                <li><p>Since `A` is an ideal, `a_1 - a_2 in A => s_1 - s_2 = phi(a_1 - a_2) in phi(A)`</p></li>
                <li><p>Let `s in phi(A)`. Let `s' in S`. We claim `s's in phi(A)`</p></li>
                <li><p>Since `s in phi(A), EE a in A` `s.t.` `phi(a) = s`</p></li>
                <li><p>Since `phi` is onto, `EE r in R` `s.t.` `phi(r) = s'`</p></li>
                <li><p>Notice that `s's = phi(r)*phi(a) = phi(r*a)`</p></li>
                <li><p>`A` is an ideal and `a in A => ra in A => s's = phi(ra) in phi(A)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p>Let `r_1, r_2 in phi^-1(B)`. We need to show that `r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>`r_1, r_2 in phi^-1(B) => phi(r_1), phi(r_2) in B`</p></li>
                <li><p>Notice that `phi(r_1) - phi(r_2) in B` since `B` is an ideal</p></li>
                <li><p>But `phi(r_1) - phi(r_2) = phi(r_1 - r_2) in B <=> r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>Let `r in phi^-1(B), r' in R`. We claim `r'r in phi^-1(B)`</p></li>
                <li><p>Notice that `phi(r'r) = phi(r')*phi(r) in B` since `B` is an ideal and `phi(r) in B`</p></li>
                <li><p>`phi(r'r) in B <=> r'r in phi^-1(B)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p>Suppose `phi: R -> S` is onto, `1 in R`</p></li>
                <li><p>We claim that `phi(1)` is a unity of `S <=>` given any `s in S, phi(1)*s = s = s*phi(1)`</p></li>
                <li><p>Let `s in S`. Since `phi` is onto, we can find `r in R` `s.t.` `phi(r) = s`</p></li>
                <li><p>Then `phi(1)*s = phi(1)*phi(r) = phi(1*r) = phi(r) = s`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p>(`=>`) Suppose `phi` is one-to-one. Since `0` is an element of `R` which maps to `0 in S`, `phi` is one-to-one `=>` if `phi(r) = 0`, then `r = 0`</p></li>
                <li><p>(`lArr`) Suppose `ker(phi) = 0`. Let `r_1, r_2 in R` `s.t.` `phi(r_1) = phi(r_2)`</p></li>
                <li><p>Then `phi(r_1 - r_2) = 0 => r_1 - r_2 in ker(phi)`</p></li>
                <li><p>So `r_1 - r_2 = 0 <=> r_1 = r_2`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
                <li><p>Suppose `phi` is an isomorphism. Then `phi` is a one-to-one and onto homomorphism</p></li>
                <li><p>Since `phi` is one-to-one and onto, `EE phi^-1: S -> R` `s.t.` `phi @ phi^-1 =` `i``d_S`, `phi^-1 @ phi =` `i``d_R`</p></li>
                <li><p>We claim that `phi^-1 (s_1 + s_2) = phi^-1(s_1) + phi^-1(s_2)` and `phi^-1(s_1s_2) = phi^-1(s_1)phi^-1(s_2)` `AA s_1s_2 in S`</p></li>
                <li><p>Let `s_1, s_2 in S`. Then we can find `r_1, r_2 in R` `s.t.` `phi(r_1) = s_1, phi(r_2) = s_2`</p></li>
                <li><p>`phi^-1(s_1 + s_2) = phi^-1(phi(r_1) + phi(r_2))`</p></li>
                <li><p>`= phi^-1(phi(r_1 + r_2)) = r_1 + r_2 = phi^-1(s_1) + phi^-1(s_2)`</p></li>
                <li><p>`phi^-1(s_1s_2) = phi^-1(phi(r_1)phi(r_2)) = phi^-1(phi(r_1r_2)) = r_1r_2 = phi^-1(s_1)phi^-1(s_2)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `phi: R -> S` is a ring homomorphism, then `ker(phi)` is an ideal of `R`</b></p></li>
                <li><p>Let `r_1, r_2 in ker(phi)`. We claim `r_1 - r_2 in ker(phi)`</p></li>
                <li><p>`phi(r_1 - r_2) = phi(r_1) - phi(r_2) = 0 - 0 = 0 => r_1 - r_2 in ker(phi)`</p></li>
                <li><p>Let `r' in R, r in ker(phi)`. We claim that `r'r in ker(phi)`</p></li>
                <li><p>Notice that `phi(r'r) = phi(r')phi(r) = phi(r')*0 = 0 => r'r in ker(phi)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `I` is a two-sided ideal of `R`, then `I` is the kernel of some ring homomorphism</b></p></li>
                <li><p>Consider `pi_I: R -> R // I`. We claim that `ker(pi_I) = I`</p></li>
                <li><p>(`supe`) If `i in I => pi_I(i) = i + I = 0 + I` since `i in I`</p></li>
                <li><p>(`sube`) Suppose `r in ker(pi_I) => pi_I(r) = 0 + I`</p></li>
                <li><p>`pi_I(r) = r + I = 0 + I <=> r in I`</p></li>
              </div>
              <li><p><b>Ideal Correspondence Theorem: Let `R` be a commutative ring with unity and let `I` be an ideal. Then there is a one-to-one order preserving correspondence between ideals of `R` which contain `I` and ideals of `R // I`</b></p></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>
