<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
    -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
    <title>Abstract Algebra II</title>
    <link href="math_103b.css" rel="stylesheet">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </head>
  <body>
    <nav class="navbar navbar-expand-sm navbar-light bg-light fixed-top">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNavDropdown">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home</a>
          </li>
          <!-- <li class="nav-item">
            <a class="nav-link" href="#" target="_blank">Cheat Sheets</a>
          </li> -->
        </ul>
      </div>
    </nav>
    <div class="toc">
      <ul>
        <a class="toc_link" href="#rings"><li>Rings</li></a>
        <a class="toc_link" href="#integral_domains"><li>Integral Domains</li></a>
        <a class="toc_link" href="#ideals"><li>Ideals</li></a>
        <a class="toc_link" href="#quotient_rings"><li>Quotient Rings</li></a>
        <a class="toc_link" href="#ring_homomorphisms"><li>Ring Homomorphisms</li></a>
        <a class="toc_link" href="#field_of_fractions"><li>Field of Fractions</li></a>
        <a class="toc_link" href="#polynomial_rings"><li>Polynomial Rings</li></a>
      </ul>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-sm-9">
          <h1>Abstract Algebra II</h1>
          <div class="proof">
            <p>A <b>ring</b> is a set `R` with two operations `+, *` such that `(R, +)` is an abelian group, `*` is associative, and `+,*` follow distributivity rules</p>
            <p>Subring Test: `a, b in S => a-b in S, ab in S` where `S sube R`</p>
            <p>An <b>integral domain</b> is a commutative ring with unity and no zero-divisors</p>
            <p>Check if S is an integral domain: `ab = 0 => a = 0` or `b = 0` for `a, b in S`</p>
            <p>A <b>field</b> is a commutative ring with unity in which every nonzero element has a multiplicative inverse (`i.e.` every nonzero element is a unit)</p>
            <p>Subfield Test: `a, b (b != 0) in K => a-b in K, ab^(-1) in K` where `K sube F`</p>
            <p>An <b>ideal</b> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</p>
            <p>Ideal Test: `a, b in A => a-b in A` and `a in A, r in R => ra in A` and `ar in A` where `A sube R`</p>
          </div>
          <div class="content" id="rings">
            <h3>Rings</h3>
            <ul>
              <li><p>Rings are modeled on the integers</p></li>
              <li><p>(`ZZ`, +) is an abelian group</p></li>
              <li><p>`ZZ` also has multiplication which satisfies</p></li>
              <li style="list-style-type: none";><p>`a*(b + c) = a*b + a*c`</p></li>
              <li style="list-style-type: none";><p>`(b + c)*a = b*a + c*a`</p></li>
              <li style="list-style-type: none";><p>`a*(b*c) = (a*b)*c`</p></li>
              <li><p><b>Def: A <u>ring</u> is a set `R` with two operations `+`, `*` such that (`R`, `+`) is an abelian group and</b></p></li>
              <li style="list-style-type: none";><p><b>1) `a*(b*c) = (a*b)*c` (`*` is associative)</b></p></li>
              <li style="list-style-type: none";><p><b>2) `a*(b + c) = a*b + a*c`, `(b + c)*a = b*a + c*a` for all `a, b, c in R`</b></p></li>
              <li><p>Ex: the set of integer multiples of 3 is a ring, `3ZZ`</p></li>
              <li><p>Ex: the real numbers, `RR`</p></li>
              <li><p>Ex: the set of real valued functions `f:[a,b]->ZZ`</p></li>
              <li><p>Ex: let V be a finite dimensional real vector space. Then `End_RR (V) = {phi: V -> V}` forms a ring</p></li>
              <li style="list-style-type: none";><p>the multiplication operation is function composition</p></li>
            </ul>
            <h5>Properties of Rings</h5>
            <ul>
              <li><p>The second 3 rings (`1in RR`; `f(x) = 1, AA x in [a,b]`; `i``d_v`) have a <u>multiplicative identity</u></p></li>
              <li style="list-style-type: none";><p>`a*1 = 1*a = a` (1 is the multiplicative identity)</p></li>
              <li style="list-style-type: none";><p>But `3a*3b != 3a`</p></li>
              <li><p>In `RR` and `{f:[a,b]->RR}`, multiplication is commutative</p></li>
              <li><p>`RR` is the only one of these rings with the property that every nonzero element of `RR` has a multiplicative inverse</p></li>
              <li><p>`AA a in RR`, `EE b in RR` `s.t. a*b = b*a = 1`</p></li>
              <li><p>Rings with a `1` element are said to be <u>unital</u></p></li>
              <li><p>`1` is called a "unity"</p></li>
              <li><p>Given a ring `R`, the elements of `R` which have a multiplicative inverse (2-sided) are called the <u>units</u> of `R`</p></li>
            </ul>
            <h5>Terminology</h5>
            <ul>
              <li><p>Given a commutative ring `R`, `a, b in R`, we say `a` divides `b` `a`|`b` if `EE c in R` `s.t. a*c = b`</p></li>
              <li><p>Since rings are additive groups under addition, given `n in ZZ^+`, we can make sense of `n*a = sum_(i=1)^n a`</p></li>
              <li><p>We define `-n*a = -sum_(i=1)^n a` when `n` is positive</p></li>
              <li><p>`0*a = 0`</p></li>
            </ul>
            <h5>Propositions</h5>
            <ul>
              <li><p>Suppose `a, b, c in R`. Then we have the following properties of multiplication</p></li>
              <li><p>`a*0 = 0*a = 0` (`0 in R`, the additive identity)</p></li>
              <li><p>`a*(-b) = -a*b`</p></li>
              <li><p>`(-a)(-b) = a*b`</p></li>
              <li><p>`a*(b-c) = a*b-a*c`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m+n)*a = (m*a) + (n*a)`</p></li>
              <li><p>given any integer `m in ZZ`, `m*(a*b) = (m*a)*b = (a)*(m*b)`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m*a)*(n*b) = (m*n)*(a*b)`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(a+b) = n*a + n*b`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(-a) = -(n*a)`</p></li>
              <li style="list-style-type: none";><p>If `R` is unital, then</p></li>
              <li><p>`(-1)*a = -a` where `-1 in R`</p></li>
              <li><p>`(-1)(-1) = 1`</p></li>
              <li><p>unity is unique</p></li>
              <li><p>if `a` has a left multiplicative inverse and a right multiplicative inverse, then they are equal</p></li>
              <li><p>multiplicative inverses are unique</p></li>
            </ul>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*0 = 0*a = 0`</b></p></li>
                <li><p>`0+0 = 0`</p></li>
                <li><p>`a*(0 + 0 = 0)`</p></li>
                <li><p>`= a*0 + a*0 = a*0`</p></li>
                <li><p>`=> a*0 = 0`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(-b) = -a*b`</b></p></li>
                <li><p>`a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`a*(b + (-b)) = a*b + a(-b) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `a*(-b) = -(a*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(-a)(-b) = a*b`</b></p></li>
                <li><p>`-a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`-a*(b + (-b)) = -a*b + (-a)*(-b)`</p></li>
                <li><p>By uniqueness of the additive inverse, `(-a)*(-b) = a*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(b - c) = a*b - b*c`</b></p></li>
                <li><p>`a*(b - c) = a*(b + (-c))`</p></li>
                <li><p>`= a*b + a*(-c)`</p></li>
                <li><p>`= a*b + (-a*c) = a*b - a*c`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m + n)*a = (m*a) + (n*a)`</b></p></li>
                <li><p>When `m, n > 0, (m*a) + (n*a) = sum_(i=1)^m a + sum_(j=1)^n a = sum_(k=1)^(m+n) a = (m + n)*a`</p></li>
                <li><p>Suppose `n < 0`, then we can write `n = -n'` where `n' > 0`. `(m + n)*a = (m - n') * a`</p></li>
                <li style="list-style-type: none";><p>1) When `m > n'`, we can write `m - n' = m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m - n')*a = sum_(i = 1)^(m-n') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a = (m*a) - (n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (-n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (n*a)`</p></li>
                <li style="list-style-type: none";><p>2) If `m < n'`, we can write `m - n' = -m'` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m + n)*a = (m - n')*a = (-m')*a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>Notice: `sum_(i = 1)^(m') a = sum_(i = 1)^(n') a - sum_(j = 1)^m a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^(m') a + (- sum_(i=1)^(m') a) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `- sum_(i = 1)^(m') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^m a - sum_(j = 1)^(n') a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>`(m*a) - (n*a) = (m*a) + (-n'*a) = (m*a) + (n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `m*(a*b) = (m*a)*b = (a)*(m*b)`</b></p></li>
                <li><p>If `m = 0,`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*b = 0*b = 0`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b) = 0*a*b = 0`</p></li>
                <li style="list-style-type: none";><p>`(a)*(m*b) = (a)*(0*b) = 0`</p></li>
                <li><p>Suppose `m` is positive. Then `m*(a*b) = sum_(i = 1)^m a*b = (sum_(i = 1)^m a)*b = (m*a)*b`</p></li>
                <li><p>If `m` is negative, we can write `m = -m` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (m + m')*(a*b) = m*(a*b) + m'*(a*b) = m*(a*b) + a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b) + a(m'*b) = a*(m*b + m'*b) = a*((m+m')*b)) = 0`</p></li>
                <li style="list-style-type: none";></li><p>By uniqueness of the additive inverse, `a*(m*b) = m*(a*b)`</p>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m*a)*(n*b) = (m*n)*(a*b)`</b></p></li>
                <li><p>If `m, n` are both positive, `(m*a)*(n*b) = (sum_(i = 1)^m a)*(sum_(j = 1)^n b) = sum_(k = 1)^(m*n) a*b = (m*n)*(a*b)`</p></li>
                <li><p>If `m, n` are both negative, `EE m', n' > 0` `s.t. m = -m', n = -n'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) = (-m'*a)*(-n'*b) = -(m'*a)*(-(n'*b)) = (m'*a)*(n'*b)`</p></li>
                <li style="list-style-type: none";><p>`= (m'*n')*(a*b) = ((-m')*(-n'))*(a*b) = (m*n)*(a*b)`</p></li>
                <li><p>If `m` is negative and `n` is positive, there exists `m' > 0` `s.t. m = -m'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) + (m'*a)*(n*b) = ((m*a) + (m'*a))*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*a)*(n*b)) = 0`</p></li>
                <li style="list-style-type: none";><p>`(m'*a)*(n*b) = (m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) + (m'*n)*(a*b) = (m*n + m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*n)*(a*b) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `(m*n)*(a*b) = -(m'*a)*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) = (-m'*a)*(n*b) = (m*a)*(n*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(a + b) = n*a + n*b`</b></p></li>
                <li><p>If `n` is positive, `n*(a + b) = sum_(i = 1)^n (a + b) = sum_(i = 1)^n a + sum_(i = 1)^n b = (n*a) = (n*b)`</p></li>
                <li><p>If `n` is negative, we can write it as `-n'` where `n' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (n + n')*(a + b) = n*(a + b) + n'*(a + b) = n*(a + b) + n'*a + n'*b`</p></li>
                <li style="list-style-type: none";><p>But `n*a + n*b + n'*a + n'*b = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `n*(a + b) = n*a + n*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(-a) = -(n*a)`</b></p></li>
                <li><p>`0 = n*(a + (-a)) = (n*a) + n*(-a)`</p></li>
                <li><p>Also know `(n*a) + (-n*a) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `n*(-a) = (-n*a) = -(n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS unity is unique</b></p></li>
                <li><p>Suppose `1, 1'` are both unity elements of `R`</p></li>
                <li><p>On one hand, `1` is a mult. identity `=> 1*1' = 1'`</p></li>
                <li><p>On the other hand, `1'` is a mult. identity `=> 1*1' = 1`</p></li>
                <li><p>`=> 1 = 1'`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS if `a` has a left mult. inverse and a right mult. inverse, then they are equal</b></p></li>
                <li><p>Suppose `b` is a left mult. inverse of `a` and `c` is a right mult. inverse of `a`</p></li>
                <li><p>`b*a = 1, a*c = 1`</p></li>
                <li><p>`b = b*1 = b*(a*c) = (b*a)*c = 1*c = c`</p></li>
              </ul>
            </div>
            <h5>Subrings</h5>
            <ul>
              <li><p><b>Def: A <u>subring</u> of a ring `R` is a subset `S sube R` which is a ring with the operations of `+` and `*` restricted to `S`</b></p></li>
              <li><p>Unwinding this definition, we see that `+: SxxS->R`, `(s_1, s_2)|->s_1 + s_2` must have image contained in `S` (closed under addition) and `*: SxxS->R`, `(s_1, s_2)|->s_1*s_2` must have image contained in `S` (closed under multiplication)</p></li>
              <li><p>We must have `0 in S` and for every `s in S, -s in S` (closed under taking additive inverses)</p></li>
              <li><p><b>In fact, we see that `S` is a subring if and only if `s_1 - s_2 in S` and `s_1*s_2 in S`, `AA s_1, s_2 in S`</b></p></li>
              <li><p>Ex: `3ZZ sube ZZ` is a subring of `ZZ`</p></li>
              <li><p>Ex: `QQ sube RR` is a subring of `RR`</p></li>
              <li><p>Ex: `{lambda Id}_(lambda in R) sube End_RR(V)` where `V` is a finite dimensional real vector space</p></li>
            </ul>
            <h5>Exercises</h5>
            <ul>
              <li><p>Let `R_1, ..., R_n` be rings. The direct sum of `R_1, ..., R_n`, `R_1 o+ R_2 o+ ... o+ R_n` is the set which is the Cartesian product `prod_(i = 1)^n R_i` with ring operations performed component-wise</p></li>
              <li><p>`(a_1, ..., a_n) + (b_1, ..., b_n) = (a_1 + b_1, ..., a_n + b_n)`</p></li>
              <li><p>`(a_1, ..., a_n) * (b_1, ..., b_n) = (a_1 * b_1, ..., a_n * b_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R_1, ..., R_n` are rings with nonzero elements. Show that `R = R_1 o+ ... o+ R_n` has unity `<=>` each `R_i` has a unity</b></p></li>
                <li><p>(`=>`) Assume `R` has unity, say `(e_1, ..., e_n)`. We want to show that each `R_i` has a unity element. We need to show that `e_i` is the mult. identity of `R_i` for each `i`.</p></li>
                <li><p>Need to show: given `r_i in R_i`, `e_i*r_i = r_i*e_i = r_i`</p></li>
                <li><p>Consider a function `f:R_j->R_1 o+ ... o+ R_n, r_j |-> (0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>We know that `(0, ..., 0, r_j, 0, ..., 0) * (e_1, ..., e_n) = (0, ..., 0, r_j, 0, ..., 0) = (e_1, ..., e_n)*(0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>`=> (0*e_1, ..., r_j*e_j, ..., 0*e_n) = (e_1*0, ..., e_j*r_j, ..., 0*e_n)`</p></li>
                <li><p>`=> (0, ..., 0, r_j*e_j, 0, ..., 0) = (0, ..., 0, e_j*r_j, 0, ..., 0)`</p></li>
                <li><p>This shows that `e_j*r_j = r_j = r_j*e_j, AA r in R_j => e_j` is a mult identity of `R_j`</p></li>
                <li><p>(`lArr`) Assume that each `R_i` has a mult. identity. We need to show that `R` does too.</p></li>
                <li><p>Say `e_i` is the mult. identity of `R_i`. We claim that `(e_1, ..., e_n)` is the mult. identity of `R`. We must show that `(e_1, ..., e_n)*(r_1, ..., r_n) = (r_1, ..., r_n)*(e_1, ..., e_n) = (r_1, ..., r_n), AA (r_1, ..., r_n) in R`</p></li>
                <li><p>`(e_1, ..., e_n)*(r_1, ..., r_n) = (e_1*r_1, ..., e_n*r_n) = (r_1, ..., r_n)`</p></li>
                <li><p>`(r_1, ..., r_n)*(e_1, ..., e_n) = (r_1*e_1, ..., r_n*e_n) = (r_1, ..., r_n)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is a positive even integer `n` `s.t. a^n = a` for all `a in R`. Show that `-a = a` for all `a in R`.</b></p></li>
                <li><p>We can write `n = 2k` for some positive integer `k`</p></li>
                <li style="list-style-type: none";><p>`-a = (-a)^n = (-a)^(2k) = ((-a)^2)^k = (a^2)^k = a^(2k) = a^n = a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is an integer `n > 1` such that `x^n = x, AA x in R`. If `m` is a positive integer such that `a^m = 0` for some `a`, show that `a = 0`</b></p></li>
                <li><p>Case 1: `m <= n`</p></li>
                <li style="list-style-type: none";><p>`a = a^n = a^m * a^(n-m) = 0 * a^(n-m) = 0`</p></li>
                <li><p>Case 2: `m > n`</p></li>
                <li style="list-style-type: none";><p>Choose `m` to be the smallest positive integer `s.t. a^m = 0`</p></li>
                <li style="list-style-type: none";><p>Suppose for a contradiction `m > n`</p></li>
                <li style="list-style-type: none";><p>`0 = a^m = a^n * a^(m-n) = a*a^(m-n) = a^(m-n+1)`</p></li>
                <li style="list-style-type: none";><p>Since m was chosen to be the smallest positive integer with this property, `m-n+1 >= m => -n + 1 >= 0 => 1 >= n`</p></li>
                <li style="list-style-type: none";><p>This contradicts the assumption that `n > 1`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="integral_domains">
            <h3>Integral Domains</h3>
            <ul>
              <li><p>`ZZ` has more structure than an arbitrary ring does</p></li>
              <li><p>`ZZ` is a commutative ring</p></li>
              <li><p>`ZZ` has a mult. identity</p></li>
              <li><p>`ZZ` has the property that if `a, b != 0`, then `ab != 0`</p></li>
              <li><p><b>Def: A <u>zero-divisor</u> in a commutative ring is a nonzero element `z in R` `s.t.` there exists a nonzero element `y in R` `s.t.` `zy = 0`</b></p></li>
              <li><p><b>Def: An <u>integral domain</u> is a unital commutative ring `R` `s.t.` if `a, b in R` `s.t. ab = 0`, then either `a = 0` or `b = 0`</b></p></li>
              <li><p>We almost have division in integral domains: we have cancellation</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `R` be a domain. Suppose that `a != 0 in R`. Then `ab = ac => b= c`</b></p></li>
                <li><p>`ab = ac => ab - ac = 0 => a(b-c) = 0`</p></li>
                <li><p>Since `a != 0`, `b-c = 0 => b = c`</p></li>
              </div>
              <li><p>Ex: `QQ` is a domain</p></li>
              <li><p>Ex: the Gaussian integers `ZZ[i] = {a + bi | a, b in ZZ}` is a domain</p></li>
              <li><p>Ex: `CC[x]` - the ring of polynomials in a single indeterminate `x` with coefficients `in CC` is a domain</p></li>
              <li><p>NonEx: `ZZ // (4ZZ)` is not a domain because `[2]_4 * [2]_4 = [4]_4 = [0]_4`</p></li>
              <li><p><b>Def: A <u>field</u> is a domain `F` `s.t.` every nonzero element of `F` has a mult. inverse</b></p></li>
              <li><p>Ex: `RR` is a field</p></li>
              <li><p>Ex: `CC(t) = {f(t)/g(t) | f(t), g(t) in CC(t)}` the ring of rational functions whose coefficients are in `CC` is a field</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `D` be a finite integral domain. Then `D` is a field.</b></p></li>
                <li><p>Need to show that every nonzero element has a mult. inverse</p></li>
                <li><p>Let `a != 0 in D`. Consider the function `phi_a: D->D`, `y |-> ay`</p></li>
                <li><p>If we show that `phi_a` is surjective, then we are done</p></li>
                <li><p>Since `D` is finite, by the pigeonhole principle, `phi_a` is surjective `<=> phi_a` is injective</p></li>
                <li><p>Therefore, it suffices to show that `phi_a` is injective</p></li>
                <li><p>Suppose `b, c in D` `s.t.` `phi_a(b) = phi_a(c) => ab = ac`</p></li>
                <li><p>Since `a != 0` and `D` is a domain, we conclude that `b = c => phi_a` is injective</p></li>
                <li><p>Since `phi_a` is surjective, if we fix `1 in D`, we can find an element `b in D` `s.t.` `phi_a(b) = ab = 1 => b` is the mult. inverse of `a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Corollary: `ZZ // pZZ` is a field `<=> p` is prime</b></p></li>
                <li><p>(`=>`) Suppose `ZZ // pZZ` is a field but `p` is not prime</p></li>
                <li><p>Then `p = qr`, `1 < q, r < p`</p></li>
                <li><p>Then `[q]_p*[r]_p = [p]_p = [0]_p => ZZ // pZZ` has zero-divisors, which contradicts `ZZ // pZZ` is a field</p></li>
                <li><p>(`lArr`) If `p` is prime, then we must show `ZZ // pZZ` is a domain by the previous result</p></li>
                <li><p>Suppose `[a]_p * [b]_p = [0]_p <=> ab = pk` for some integer `k`</p></li>
                <li><p>`p` prime `=> p|ab <=> p|a` or `p|b <=> [a]_p = [0]_p` or `[b]_p = [0]_p => ZZ // pZZ` is a domain</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain and `S` is a subring of `R` which contains `1 in R`, then `S` itself is an integral domain</b></p></li>
                <li><p>`S` is commutative &#10003;</p></li>
                <li><p>`S` has a mult. identity &#10003;</p></li>
                <li><p>If `s_1, s_2 in S` `s.t.` `s_1*s_2 = 0 in S`, this same equation holds in `R`</p></li>
                <li><p>Since `R` is a domain, `s_1s_2 = 0 => s_1 = 0 or s_2 = 0`</p></li>
              </div>
              <li><p>Ex: Notice that in `ZZ // nZZ`, `n[a]_n = [na]_n = [0]_n`</p></li>
              <li style="list-style-type: none";><p>Multiplication by `n` kills all elements of `ZZ // nZZ`</p></li>
              <li><p>Ex: Consider `CC` (along with all subrings `R` of `CC` containing `1`). There does not exist a positive integer `n` `s.t.` `n*z = 0` `AA z in CC` and `n*z = 0` `AA z in R`</p></li>
              <li style="list-style-type: none";><p>The only integer which kills all of `CC` (or `R`) is `0`</p></li>
              <li><p>The integer `n` in these examples is called the characteristic of the ring</p></li>
              <li><p><b>Def: the <u>characteristic</u> of a ring `R` is the least nonnegative integer `n` `s.t.` `n*r = 0` `AA r in R`</b></p></li>
              <li><p>`char(ZZ // nZZ) = n`, `char(CC) = 0`</p></li>
              <li><p>When `R` is a unital commutative ring, we can relate `char(R)` to the order of `1 in R` (as an abelian group under `+`)</p></li>
              <li><p>If `1` has infinite order in `R`, then `char(R) = 0`</p></li>
              <li><p>If `1` has finite order, say `n`, then `char(R) = n`</p></li>
              <li style="list-style-type: none";><p>Since `o``rd(1) = n, n*1 = 0`</p></li>
              <li style="list-style-type: none";><p>`n*r = (n*1)r = 0` `AA r in R`</p></li>
              <li style="list-style-type: none";><p>`=> n` kills everything in `R`</p></li>
              <li style="list-style-type: none";><p>Therefore, `n >= char(R)`</p></li>
              <li style="list-style-type: none";><p>We know that `char(R)*1 = 0 => n|char(R) => n <= char(R)`</p></li>
              <li style="list-style-type: none";><p>So `n = char(R)`</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `char(R) = 0` or `char(R) = p` for some prime number `p`</b></p></li>
                <li><p>Suppose that `R` is an integral domain and `char(R) != 0`. Suppose for a contradiction `char(R)` is not prime.</p></li>
                <li><p>If `char(R)` is not prime, `EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Notice that `(n*1)*(q*1) = (nq)*1 = p*1 = 0` where `(n*1)` and `(q*1)` are not equal to `0`</p></li>
                <li><p>This contradicts the fact that `R` is a domain</p></li>
              </div>
              <li><p>If `char(R) = n`, then the subring generated by `1` in `R` is isomorphic to `ZZ // nZZ`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R` is a commutative ring without zero divisors. (`R` is not necessarily unital.) Show that `char(R)` is `0` or prime.</b></p></li>
                <li><p>Suppose `R` is commutative with no zero divisors. Let `p = char(R)` and suppose `p != 0`. Suppose for a contradiction that `p` is not prime.</p></li>
                <li><p>`=> EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Claim: we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>Suppose not. Then for all `r in R`, `n*r = 0` and `q*r = 0`</p></li>
                <li><p>But `1 < n, q < p = char(R)`</p></li>
                <li><p>This contradicts the fact that `p` is the least nonnegative integer `s.t.` `p*r = 0` `AA r in R`</p></li>
                <li><p>Thus, we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>`(n*a) * (q*b) = (n*q)*(a*b) = p*(a*b) = 0`</p></li>
                <li><p>This contradicts the assumption that `R` does not have zero divisors</p></li>
              </div>
              <div class="proof">
                <li><p><b>Suppose `R` is a commutative ring with prime characteristic `p`. Show that `(x + y)^p = x^p + y^p, AA x, y in R` and `(x + y)^(p^n) = x^(p^n) + y^(p^n)`, for all positive integers `n`</b></p></li>
                <li><p>`(x + y)^p = sum_(i = 0)^p ((p), (i)) x^iy^(p-i)`</p></li>
                <li><p>`= ((p), (0))x^0y^(p) + ((p), (1))xy^(p-1) + ... + ((p), (p-1))x^(p-1)y + ((0), (p))x^p`</p></li>
                <li><p>`= y^p + pxy^(p-1) + ((p), (2))x^2y^(p-2) + ... + ((p), (p-2))x^(p-2)y^2 + px^(p-1)y + x^p`</p></li>
                <li><p>It suffices to show that `((p), (i))` is divisible by `p`</p></li>
                <li><p>`((p), (i)) = (p!) / ((p-i)!p!) = (p * ... * (p-i+1) * (p-i) * ... * 1) / ((p-i)*...*1*i!)`</p></li>
                <li><p>` = (p*...*(p-i+1)) / (i!) = p(((p-1)*...*(p-i+1)) / (i!))`</p></li>
                <li><p>`=> p` divides `((p), (i))`</p></li>
                <li><p>So `y^p + p(_) + ... + p(_) + x^p = y^p + x^p`</p></li>
                <li><p>Base Case: We just proved `(x+y)^(p^1) = x^(p^1) + y^(p^1)` for all `x, y in R`</p></li>
                <li><p>Inductive Hypothesis: Assume that for some integer `k >= 1`, `(x+y)^(p^k) = x^(p^k) + y^(p^k)`</p></li>
                <li><p>`(x+y)^(p^(k+1)) = ((x+y)^(p^k))^p = (x^(p^k) + y^(p^k))^p = ((x^(p^k))^p + (y^(p^k))^p)`</p></li>
                <li><p>`= x^(p^(k+1)) + y^(p^(k+1))`</p></li>
                <li><p>By induction, `(x+y)^(p^n) = x^(p^n) + y^(p^n), AA n in ZZ^+`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a finite commutative ring with unity. Prove that every nonzero element of `R` is either a zero-divisor or a unit</b></p></li>
                <li><p>Let `a != 0` be a non zero-divisor. We claim that `a` is a unit</p></li>
                <li><p>Define `phi_a: R -> R`, `x |-> ax`. We claim that `phi_a` is injective</p></li>
                <li><p>Suppose `x, y in R` `s.t.` `phi_a (x) = phi_a (y)`</p></li>
                <li><p>Then `ax = ay <=> a(x-y) = 0`</p></li>
                <li><p>Since `a` is not a zero divisor and `a != 0`, `x-y = 0 <=> x = y`</p></li>
                <li><p>By the Pigeonhole Principle, `phi_a` is also surjective</p></li>
                <li><p>If we fix `1 in R`, we can find `b in R` `s.t.` `phi_a (b) = 1 <=> ab = 1 => a` is a unit</p></li>
              </div>
              <li><p>Let `R` be an integral domain. A subdomain `S` of `R` is a subring of `R` `s.t.` `S` contains the `1` element of `R`.</p></li>
              <div class="proof">
                <li><p><b>Exercise: Let `P = {n*1 | n in ZZ} sube R`. Show that `P` is contained in every subdomain. What is the order of `P`?</b></p></li>
                <li><p>Let `S` be a subdomain of `R`. We claim that `P sube S`</p></li>
                <li><p>Any element of `P` has the form `n*1` for some integer `n`</p></li>
                <li><p>Case 1 `(n = 0)`: `0*1 = 0 in S`</p></li>
                <li><p>Case 2 `(n > 0)`: `n*1 = sum_(i = 1)^n 1 in S` because `S` is closed under addition</p></li>
                <li><p>Case 3 `(n < 0)`: `n = -n', n' > 0`. `n'*1 in S => -n'*1 in S` so `S` is closed under taking additive inverses</p></li>
                <li><p>Therefore `P sube S`</p></li>
                <li><p>Claim: the order of `P = char(R)`</p></li>
                <li><p>If `n*1 = 0 in R, n*1 = 0 in P`</p></li>
                <li><p>`n = char(R), o rd(P) | char(R) => o rd(P) <= char(R)`</p></li>
                <li><p>`o rd(P)*1 = 0 in P => o rd(P)*1 = 0 in R => char(R) <= o rd(P)`</p></li>
              </div>
              <li><p>A ring element `a` is idempotent if `a^2 = a`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Prove that the only idempotent elements of an integral domain are `0` and `1`</b></p></li>
                <li><p>If `a` is idempotent, then `a^2 = a <=> a^2 - a = 0 <=> a(a-1) = 0`</p></li>
                <li><p>`<=> a = 1` or `a = 0`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ideals">
            <h3>Ideals</h3>
            <ul>
              <li><p>From group theory, the cosets of a normal subgroup `N` in a group `G` form a group themselves</p></li>
              <li><p>It turns out that, with rings, the quotient of a ring by an arbitrary subring need not be a ring itself</p></li>
              <li><p><b>Definition: A (two-sided) <u>ideal</u> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</b></p></li>
              <li><p><b>Definition: An <u>ideal</u> of a commutative ring `R` is a subset `I sube R` `s.t.` `I` is a subgroup of the additive group of `R` and `rI sube I` for all `r in R`</b></p></li>
              <li><p>Ex: Fix a ring `R`. The set consisting of `{0}` is an ideal generated by a single element</p></li>
              <li><p>Ex: `I = {f in CC[t]` `|` `t|f} = (t) = {tf}`</p></li>
              <li style="list-style-type: none";><p>Let `f, g in I => EE f', g' in CC[t]` `s.t.` `f = f't, g = g't`</p></li>
              <li style="list-style-type: none";><p>`f + g = f't + g't = t(f' + g')`</p></li>
              <li style="list-style-type: none";><p>Let `h in CC[t], f in I => EE f' in CC[t]` `s.t.` `f = f't`</p></li>
              <li style="list-style-type: none";><p>Then `hf = h*f't = t(hf') in I`</p></li>
              <li><p>This is an example of a principle ideal: an ideal generated by a single element</p></li>
              <li><p>Ex: Given a ring `R` and elements `a_1, ..., a_n in R`, we can consider the set of all `R`-linear combinations of `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>`{r_1a_1 + ... + r_na_n | r_i in R} = (a_1, ..., a_n)` is the ideal generated by `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>Let `sum_(i = 1)^n r_ia_i, sum_(i = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i = sum_(i = 1)^n (r_i-s_i)a_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>Let `r in R, sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `r*sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`r*sum_(i = 1)^n r_ia_i = sum_(i = 1)^n rr_ia_i in (a_1, ..., a_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Given two ideals `I, J in R`, let `I+J = {i + j | i in I, j in J}`. Show that `I+J` is an ideal</b></p></li>
                <li><p>Let `i_1 + j_1 in I + J` and `i_2 + j_2 in I + J` for `i_1, i_2 in I` and `j_1, j_2 in J`</p></li>
                <li><p>`(i_1 + j_1) - (i_2 + j_2) = (i_1 - i_2) + (j_1 - j_2) in I + J`</p></li>
                <li><p>Let `i + j in I + J`. Let `r in R`.</p></li>
                <li><p>`r(i + j) = ri + rj in I + J` and `(i + j)r = ir + ij in I + J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be ideals of a ring `R`. Let `IJ = {sum_(k = 1)^n i_kj_k | i_k in I, j_k in J, n in ZZ^+}`. Show that `IJ` is an ideal</b></p></li>
                <li><p>Let `sum_(k = 1)^n i_kj_k, sum_(l = 1)^m i'_lj'_l in IJ`</p></li>
                <li><p>Then `sum_(k = 1)^n i_kj_k - sum_(l = 1)^m i'_lj'_l = sum_(k = 1)^n i_kj_k + sum_(l = 1)^m (-i'_l)(j'_l) in IJ`</p></li>
                <li><p>Let `r in R`. Let `sum_(k = 1)^n i_kj_k in IJ`</p></li>
                <li><p>`r*sum_(k = 1)^n i_kj_k = sum_(k = 1)^n ri_kj_k = sum_(k = 1)^n (ri_k)j_k in IJ`</p></li>
                <li><p>`(sum_(k = 1)^n i_kj_k)*r = ... = sum_(k = 1)^n i_k(j_kr) in IJ`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be two ideals of `R`. Show that `I nn J` is an ideal</b></p></li>
                <li><p>From group theory, since `I, J` are subgroups of `(R, +)`, `I nn J` is a subgroup of `(R, +)`</p></li>
                <li><p>Let `z in I nn J`. Let `r in R`. We claim that `rz, zr in I nn J`</p></li>
                <li><p>`z in I nn J => z in I => rz in I`</p></li>
                <li><p>`z in I nn J => z in J => rz in J`</p></li>
                <li><p>`=> rz in I nn J` (similarly for `zr`)</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: If `I` and `J` are two ideals in a unital commutative ring, show that `IJ sube I nn J`</b></p></li>
                <li><p>Let `i in I, j in J`</p></li>
                <li><p>`ij = (i)j in J` (`i in R, j in J`)</p></li>
                <li><p>`ij = i(j) in I` (`i in I, j in R`)</p></li>
                <li><p>`=> ij in I nn J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>If `I` and `J` are two ideals in a unital commutative ring `R` `s.t.` `I + J = R`, show that `IJ = I nn J`</b></p></li>
                <li><p>Since `I + J = R`, given any `r in R`, we can write `r = i + j` for some `i in I, j in J`</p></li>
                <li><p>In particular, `1 = i + j` for some `i in I, j in J`</p></li>
                <li><p>Let `z in I nn J`. We claim `z in IJ`</p></li>
                <li><p>`z = 1*z = (i + j)*z = iz + jz`</p></li>
                <li><p>`z in I nn J => z in I, z in J`</p></li>
                <li><p>Since `i in I, z in J, iz in IJ`</p></li>
                <li><p>Since `j in J, z in I, jz in IJ`</p></li>
                <li><p>So `iz + jz in IJ`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="quotient_rings">
            <h3>Quotient Rings</h3>
            <ul>
              <li><p>Let `R` be a ring and let `I` be an ideal</p></li>
              <li><p>Let `R//I = {r + I | r in R}`. We will put a ring structure on `R//I`</p></li>
              <li><p>From group theory, `R` is an abelian group under `+` and `I` is a subgroup</p></li>
              <li><p>Therefore, `R//I` is a group under `+`, which is defined as `(r_1 + I) + (r_2 + I) = (r_1 + r_2 + I)`</p></li>
              <li><p>We define multiplication by `(r_1 + I) * (r_2 + I) = (r_1r_2 + I)`</p></li>
              <div class="proof">
                <li><p>We claim that this is well-defined</p></li>
                <li><p>Suppose `r_1 + I = s_1 + I, r_2 + I = s_2 + I`</p></li>
                <li><p>We need to show that `r_1r_2 + I = s_1s_2 + I`</p></li>
                <li><p>`r_1 + I = s_1 + I <=> r_1 - s_1 in I`</p></li>
                <li><p>`r_2 + I = s_2 + I <=> r_2 - s_2 in I`</p></li>
                <li><p>Notice that `r_1r_2 + I = s_1s_2 + I <=> r_1r_2 - s_1s_2 in I`</p></li>
                <li><p>Since `r_1-s_1, r_2-s_2 in I`, we see that `(r_1-s_1)(r_2-s_2) = r_1r_2 - s_1r_2 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2 + (s_1s_2 - s_1s_2)`</p></li>
                <li><p>`= (r_1r_2 - s_1s_2) - s_1(r_2-s_2) - s_2(r_1-s_1)`</p></li>
                <li><p>`=> r_1r_2 - s_1s_2 in I`</p></li>
              </div>
              <li><p>Ex: `ZZ // nZZ` is the quotient of `ZZ` by the ideal `nZZ`</p></li>
              <li><p>Ex: Let's determine what the cosets of `(t)` in `CC[t]` are. What is `(CC[t])/((t))`?</p></li>
              <li style="list-style-type: none";><p>Given `f(t) in CC[t]`, we can consider the polynomial `f(t) - f(0)` which lies in `(t)`</p></li>
              <li style="list-style-type: none";><p>Therefore, `f(t) + (t) = f(0) + t` as cosets</p></li>
              <div class="proof" id="inzz">
                <li><p>Ex: Classify all ideals in `ZZ`. We claim that every ideal has the form `nZZ` for some `n in ZZ^+`</p></li>
                <li><p>Let `I != (0)` be an ideal of `ZZ`. Let `n` be the least positive integer in `I`</p></li>
                <li><p>We claim `I = nZZ`. It suffices to show that `n | m`, `AA m in I`</p></li>
                <li><p>Let `m != 0 in I`. Assume that `m > 0`. Consider `gcd(m,n)`</p></li>
                <li><p>By the Euclidean algorithm, we can write `gcd(m,n) = am + bn` for some `a, b in ZZ^+`</p></li>
                <li><p>`m, n in I => gcd(m,n) = am + bn in I`</p></li>
                <li><p>Therefore, `gcd(m,n) in I` but `0 < gcd(m,n) <= n => gcd(m,n) = n` (since `n` is the least positive integer in `I`) `=> n|m`</gcd></p></li>
                <li><p>If `m < 0`, then `-m in I` and the argument we just proved shows that `n|-m =>n|m`</0> </p></li>
              </div>
              <div id="prime_ideal" class="proof">
                <li><p>`pZZ` where `p` is prime is a "special type" of ideal</p></li>
                <li><p>Let `a, b in ZZ` `s.t.` `p|ab`. Then `p|a` or `p|b`</p></li>
                <li><p>`ab in pZZ <=> p|ab => p|a` or `p|b <=> a in pZZ` or `b in pZZ`</p></li>
                <li><p>So `ab in pZZ => a in pZZ` or `b in pZZ`</p></li>
              </div>
                <li><p>If `aZZ, bZZ` are two ideals of `ZZ`, then `aZZ * bZZ sube pZZ => aZZ sube pZZ` or `bZZ sube pZZ`</p></li>
              <li><p>Such ideals with this property are called prime ideals</p></li>
              <li><p><b>Definition: An ideal `p sube R` is a <u>prime ideal</u> if `p` is a proper ideal and whenever `ab in p`, we must have `a in p` or `b in p` `AA a, b in R`</b></p></li>
              <div class="proof">
                <li><p><b>`pZZ` is a prime ideal `<=> p` is prime</b></p></li>
                <li><p>(`lArr`)<a href="#prime_ideal"> We've already seen that if `p` is prime, then `pZZ` is a prime ideal</a></p></li>
                <li><p>(`=>`) Suppose `pZZ` is a prime ideal. It suffices to show that if `p = ab` where `a, b > 0`, then `p = a` or `p = b`</p></li>
                <li><p>If `p = ab`, then `ab in pZZ`</p></li>
                <li><p>Since `pZZ` is a prime ideal, we must have either `a in pZZ` or `b in pZZ`</p></li>
                <li><p>`a in pZZ <=> p|a` and `b in pZZ <=> p|b`</p></li>
                <li><p>Either `p|a` or `p|b`</p></li>
                <li><p>Since `a, b, p > 0`, `p|a` and `a|p` `=> a = p`</p></li>
                <li><p>`p|b` and `b|p` `=> b = p`</p></li>
                <li><p>`=> p` is a prime number</p></li>
              </div>
              <li><p><b>Definition: An ideal `m` of a commutative ring `R` is said to be <u>maximal</u> if `m sub R` (`m` is a proper ideal) and, whenever `I` is an ideal `s.t.` `m sube I`, we must have `I = m` or `I = R`</b></p></li>
              <li><p>Ex: Returning to `ZZ`, it turns out that `pZZ` is not only prime, but also maximal when `p` is prime</p></li>
              <div class="proof">
                <li><p><b>We claim `pZZ` is maximal</b></p></li>
                <li><p>Suppose `pZZ sube I` where `I` is an ideal of `ZZ`</p></li>
                <li><p><a href="#inzz">We've already seen that `I = nZZ` for some positive integer `n`</a></p></li>
                <li><p>Therefore, `pZZ sube nZZ`</p></li>
                <li><p>In particular, `p in pZZ sube nZZ => p in nZZ <=> n|p`</p></li>
                <li><p>Since `p` is prime, we either have `n = p` (`=> nZZ = pZZ`) or `n = 1` (`=> nZZ = ZZ`)</p></li>
                <li><p>So `pZZ` is maximal</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a commutative ring with unity, then the following are equivalent</b></p></li>
                <li><p><b>1) `p` is a prime ideal</b></p></li>
                <li><p><b>2) `R // p` is an integral domain</b></p></li>
                <li><p><b>and</b></p></li>
                <li><p><b>3) `M` is a maximal ideal</b></p></li>
                <li><p><b>4) `R // M` is a field</b></p></li>
                <li><p>(`1 => 2`): Suppose `p` is a prime ideal. We already know that `R // p` is a commutative ring with unity. We must show that `R // p` has no zero-divisors</p></li>
                <li><p>Suppose `(x + p)(y + p) = (0 + p) => (xy + p) = (0 + p) <=> xy in p`</p></li>
                <li><p>Since `p` is a prime ideal, `xy in p <=> x in p` or `y in p`</p></li>
                <li><p>If `x in p`, then `x + p = 0 + p`</p></li>
                <li><p>If `y in p`, then `y + p = 0 + p`</p></li>
                <li><p>Then `R // p` is an integral domain</p></li>
                <li><p>(`2 => 1`): Suppose `R // p` is an integral domain. Let `x, y in R` `s.t.` `xy in p`</p></li>
                <li><p>We claim that `x in p` or `y in p`</p></li>
                <li><p>Consider `(x + p)*(y + p) = (xy + p)`</p></li>
                <li><p>Since `xy in p, (xy + p) = (0 + p)`</p></li>
                <li><p>Since `R // p` is an integral domain, we must have either `x + p = 0 + p <=> x in p` or `y + p = 0 + p <=> y in p`</p></li>
                <li><p>Therefore `p` is prime</p></li>
                <li><p>(`3 => 4`): Assume that `M` is a maximal ideal</p></li>
                <li><p>Let `x + M != 0 + M in R // M`</p></li>
                <li><p>We claim that there exists `y + M in R // M` `s.t.` `(x + M)*(y + M) = 1 + M => xy + M = 1 + M`</p></li>
                <li><p>We need to show that we can find `y in R` `s.t.` `xy = 1 (mod M)`</p></li>
                <li><p>Consider the ideal `(x) + M sube R`</p></li>
                <li><p>We know that `(x) + M != M` since `x notin M`</p></li>
                <li><p>Since `(x) + M sup M` and `M` is maximal, `(x) + M = R`</p></li>
                <li><p>We need to use the fact that `(x) + M = R` to produce an element `y` `s.t.` `xy - 1 in M`</p></li>
                <li><p>Since `(x) + M = R`, we can find `y in R, m in M` `s.t.` `xy + m = 1 => xy - 1 = m in M`</p></li>
                <li><p>So `xy = 1 (mod M) <=> y + M` is the multiplicative inverse of `x + M`</p></li>
                <li><p>(`4 => 3`): Suppose `R // M` is a field</p></li>
                <li><p>Let `I` be an ideal of `R` `s.t.` `M sube I`</p></li>
                <li><p>We must show that `I = R <=> 1 in I`</p></li>
                <li><p>Consider `(I + M) // M = {i + M | i in I}`</p></li>
                <li><p>It turns out that `(I + M) // M` is an ideal of `R // M`</p></li>
                <li><p>Let `i_1 + M, i_2 + M in (I + M) // M`</p></li>
                <li><p>Notice that `(i_1 + M) - (i_2 + M) = ((i_1 - i_2) + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M` is a subgroup of `R // M`</p></li>
                <li><p>Let `i + M in (I + M) // M, r + M in R // M`</p></li>
                <li><p>Notice that `(r + M)*(i + M) = (ri + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M = {i + M | i in I}` is an ideal of `R // M`</p></li>
                <li><p>This is not the zero ideal since `I sup M`</p></li>
                <li><p>Therefore, there exists `i + M != 0 + M in (I + M) // M`</p></li>
                <li><p>`R // M` is a field `=> EE j + M in R // M` `s.t.` `(i + M)(j + M) = 1 + M = ij + M`</p></li>
                <li><p>Since `(I + M) // M` is an ideal containing `i + M`, `(i + M)(j + M) = 1 + M in (I + M) // M`</p></li>
                <li><p>Since `(ij + M) = (1 + M), 1 - ij in M`</p></li>
                <li><p>Remember `i in I => ij in 1` and `m sub I => 1 - ij in I`</p></li>
                <li><p>Therefore, `1 - ij = i' in I`, so `1 = ij + i' in I => 1 in I => I = R`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ring_homomorphisms">
            <h3>Ring Homomorphisms</h3>
            <ul>
              <li><p>In group theory, we saw that group homomorphisms allow us to translate data from one group to another</p></li>
              <li><p>`phi(g_1 **_1 g_2) = phi(g_1) **_2 phi(g_2)`</p></li>
              <li><p><b>Definition: Let `R, S` be rings. A <u>ring homomorphism</u> `phi: R -> S` is a function from `R` to `S` `s.t.` `AA r_1, r_2 in R`</b></p></li>
              <li style="list-style-type: none";><p>1) `phi(r_1 + r_2) = phi(r_1) + phi(r_2)`</p></li>
              <li style="list-style-type: none";><p>2) `phi(r_1r_2) = phi(r_1)phi(r_2)`</p></li>
              <li><p><b>Definition: Suppose `R, S` have unity elements. A ring homomorphism is <u>unital</u> if `phi(1_R) = 1_S`</b></p></li>
              <li><p><b>Definition: A <u>ring isomorphism</u> is a ring homomorphism which is both one-to-one and onto</b></p></li>
              <div class="proof">
                <li><p><b>Ex: Let `n` be a positive integer. Then reduction modulo `n` is a ring homomorphism: `pi_n: ZZ -> ZZ // nZZ, a |-> [a]_n`</b></p></li>
                <li><p>Let `a, b in ZZ`</p></li>
                <li><p>Then `pi_n(a + b) = [a + b]_n = [a]_n + [b]_n = pi_n(a) + pi_n(b)`</p></li>
                <li><p>Also `pi_n(ab) = [ab]_n = [a]_n[b]_n = pi_n(a)pi_n(b)`</p></li>
                <li><p>Since `pi_n(1) = [1]_n, pi_n` is also unital</p></li>
              </div>
              <li><p>This is a special case of the natural projection homomorphism:</p></li>
              <li><p>Given a ring `R` and a two-sided ideal `I`, `pi_I: R -> R // I, r |-> r + I`</p></li>
              <div id="ev_hom" class="proof">
                <li><p><b>Ex: Let `z in CC`. Consider the map `ev_z: CC[t] -> CC, f |-> f(z)`. This is a ring homomorphism</b></p></li>
                <li><p>Let `f, g in CC[t]`.</p></li>
                <li><p>Then `ev_z(f+g) = (f+g)(z) = f(z) + g(z) = ev_z(f) + ev_z(g)`</p></li>
                <li><p>`ev_z(fg) = (fg)(z) = f(z)g(z) = ev_z(f)ev_z(g)`</p></li>
              </div>
              <li><p><b>Definition: Let `phi: R -> S` be a homomorphism of rings. Define the <u>kernel</u> of `phi` to be `ker(phi) = {r in R | phi(r) = 0}`</b></p></li>
              <div id="ev_ker" class="proof">
                <li><p><b>Find the kernel of `ev_0: CC[t] -> CC, f |-> f(0)`</b></p></li>
                <li><p>We claim that `ker(ev_0) = (t)`</p></li>
                <li><p>Let `f in ker(ev_0) => ev_0(f) = 0 <=> f(0) = 0 => f` has no constant term, so `t|f <=> f in (t)`</p></li>
                <li><p>Let `f in (t)`. Then there exists `f' in CC[t]` `s.t.` `f = tf'`</p></li>
                <li><p>Notice that `ev_0(f) = ev_0(tf') = 0*f'(0) = 0 => tf' = f in ker(ev_0)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Propositions: Let `R, S` be rings. Let `phi: R -> S` be a ring homomorphism. Let `A sube R` be a subring and let `B sube S` be an ideal</b></p></li>
                <li><p><b>`phi(0) = 0`</b></p></li>
                <li><p><b>`phi(r^n) = (phi(r))^n` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>`phi(nr) = n*phi(r)` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p><b>The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p><b>If `R` is commutative, so is `phi(R)`</b></p></li>
                <li><p><b>If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p><b>`phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p><b>If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi(0) = 0`</b></p></li>
                <li><p>`0 + 0 = 0 => phi(0 + 0) = phi(0)`</p></li>
                <li><p>Since `phi` is a ring homomorphism, `phi(0 + 0) = phi(0) + phi(0)`</p></li>
                <li><p>`=> phi(0) + phi(0) = phi(0) => phi(0) = 0`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p>Suppose `A` is an ideal and `phi` is onto</p></li>
                <li><p>Let `s_1, s_2 in phi(A) sube S`</p></li>
                <li><p>Then we can find `a_1, a_2 in A` `s.t.` `phi(a_1) = s_1, phi(a_2) = s_2`</p></li>
                <li><p>Notice that `s_1 - s_2 = phi(a_1) - phi(a_2) = phi(a_1 - a_2)`</p></li>
                <li><p>Since `A` is an ideal, `a_1 - a_2 in A => s_1 - s_2 = phi(a_1 - a_2) in phi(A)`</p></li>
                <li><p>Let `s in phi(A)`. Let `s' in S`. We claim `s's in phi(A)`</p></li>
                <li><p>Since `s in phi(A), EE a in A` `s.t.` `phi(a) = s`</p></li>
                <li><p>Since `phi` is onto, `EE r in R` `s.t.` `phi(r) = s'`</p></li>
                <li><p>Notice that `s's = phi(r)*phi(a) = phi(r*a)`</p></li>
                <li><p>`A` is an ideal and `a in A => ra in A => s's = phi(ra) in phi(A)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p>Let `r_1, r_2 in phi^-1(B)`. We need to show that `r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>`r_1, r_2 in phi^-1(B) => phi(r_1), phi(r_2) in B`</p></li>
                <li><p>Notice that `phi(r_1) - phi(r_2) in B` since `B` is an ideal</p></li>
                <li><p>But `phi(r_1) - phi(r_2) = phi(r_1 - r_2) in B <=> r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>Let `r in phi^-1(B), r' in R`. We claim `r'r in phi^-1(B)`</p></li>
                <li><p>Notice that `phi(r'r) = phi(r')*phi(r) in B` since `B` is an ideal and `phi(r) in B`</p></li>
                <li><p>`phi(r'r) in B <=> r'r in phi^-1(B)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p>Suppose `phi: R -> S` is onto, `1 in R`</p></li>
                <li><p>We claim that `phi(1)` is a unity of `S <=>` given any `s in S, phi(1)*s = s = s*phi(1)`</p></li>
                <li><p>Let `s in S`. Since `phi` is onto, we can find `r in R` `s.t.` `phi(r) = s`</p></li>
                <li><p>Then `phi(1)*s = phi(1)*phi(r) = phi(1*r) = phi(r) = s`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p>`(=>)` Suppose `phi` is one-to-one. Since `0` is an element of `R` which maps to `0 in S`, `phi` is one-to-one `=>` if `phi(r) = 0`, then `r = 0`</p></li>
                <li><p>`(lArr)` Suppose `ker(phi) = 0`. Let `r_1, r_2 in R` `s.t.` `phi(r_1) = phi(r_2)`</p></li>
                <li><p>Then `phi(r_1) - phi(r_2) = 0 => phi(r_1 - r_2) = 0 => r_1 - r_2 in ker(phi)` so `r_1 - r_2 = 0 <=> r_1 = r_2`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
                <li><p>Suppose `phi` is an isomorphism. Then `phi` is a one-to-one and onto homomorphism</p></li>
                <li><p>Since `phi` is one-to-one and onto, `EE phi^-1: S -> R` `s.t.` `phi @ phi^-1 =` `i``d_s`, `phi^-1 @ phi =` `i``d_r`</p></li>
                <li><p>We claim that `phi^-1(s_1 + s_2) = phi^-1(s_1) + phi^-1(s_2)` and `phi^-1(s_1s_2) = phi^-1(s_1)phi^-1(s_2) AA s_1, s_2 in S`</p></li>
                <li><p>Let `s_1, s_2 in S`. Then we can find `r_1, r_2 in R` `s.t.` `phi(r_1) = s_1, phi(r_2) = s_2`</p></li>
                <li><p>`phi^-1(s_1 + s_2) = phi^-1(phi(r_1) + phi(r_2)) = phi^-1(phi(r_1 + r_2))`</p></li>
                <li><p>`= r_1 + r_2 = phi^-1(s_1) + phi^-1(s_2)`</p></li>
                <li><p>`phi^-1(s_1s_2) = phi^-1(phi(r_1)phi(r_2)) = phi^-1(phi(r_1r_2))`</p></li>
                <li><p>`= r_1r_2 = phi^-1(s_1)phi^-1(s_2)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `phi: R -> S` is a ring homomorphism, then `ker(phi)` is an ideal of `R`</b></p></li>
                <li><p>Let `r_1, r_2 in ker(phi)`. We claim `r_1 - r_2 in ker(phi)`</p></li>
                <li><p>`phi(r_1 - r_2) = phi(r_1) - phi(r_2) = 0 - 0 = 0 => r_1 - r_2 in ker(phi)`</p></li>
                <li><p>Let `r' in R, r in ker(phi)`. We claim that `r'r in ker(phi)`</p></li>
                <li><p>`phi(r'r) = phi(r')phi(r) = phi(r')*0 = 0 => r'r in ker(phi)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `I` is a two-sided ideal of `R`, then `I` is the kernel of some ring homomorphism</b></p></li>
                <li><p>Consider `pi_I: R -> R // I`. We claim that `ker(pi_I) = I`</p></li>
                <li><p>`(supe)` If `i in I => pi_I(i) = i + I = 0 + I` since `i in I`</p></li>
                <li><p>`(sube)` Suppose `r in ker(pi_I) => pi_I(r) = 0 + I`</p></li>
                <li><p>`pi_I(r) = r + I = 0 + I <=> r in I`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Ideal Correspondence Theorem: Let `R` be a commutative ring with unity and let `I` be an ideal. Then there is a one-to-one order-preserving correspondence between ideals of `R` which contain `I` and ideals of `R // I`</b></p></li>
                <img class="img-fluid" src="./pictures/ideal_correspondence_theorem.jpg">
                <li><p>Since `pi_I` is surjective, given any ideal `J sube R` which contains `I`, `pi_I(J)` is an ideal of `R // I`</p></li>
                <li><p>`pi_I(J) = {j + I | j in J} = (J + I) // I`</p></li>
                <li><p>We claim that `pi_I^-1(pi_I(J)) = J`</p></li>
                <li><p>`(supe)` If `j in J`, then `pi_I(j) = j + I in pi_I(J) => j in pi_I^-1(pi_I(j))`</p></li>
                <li><p>`(sube)` Suppose `r in pi_I^-1(pi_I(J)) => pi_I(r) in pi_I(J) => r + I in pi_I(J)`</p></li>
                <li><p>`EE j in J` `s.t.` `r + I = j + I <=> r - j in I`</p></li>
                <li><p>Since `I sube J, r - j in J => r in J`</p></li>
                <li><p>Let `H sube R // I`. Consider `pi_I^-1(H) sube R`. We claim that `pi_I^-1(H) supe I`</p></li>
                <li><p>Let `i in I => pi_I(i) = i + I = 0 + I`</p></li>
                <li><p>Since `H` is an ideal, `0 + I in H => i in pi_I^-1(H) => I in pi_I^-1(H)`</p></li>
                <li><p>We claim that `pi_I(pi_I^-1(H)) = H`</p></li>
                <li><p>Since `pi_I` is surjective, this is true.</p></li>
                <li><p>Therefore, `pi_I: {I sube J sube R} -> {(0 + I) // I sube H sube R // I}` is a bijection</p></li>
                <li><p>Suppose `I sube J_1 sube J_2`. We claim that `pi_I(J_1) sub pi_I(J_2)`</p></li>
                <li><p>We always have `J_1 sube J_2 => pi_I(J_1) sube pi_I(J_2)`</p></li>
                <li><p>If `pi_I(J_1) = pi_I(J_2) => J_1 = J_2` since correspondence is one-to-one</p></li>
                <li><p>So we must have `pi_I(J_1) sub pi_I(J_2)`</p></li>
                <li><p>Suppose `H_1 sub H_2 sube R // I`. We claim that `pi_I^-1(H_1) sub pi_I^-1(H_2)`</p></li>
                <li><p>We always have `pi_I^-1(H_1) sube pi_I^-1(H_2)`</p></li>
                <li><p>If `pi_I^-1(H_1) = pi_I^-1(H_2)`, then since `pi_I^-1` is a bijection, we must have `H_1 = H_2`</p></li>
                <li><p>Therefore, `pi_I^-1(H_1) sub pi_I^-1(H_2)`</p></li>
              </div>
              <li><p>Through this order-preserving correspondence, we can think of the set of ideals of `R // I` as a subset of the set of ideals of `R`</p></li>
              <li><p>In particular, the set of prime ideals of `R // I` can be viewed as a subset of the set of prime ideals of `R`</p></li>
              <div class="proof">
                <li><p><b>First Isomorphism Theorem: If `phi: R -> S` is a ring homomorphism, then there is an isomorphism of rings `bar phi: R // ker(phi) -> phi(R), r + ker(phi) |-> phi(r)`</b></p></li>
                <li><p>We need to prove that `bar phi` is well-defined.</p></li>
                <li><p>Let `r_1 + ker(phi) = r_2 + ker(phi) in R // ker(phi)`</p></li>
                <li><p>We claim `bar phi(r_1 + ker(phi)) = bar phi(r_2 + ker(phi))`</p></li>
                <li><p>`bar phi(r_1 + ker(phi)) = phi(r_1) and bar phi(r_2 + ker(phi)) = phi(r_2)`</p></li>
                <li><p>Therefore, we must show that if `r_1 + ker(phi) = r_2 + ker(phi)`, then `phi(r_1) = phi(r_2)`</p></li>
                <li><p>Suppose `r_1 + ker(phi) = r_2 + ker(phi) <=> r_1 - r_2 in ker(phi)`</p></li>
                <li><p>`=> phi(r_1 - r_2) = 0 => phi(r_1) - phi(r_2) = 0 => phi(r_1) = phi(r_2)`</p></li>
                <li><p>Next we check that `bar phi` is a ring homomorphism</p></li>
                <li><p>Let `r_1 + ker(phi), r_2 + ker(phi) in R // ker(phi)`</p></li>
                <li><p>Consider `bar phi((r_1 + ker(phi)) + (r_2 + ker(phi)))`</p></li>
                <li><p>`= bar phi(r_1 + r_2 + ker(phi)) = phi(r_1 + r_2) = phi(r_1) + phi(r_2)`</p></li>
                <li><p>`= bar phi(r_1 + ker(phi)) + bar phi(r_2 + ker(phi))`</p></li>
                <li><p>`bar phi((r_1 + ker(phi)) * (r_2 + ker(phi))) = bar phi(r_1r_2 + ker(phi)) = phi(r_1r_2)`</p></li>
                <li><p>`= phi(r_1)phi(r_2) = bar phi(r_1 + ker(phi)) bar phi(r_2 + ker(phi))`</p></li>
                <li><p>We must check that `bar phi` is onto. Fix `s in phi(R)`</p></li>
                <li><p>Then we can find `r in R` `s.t.` `phi(r) = s`</p></li>
                <li><p>Notice that `bar phi(r + ker(phi)) = phi(r)`, so `bar phi` is onto</p></li>
                <li><p>Suppose that `r + ker(phi) in ker(bar phi) => bar phi(r + ker(phi)) = 0`</p></li>
                <li><p>But `bar phi(r + ker(phi)) = phi(r) = 0 <=> r in ker(phi) => r + ker(phi) = 0 + ker(phi)`</p></li>
                <li><p>So `bar phi` is injective</p></li>
              </div>
              <li><p>Last time we defined `ev_0: CC[t] -> CC, f |-> f(c)`</p></li>
              <li><p><a href="#ev_hom">We saw that this is a ring homomorphism which maps onto `CC`</a></p></li>
              <li><p><a href="#ev_ker">We saw that `ker(ev_0) = (t)`</a></p></li>
              <li><p>Therefore, by the First Isomorphism Theorem, `CC[t] // (t) ~= CC`</p></li>
              <li><p>Suppose `I` is an ideal of a commutative ring `R`. Then we can use the First Isomorphism Theorem to determine what `R // I` is isomorphic to</p></li>
              <li style="list-style-type: none;"><p>Suppose we have a hunch that `R // I ~= S`. To prove this, we can exhibit a surjective ring homomorphism `phi: R -> S` whose kernel is `I`</p></li>
              <li style="list-style-type: none;"><p>First Isomorphism Theorem `=> R // I ~= S`</p></li>
              <li><p>If `char(R) = n` and `R` is unital, then `R` contains a subring `~= ZZ // nZZ`</p></li>
              <li style="list-style-type: none;"><p>`varepsilon_R: ZZ -> R, m |-> m*1`</p></li>
              <li style="list-style-type: none;"><p>Since `char(R) = n`, the additive order of `1` in `(R,+)` is `n => ker(varepsilon_R) = nZZ`</p></li>
              <li style="list-style-type: none;"><p>By the First Isomorphism Theorem, `ZZ // nZZ ~= ZZ // ker(varepsilon_R) ~= im(varepsilon_R)`</p></li>
              <li><p>If `F` is a field of `char(p)` where `p` is prime, then `F` has a subfield isomorphic to `ZZ // pZZ`, called the prime subfield of `F`</p></li>
              <li><p>What is the prime subfield of a field of characteristic `0`?</p></li>
              <li style="list-style-type: none;"><p>By the First Isomorphism Theorem, we have a subring `~= ZZ`</p></li>
              <li style="list-style-type: none;"><p>`varepsilon_R: ZZ -> F`</p></li>
              <li style="list-style-type: none;"><p>Since `char(R) = 0`, the additive order of `1` in `F` is `oo`</p></li>
              <li style="list-style-type: none;"><p>Therefore, `varepsilon_R` is injective, so `ZZ` is a subring of `F`</p></li>
            </ul>
          </div>
          <div class="content" id="field_of_fractions">
            <h3>Field of Fractions</h3>
            <ul>
              <li><p>Rational numbers can be thought of as tuples `(a,b)` where `a in ZZ, b in ZZ \\ {0}`</p></li>
              <li><p>For instance, `6/3 = 2/1`, so `(6,3) ~ (2,1)`</p></li>
              <li><p>We have to put an equivalence relation on `ZZ oplus ZZ \\ {0}`</p></li>
              <li><p>The relation is `(a,b) ~ (c,d) <=> ad - bc = 0`</p></li>
              <div class="proof">
                <li><p>Let's check that `~` defines an equivalence relation on `ZZ oplus ZZ \\ {0}`</p></li>
                <li><p>Reflexive: We must check that `(a,b) ~ (a,b)` `AA a,b in ZZ oplus ZZ \\ {0}`</p></li>
                <li><p>`(a,b) ~ (a,b) <=> ab - ba = 0`</p></li>
                <li><p>Since `ab - ba = 0 => (a,b) ~ (a,b)`</p></li>
                <li><p>Symmetric: We must check that if `(a,b) ~ (c,d)`, then `(c,d) ~ (a,b)`</p></li>
                <li><p>Assume `(a,b) ~ (c,d) <=> ad - bc = 0`</p></li>
                <li><p>`(c,d) ~ (a,b) <=> cb - da = 0`</p></li>
                <li><p>Since `ad - bc = 0 => (c,d) ~ (a,b)`</p></li>
                <li><p>Transitive: Suppose `(a,b) ~ (c,d)` and `(c,d) ~ (e,f)`</p></li>
                <li><p>We claim `(a,b) ~ (e,f)`. We must show `af - be = 0`</p></li>
                <li><p>`(a,b) ~ (c,d) => ad - bc = 0 => ad = bc`</p></li>
                <li><p>`(c,d) ~ (e,f) => cf - de = 0 => cf = de`</p></li>
                <li><p>`=> adcf = bcde => cd(af - be) = 0`</p></li>
                <li><p>Either `cd = 0 or cd != 0`</p></li>
                <li><p>If `cd = 0, d != 0 => c = 0`</p></li>
                <li><p>`ad = bc = b*0 = 0`</p></li>
                <li><p>`d != 0 => a = 0`</p></li>
                <li><p>`0*f = cd = de = 0`</p></li>
                <li><p>`d != 0 => e = 0`</p></li>
                <li><p>`af - be = 0 - 0 = 0`</p></li>
              </div>
              <li><p>We now define addition and multiplication on `ZZ oplus ZZ \\ {0} // ~`</p></li>
              <div class="proof">
                <li><p>We define addition by `(a,b) + (c,d) = (ad + bc, bd)`</p></li>
                <li><p>We must check that this is well-defined</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2)` and `(c_1,d_1) ~ (c_2,d_2)`</p></li>
                <li><p>We claim `(a_1d_1 + b_1c_1, b_1d_1) ~ (a_2d_2 + b_2c_2, b_2d_2)`</p></li>
                <li><p>`<=> a_1d_1b_2d_2 + b_1c_1b_2d_2 - (a_2d_2b_1d_1 + b_2c_2b_1d_1) = 0`</p></li>
                <li><p>`(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 - b_1a_2 = 0`</p></li>
                <li><p>`(c_1,d_1) ~ (c_2,d_2) <=> c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>Since `a_1b_2 - b_1a_2 = 0` and `c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>`=> d_1d_2(a_1b_2 - b_1a_2) + b_1b_2(c_1d_2 - c_2d_1) = 0`</p></li>
                <li><p>Therefore, `(a_1d_1 + b_1c_1, b_1d_1) ~ (a_2d_2 + b_2c_2, b_2d_2)`</p></li>
                <li><p>Now we check that multiplication is well-defined</p></li>
                <li><p>We define `(a,b) * (c,d) = (ac,bd)`</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2)` and `(c_1,d_1) ~ (c_2,d_2)`</p></li>
                <li><p>We claim `(a_1c_1, b_1d_1) ~ (a_2c_2, b_2d_2) <=> a_1c_1b_2d_2 - b_1d_1a_2c_2 = 0`</p></li>
                <li><p>Since `(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 - b_1a_2 = 0`</p></li>
                <li><p>`(c_1,d_1) ~ (c_2,d_2) <=> c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>`(a_1b_2 - b_1a_2)(c_1d_2 - c_2d_1) = 0`</p></li>
                <li><p>`a_1b_2c_1d_2 - b_1a_2c_1d_2 + b_1a_2c_2d_1 - a_1b_2c_2d_1 + (b_1a_2c_2d_1 - b_1a_2c_2d_1) = 0`</p></li>
                <li><p>`(a_1b_2c_1d_2 - b_1a_2c_2d_1) + b_1a_2(c_2d_1 - c_1d_2) + c_2d_1(b_1a_2 - a_1b_2) = 0`</p></li>
                <li><p>`=> (a_1b_2c_1d_2 - b_1a_2c_2d_1) = 0`</p></li>
              </div>
              <li><p>Given any integral domain, we define the field of fractions, `Q(A)` to be `A oplus A \\ {0} // ~`</p></li>
              <div class="proof">
                <li><p><b>Proposition: Given an integral domain `R` and an injective unital ring homomorphism `phi: R -> K` where `K` is a field, the map `phi` extends uniquely to a unital ring homomorphism `bar phi: Q(R) -> K, bar phi((r,1)``) = phi(r)`</b></p></li>
                <li><p>We first prove uniqueness of `bar phi`</p></li>
                <li><p>Suppose `bar phi, psi` are ring homomorphisms extending `phi`. We claim `bar phi = psi`</p></li>
                <li><p>`bar phi((r,1)``) = phi(r) = ``psi((r,1)``)`</p></li>
                <li><p>Since both are ring homomorphisms,</p></li>
                <li><p>`bar phi((a,b)``) = bar phi((a,1)``, (1,b)) = bar phi((a,1)``) * bar phi((1,b)``) = phi(a) * bar phi((1,b)``)`</p></li>
                <li><p>`psi((a,b)``) = psi((a,1)``, (1,b)) = psi((a,1)``) * psi((1,b)``) = phi(a) * psi((1,b)``)`</p></li>
                <li><p>Therefore, it suffices to show that `psi((1,b)``) = bar phi((1,b)``)` `AA b in ZZ \\ {0}`</p></li>
                <li><p>We show that both are multiplicative inverses of `phi(b)`</p></li>
                <li><p>Notice `psi((1,b)``) * psi((b,1)``) = psi((1,b)(b,1)) = psi((b,b)``) = 1`</p></li>
                <li><p>`=> psi((1,b)``)` is the multiplicative inverse of `psi((b,1)``) = phi(b)`</p></li>
                <li><p>`bar phi((1,b)``) * bar phi((b,1)``) = bar phi((1,b)(b,1)) = bar phi((b,b)``) = 1`</p></li>
                <li><p>`=> bar phi((1,b)``)` is the multiplicative inverse of `bar phi((b,1)``) = phi(b)`</p></li>
                <li><p>`=> psi((1,b)``) = bar phi((1,b)``)`` = phi(b)^-1`</p></li>
                <li><p>Therefore, `bar phi` is unique</p></li>
                <li><p>Now we prove existence</p></li>
                <li><p>If `bar phi` exists, it must be defined as `bar phi((a,b)``)`` = phi(a)phi(b)^-1`</p></li>
                <li><p>Let's show that `bar phi` is well-defined</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 = b_1a_2`</p></li>
                <li><p>We claim `bar phi((a_1,b_1)``) = bar phi((a_2,b_2)``)` `<=> phi(a_1)phi(b_1)^-1 = phi(a_2)phi(b_2)^-1`</p></li>
                <li><p>Since `a_1b_2 = b_1a_2 => phi(a_1b_2) = phi(b_1a_2) => phi(a_1)phi(b_2) = phi(b_1)phi(a_2)`</p></li>
                <li><p>`b_1, b_2 != 0, phi` injective `=> phi(b_1), phi(b_2) != 0 =>` they are units</p></li>
                <li><p>Multiply `phi(a_1)phi(b_2) = phi(a_2)phi(b_1)` by `phi(b_1)^-1phi(b_2)^-1`</p></li>
                <li><p>to get `phi(a_1)phi(b_1)^-1 = phi(a_2)phi(b_2)^-1`</p></li>
                <li><p>We must check that `bar phi` is a ring homomorphism</p></li>
                <li><p>Let `(a,b), (c,d) in Q(R)`</p></li>
                <li><p>`bar phi((a,b) + (c,d)) = bar phi((ad + bc, bd)``)`</p></li>
                <li><p>`= phi(ad + bc)phi(bd)^-1 = phi(a)phi(d)phi(b)^-1phi(d)^-1 + phi(b)phi(c)phi(b)^-1phi(d)^-1`</p></li>
                <li><p>`= phi(a)phi(b)^-1 + phi(c)phi(d)^-1 = bar phi((a,b)``) + bar phi((c,d)``)`</p></li>
                <li><p>`bar phi((a,b)(c,d)``) = phi((ac,bd)``)`` = phi(ac)phi(bd)^-1 = phi(a)phi(c)phi(b)^-1phi(d)^-1`</p></li>
                <li><p>`= (phi(a)phi(b)^-1)(phi(c)phi(d)^-1) = bar phi((a,b)``) bar phi((c,d)``)`</p></li>
                <li><p>`a != 0, bar phi((a,a)``)`` = phi(a)phi(a)^-1 = 1 => bar phi` is a unital ring homomorphism</p></li>
                <li><p>`bar phi((a,b)``)`` = 0 => phi(a)phi(b)^-1 = 0 => phi(a) = 0 => a = 0 => bar phi` is injective</p></li>
              </div>
              <li><p>Suppose `F` is a field of characteristic `0`. What is the prime subfield of `F`?</p></li>
              <li><p>We've seen that we have an injective unital ring homomorphism `varepsilon_F: ZZ -> F`</p></li>
              <li><p>By the proposition, `EE!` `phi: Q(ZZ) ~= QQ -> F =>` the prime subfield of `F` when `char(F) = 0` is `QQ`</p></li>
              <li><p>Every field either contains `QQ` or `ZZ // pZZ` for some prime `p`</p></li>
            </ul>
          </div>
          <div class="content" id="polynomial_rings">
            <h3>Polynomial Rings</h3>
            <ul>
              <li><p><b>Definition: Let `R` be a commutative ring. The polynomial ring `R[x]` of polynomials over `R` in the indeterminate `x` is defined to be the ring consisting of all expressions of the form `sum_(i=0)^n a_ix^i = a_nx^n + a_(n-1)x^(n-1) + ... + a_1x + a_0`, `a_i in R, n in ZZ^(>= 0)`</b></p></li>
              <li><p>We can always write an element of `R[x]` as `sum_(i=0)^n a_ix^i` where `a_n != 0`</p></li>
              <li><p>If we have two polynomials `sum_(i = 0)^n a_ix^i, sum_(j = 0)^m b_jx^j` written in this form then `sum_(i = 0)^n a_ix^i = sum_(j = 0)^m b_jx^j <=> n = m` and `a_k = b_k` `AA 1 <= k <= n`</p></li>
              <li><p>Note: `x` and `x^2` take on the same values at all elements of `ZZ // 2ZZ` but `x != x^2` as elements of `ZZ // 2ZZ [x]`</p></li>
              <li><p>Addition and multiplication are defined exactly as how they were in grade school, except if the coefficient ring `R` has `char(R) = n`, then we have to reduce `mod n`</p></li>
              <li><p>`(3x^2 + 2x + 1) + (x + 4) = 3x^2 + 3x + 5`</p></li>
              <li><p>`= 3x^2 + 3x + 0` if in `[ZZ]_5`</p></li>
              <li><p><b>Definition: Let `f(x) = sum_(i = 0)^n a_ix^i in R[x]`. If `a_n != 0`, then the <u>degree</u> of `f`, denoted by `deg(f(x))`, is `n`. The <u>leading term</u> is `a_n`. If `a_n = 1`, then `f(x)` is said to be <u>monic</u>. If `f(x) = r in R`, then `f(x)` is <u>constant</u>. `R` is called the <u>coefficient ring</u>.</b></p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `R[x]` is an integral domain</b></p></li>
                <li><p>Let `sum_(i = 0)^n a_ix^i, sum_(j = 0)^m b_jx^j in R[x]` be nonzero elements `s.t.` the leading terms are `a_n, b_m != 0`</p></li>
                <li><p>Then the product has leading term `a_nb_m`</p></li>
                <li><p>`a_nb_m != 0` since `R` is a domain and `a_n, b_m != 0`</p></li>
                <li><p>Therefore, the product is nonzero</p></li>
              </div>
              <li><p>For a unital commutative ring `R`, if every ideal of `R` is finitely generated `<=>` every ideal of `R[x]` is finitely generated</p></li>
              <li><p>Degree adds under taking products in `R[x]` when `R` is a domain</p></li>
              <li><p>`ZZ // 4ZZ: f(x) = [2]_4x + [1]_4, g(x) = [2]_4x^2 + [2]_4x`</p></li>
              <li style="list-style-type: none"><p>`f(x)g(x) = [4]_4x^3 + [4]_4x^2 + [2]_4x^2 + [2]_4x = [2]_4x^2 + [2]_4x`</p></li>
              <li style="list-style-type: none"><p>`deg(fg) != deg(f)deg(g)`</p></li>
              <li><p>Unexpected things happen in `R[x]` when `R` is not a domain</p></li>
              <li><p>However, when `F` is a field, none of this occurs</p></li>
              <li><p>Even better, we have a division algorithm in `F[x]` like the one in `ZZ`</p></li>
              <li><p>We can order collections of elements in `F[x]` by their degrees</p></li>
              <li><p>In `ZZ`: If `a in ZZ, b != 0 in ZZ`, then `EE q, r in ZZ` `s.t.` `a = bq + r` `0 <= r < |b|`</p></li>
              <div class="proof">
                <li><p><b>Division Algorithm in `F[x]`: Let `F` be a field. Let `f(x) in F[x]`. Let `g(x) != 0 in F[x]`. Then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where either `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</b></p></li>
                <li><p>First we prove existence</p></li>
                <li><p>If `f(x) = 0`, take `q(x) = 0` and `r(x) = 0`</p></li>
                <li><p>If `deg(g(x)) > deg(f(x))`, let `q(x) = 0, r(x) = f(x)`</p></li>
                <li><p>`f(x) = g(x)*0 + f(x), 0 <= deg(r(x)) = deg(f(x)) < deg(g(x))`</p></li>
                <li><p>We've reduced to the case where `deg(f(x)) >= deg(g(x))`</p></li>
                <li><p>We induct on `deg(f(x)) = n`</p></li>
                <li><p>Base case: `n = 0`. In this case `f(x)` is constant, and since `deg(g(x)) <= deg(f(x)) = 0 => deg(g(x)) = 0 => g(x)` is a constant</p></li>
                <li><p>`f(x)` is constant `=> f(x) = a in F \\ {0}`</p></li>
                <li><p>`g(x)` is constant `=> g(x) = b in F \\ {0}`</p></li>
                <li><p>`a = b*(a/b)`. Let `q(x) = a/b`. Let `r(x) = 0`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `n >= 0, k <=n` `AA k in ZZ^(>= 0).` If `f(x)` is a polynomial of degree `k`, then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</p></li>
                <li><p>WTS: If `f(x)` is a polynomial of degree `n+1` in `F[x]`, then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</p></li>
                <li><p>Let `a_n` be the leading term of `f(x)`, `b_m` be the leading term of `g(x)`</p></li>
                <li><p>The leading monomial of `f(x)` is `a_nx^n` and the leading monomial of `g(x)` is `b_mx^m`, `m <= n`</p></li>
                <li><p>Consider `f(x) - a_nb_m^-1x^(n-m)g(x)`. This has degree `< deg(f(x)) = n+1`</p></li>
                <li><p>So the inductive hypothesis applies to `f(x) - a_nb_m^-1x^(n-m)g(x)`</p></li>
                <li><p>`EE q_1(x), r_1(x) in F[x]` `s.t.` `(f(x) - a_nb_m^-1x^(n-m)g(x)) = g(x)q_1(x) + r_1(x)` where `0 <= deg(r_1(x)) < deg(g(x))` or `r_1(x) = 0`</p></li>
                <li><p>Rearranging this, we find `f(x) = g(x)(a_nb_m^-1x^(n-m) + q_1(x)) + r_1(x)` where `0 <= deg(r_1(x)) < deg(g(x))` or `r_1(x) = 0`</p></li>
                <li><p>Now we prove uniqueness</p></li>
                <li><p>Suppose `f(x) = g(x)q_1(x) + r_1(x) = g(x)q_2(x) + r_2(x)`</p></li>
                <li><p>`g(x)q_1(x) + r_1(x) - g(x)q_2(x) - r_2(x) = 0`</p></li>
                <li><p>`g(x)(q_1(x) - q_2(x)) = (r_2(x) - r_1(x)) => g(x) | (r_2(x) - r_1(x))`</p></li>
                <li><p>`deg(r_2(x) - r_1(x)) <= max{deg(r_1(x)), deg(r_2(x))} < deg(g(x))`</p></li>
                <li><p>If `r_2(x) - r_1(x) != 0`, then that is a contradiction</p></li>
                <li style="list-style-type: none"><p>`deg(g(x)) > deg(f(x))`</p></li>
                <li style="list-style-type: none"><p>If `g(x) | f(x) => EE q(x) in F[x]` `s.t.` `g(x)q(x) = f(x)`</p></li>
                <li style="list-style-type: none"><p>`deg(g(x)) + deg(q(x))` (which is `>= 0`) `= deg(f(x)) < deg(g(x))`, a contradiction</p></li>
                <li><p>So we must have `r_1(x)- r_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is an integral domain, we see that `q_1(x) = q_2(x)`</p></li>
              </div>
              <li><p>If `R` is an integral domain, then we can make sense of `f(x) | g(x).` This means that `EE q(x) in R[x]` `s.t.` `f(x)q(x) = g(x)`</p></li>
              <li><p>`f(x)` is called a <u>factor</u> of `g(x)`. `a in R` is called the <u>root</u> of `f(x)` if `f(a) = 0`</p></li>
              <li><p>Let `a in R`. Then `a` is called a zero of multiplicity `n` of `f(x)` if `(x-a)^n | f(x)` and `(x-a)^(n+1) cancel(|) f(x)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Show that if `R` is an integral domain, the only units of `R[x]` are the units of `R`</b></p></li>
                <li><p>Suppose `f(x) != 0` is a unit in `R[x]`. Then there exists `g(x) != 0` in `R[x]` `s.t.` `f(x)g(x) = 1`</p></li>
                <li><p>`deg(f(x)g(x)) = deg(f(x)) + deg(g(x)) = deg(1) = 0`</p></li>
                <li><p>`=> deg(f(x)) = 0 => f(x) in R`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: A polynomial of degree `n` over a field `F` has at most `n` roots in `F`</b></p></li>
                <li><p>Base case: If `n = 0`, then `f(x) in F \\ {0}`, so it has `0` roots</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `n >= 0, k <= n` `AA k in ZZ^(>= 0)` If `f(x)` is a polynomial of degree `k`, then `f(x)` has at most `k` roots in `F`</p></li>
                <li><p>WTS: If `f(x)` is a polynomial of degree `n+1`, then `f(x)` has at most `n+1` roots in `F`</p></li>
                <li><p>Let `f(x)` be a polynomial of degree `n+1`. If `f(x)` has no roots in `F`, then the statement is proven</p></li>
                <li><p>Therefore we can assume `f(x)` has a root, call it `alpha in F`</p></li>
                <li><p>Let `h` be the multiplicity of `alpha`. We can write `f(x) = (x-alpha)^hq(x)` where `(x-alpha) cancel(|) q(x)`</p></li>
                <li><p>If `alpha` is the only root, then `h <= n + 1` and the statement is proven</p></li>
                <li><p>Suppose that `beta` is a root of `f(x), beta != alpha`</p></li>
                <li><p>`0 = f(beta) = (beta - alpha)^hq(beta) => q(beta) = 0`</p></li>
                <li><p>Therefore, `beta` is a root of `q(x)`</p></li>
                <li><p>We claim that the multiplicity of `beta` as a root of `q(x)` is equal to the multiplicity of `beta` as a root of `f(x)`</p></li>
                <li><p>Since `beta` is a root of `q(x) => (x - beta) | q(x)`</p></li>
                <li><p>Let `m_1` be the multiplicity of `beta` as a root of `q(x)` (So `(x-beta)^(m_1) | q(x)` and `(x - beta)^(m_1+1) cancel(|) q(x)`)</p></li>
                <li><p>Since `beta` is a root of `f(x)`, we can write `f(x) = (x - beta)^(m_2)q_2(x)`</p></li>
                <li><p>`m_2`: the multiplicity of `beta` as a root of `f(x)`</p></li>
                <li><p>`q(x) = (x - beta)^(m_1)q_1(x)`</p></li>
                <li><p>Notice `f(x) = (x - alpha)^nq(x) = (x - alpha)^h(x - beta)^(m_1)q_1(x)`</p></li>
                <li><p>`f(x) = (x - beta)^(m_2)q_2(x)`. We claim `m_1 = m_2`</p></li>
                <li><p>Case 1: `m_1 > m_2`. `(x - alpha)^h(x - beta)^(m_1)q_1(x) - (x - beta)^(m_2)q_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is a domain, `(x - alpha)^h(x - beta)^(m_2 - m_1)q_1(x) - q_2(x) = 0`</p></li>
                <li><p>Plugging in `beta` gives `q_2(beta) = 0`, which is a contradiction</p></li>
                <li><p>Case 2: `m_1 < m_2`. (x - alpha)^h(x - beta)^(m_1)q(x) = (x - beta)^(m_2)q_2(x)`</p></li>
                <li><p>`(x - alpha)^h(x- beta)^(m_1)q_1(x) - (x - beta)^(m_2)q_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is a domain, `(x - alpha)^hq_1(x) - (x - beta)^(m_2 - m_1)q_2(x) = 0`</p></li>
                <li><p>Plugging in `beta => q_1(beta) = 0`, which is a contradiction</p></li>
                <li><p>Therefore, `m_1 = m_2`</p></li>
                <li><p>By the induction hypothesis, since `deg(q(x)) < deg(f(x)) = n + 1, q(x)` has at most `deg(q(x)) = n + 1 - h` roots counted with multiplicity</p></li>
                <li><p>Since the remaining roots of `f(x)` are exactly the roots of `q(x)` with the same multiplicity, since `f(x) = (x - alpha)^hq(x)` we see that `f(x)` has at most `h + deg(q(x)) = h + n + 1 - h = n + 1` roots in `F`</p></li>
              </div>
              <li><p>Why "at most"? Ex: `x^2 + 1 in RR[x]` has no roots</p></li>
              <div class="proof">
                <li><p><b>Theorem: `F[x]` is a principle ideal domain</b></p></li>
                <li><p>Let `I` be a nonzero proper ideal of `F[x]`. Let `f(x) != 0` be an element of minimal degree in `I`</p></li>
                <li><p>Since `I` is proper, the degree of `f(x)` must be positive</p></li>
                <li style="list-style-type: none"><p>(If `deg(f(x)) = 0 => f(x) in F \\ {0} => f(x)` is a unit in `I => I = F[x]`)</p></li>
                <li><p>Let `g(x) in I`. By the division algorithm, `EE q(x), r(x) in F[x]` `s.t` `g(x) = f(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(f(x))` or `r(x) = 0`</p></li>
                <li><p>We can rewrite this as `r(x) = g(x) - f(x)q(x) in I`</p></li>
                <li><p>Since `F` was chosen to have minimal degree, `r(x) = 0 => I sube (f(x))`</p></li>
                <li><p>Since `f(x) in I => (f(x)) sube I => (f(x)) = I`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a commutative ring with unity. Let `I sube R` be an ideal. Show that `I[x]` = the set of polynomials in `R[x]` whose coefficients lie in `I` is an ideal of `R[x]`</b></p></li>
                <li><p>We must show that `I[x]` is a subgroup. Let `f(x) = sum_(i = 0)^n a_ix^i, g(x) = sum_(j = 0)^m b_jx^j in I[x]`</p></li>
                <li><p>WLOG, `n >= m`</p></li>
                <li><p>`f(x) - g(x) = sum_(k = 0)^n c_kx^k` where `c_k = {(a_k - b_k if k <= m), (a_k if m < k <= n):}`</p></li>
                <li><p>`a_k - b_k in I` since `a_k, b_k in I` and `I` is an ideal (for `0 <= k <= m`)</p></li>
                <li><p>`a_k in I` if `m < k <= n =>` By definition, `f(x) - g(x) in I[x]`</k></p></li>
                <li><p>It suffices to show that `AA` monomials `r_hx^h in R[x]`, `AA f(x) in I[x], r_hx^h - f(x) in I[x]`</p></li>
                <li><p>Let `f(x) = sum_(i = 0)^n a_ix^i`. Then `r_hx^h(sum_(i = 0)^n a_ix^i) = sum_(j = h)^(n+1) r_ha_j - hx^j in I[x]`</p></li>
                <li><p>Let `sum_(k = 0)^m r_kx^k in R[x], f(x) in I[x]`</p></li>
                <li><p>Then `sum_(k = 0)^m r_kx^k*f(x) = sum_(k = 0)^m (r_kx^kf(x)) in I[x]`</p></li>
                <li><p>Since `I[x]` is a subgroup `=> sum_(k = 0)^m r_kx^kf(x) in I[x]`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Ex: If `p` is a prime ideal in `R`, then `p[x]` is a prime ideal in `R[x]`</b></p></li>
                <li><p>We show that `R[x] // p[x]` is an integral domain</p></li>
                <li><p>To do this, we exhibit an isomorphism `R[x] // p[x] ~= R // p [x]`</p></li>
                <li><p>`pi_p: R -> R // p`</p></li>
                <li><p>There is a map of rings `bar pi_p: R[x] -> R // p [x], sum_(i = 0)^n a_ix^i |-> sum_(i = 0)^n pi_p(a_i)x^i`</p></li>
                <li><p>(Surjective): Fix `sum_(j = 0)^m (b_i + p)x^i in R // p [x]`</p></li>
                <li><p>Notice `bar pi_p(sum_(j = 0)^m b_jx^j) = sum_(j = 0)^m pi_p(b_j)x^j = sum_(j=  0)^m (b_j + p)x^j`</p></li>
                <li><p>`bar pi` is onto `R[x] -> R // p [x]`</p></li>
                <li><p>We claim `ker(bar pi_p) = p[x]`</p></li>
                <li><p>`(sube)` Let `sum_(i = 0)^n a_ix^i in ker(bar pi_p) => bar pi_p(sum_(i = 0)^n a_ix^i) = sum_(i = 0)^n pi_p(a_i)x^i = 0`</p></li>
                <li><p>`=> pi_p(a_i) = 0` `AA i`</p></li>
                <li><p>`a_i + p = 0 + p => a_i in p` `AA i =>` since all `a_i in p => sum_(i = 0)^n a_ix^i in p[x]`</p></li>
                <li><p>`(supe)` Suppose `sum_(i = 0)^m c_ix^i in p[x] => c_i in p` `AA i`</p></li>
                <li><p>`bar pi_p(sum_(i = 0)^m c_ix^i) = sum_(i = 0)^m pi_p(c_i)x^i = sum_(i = 0)^m (c_i + p)x^i = sum_(i = 0)^m (0 + p)x^i = 0`</p></li>
                <li><p>`=> sum_(i = 0)^m c_ix^i in ker(bar pi_p)`</p></li>
                <li><p>Since `bar pi_p: R[x] -> R // p [x]` is surjective and `ker(bar pi_p) = p[x]`, by the First Isomorphism Theorem, `R[x] // p[x] ~= R // p [x]`</p></li>
                <li><p>`R // p [x]` is a domain `<=> R[x] // p[x]` is a domain `<=> p[x]` is prime</p></li>
              </div>
              <div class="proof">
                <li><p><b>However, if `m` is a maximal ideal of `R`, `m[x]` need not be a maximal ideal of `R[x]`</b></p></li>
                <li><p>Let `R = ZZ, m = pZZ`, `p` prime</p></li>
                <li><p>Then `ZZ[x] // pZZ[x] ~= ZZ // pZZ [x]`</p></li>
                <li><p>We know that `ZZ // pZZ [x]` is not a field `<=> pZZ[x]` is not maximal</p></li>
              </div>
              <li><p>What is the right generalization of a prime number in `F[x]`?</p></li>
              <li><p>`p in ZZ` is prime `<=>` whenever `p = ab, a = +- p, b = +- p` or vice versa</p></li>
              <li><p><b>Definition: Let `R` be an integral domain. Let `f(x) in R[x]` which is nonzero and not a unit. `f(x)` is <u>irreducible</u> if whenever `f(x) = g(x)h(x)` for some `g(x), h(x) in R[x]`, either `g(x)` or `h(x)` must be a unit. If an element is not a unit, nonzero, and not irreducible, it is <u>reducible</u></b></p></li>
              <li><p>Re-examining the definition of irreducible polynomials, since `R` is a domain, the units of `R[x]` are the units of `R` itself, so we can rephrase the definition as:</p></li>
              <li><p><b>`f(x)` is irreducible if whenever `f(x) = g(x)h(x)` for some `g(x), h(x) in R[x]` we must have `g(x)` or `h(x)` is a unit in `R`</b></p></li>
              <li><p>When `R` is a field, we can say even more</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `F` be a field. Then an element `f(x) in F[x]` (nonzero, non-unit) is irreducible if and only if we cannot express `f(x)` as a product of two polynomials whose degrees are `< deg(f(x))`</b></p></li>
                <li><p>`(=>)` Suppose that `f(x)` is irreducible. Suppose for a contradiction that `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`</p></li>
                <li><p>Since `f(x)` is irreducible, one of `g(x)` or `h(x)` must be a unit in `F`</p></li>
                <li><p>If `g(x) in F^x`, then `deg(g(x)) = 0`</p></li>
                <li><p>`f(x) = g(x)h(x) => deg(f(x)) = cancel(deg(g(x))) + deg(h(x)) => deg(f(x)) = deg(h(x))`, which is a contradiction</p></li>
                <li><p>`(lArr)` Suppose that `f(x)` is such that `f(x)` cannot be factored as a product `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`</p></li>
                <li><p>We claim that `f` is irreducible</p></li>
                <li><p>Suppose `f(x) = p(x)q(x)`</p></li>
                <li><p>By assumption, either `deg(p(x)) = deg(f(x))` or `deg(q(x)) = deg(f(x))`</p></li>
                <li><p>In the first case, `deg(q(x)) = 0 <=> q(x) in F^x`</p></li>
                <li><p>In the second case, `deg(p(x)) = 0 <=> p(x) in F^x`</p></li>
                <li><p>Therefore, `f` is irreducible</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a principal ideal domain, then every prime ideal is maximal</b></p></li>
                <li><p>`(lArr)` maximal ideals are always prime in integral domains</p></li>
                <li><p>`(=>)` Suppose that `p` is a prime ideal. Let `p in I` where `I` is an ideal</p></li>
                <li><p>We claim that `I = p` or `I = R`</p></li>
                <li><p>Since `R` is a principal ideal domain, `EE x, z in R` `s.t.` `(x) = p, (z) = I, (x) sube (z)` where `(x)` is prime</p></li>
                <li><p>Since `(x) sube (z), EE y in R` `s.t.` `x = yz => yz in (x)`</p></li>
                <li><p>Since `(x)` is a prime ideal, either `y in (x)` or `z in (x)`</p></li>
                <li><p>If `y in (x) => EE r in R` `s.t.` `y = rx`</p></li>
                <li><p>Then `x = yz = rxz = (rz)x`</p></li>
                <li><p>Since `R` is a domain `=> rz = 1 => z in R^x => (z) = R`</p></li>
                <li><p>If `z in (x)`, then `(z) sube (x)` and therefore `(z) = (x)`</p></li>
                <li><p>`=> p = (x)` is maximal</p></li>
              </div>
              <li><p>Since `F(x)` is a principal ideal domain, to show that irreducible polynomials generate maximal ideals, it suffices to show that irreducible polynomials generate prime ideals</p></li>
              <li><p>To do this, we must establish some properties of irreducible polynomials</p></li>
              <li><p>The property we want is: If `f(x)` is irreducible, then `f(x) | g(x)h(x) => f(x)|g(x)` or `f(x)|h(x)`</p></li>
              <li><p><b>Definition: Let `f(x), g(x) in F[x]`. A polynomial `h(x)` is a <u>greatest common divisor</u> of `f(x)` and `g(x)` if</b></p></li>
              <li style="list-style-type: none"><p><b>1) `h(x) | f(x)` and `h(x) | g(x)`</b></p></li>
              <li style="list-style-type: none"><p><b>2) If `q(x)` is any other common divisor of `f(x)` and `g(x)`, then `q(x) | h(x)`</b></p></li>
              <li><p>We used "a" and not "the" because if `h(x)` satisfies these conditions, so does `c*h(x)` `AA c in F^x`</p></li>
              <li><p>Suppose `h_1(x), h_2(x)` both satisfy these conditions.</p></li>
              <li><p>Then `h_1(x) | h_2(x) => EE p_1(x) in F[x]` `s.t.` `h_1(x)p_1(x) = h_2(x)`</p></li>
              <li><p>And `h_2(x) | h_1(x) => EE p_2(x) in F[x]` `s.t.` `h_2(x)p_2(x) = h_1(x)`</p></li>
              <li><p>`h_2(x) = h_1(x)p_1(x) = h_2(x)p_2(x)p_1(x)`</p></li>
              <li><p>Since `F[x]` is a domain, `p_2(x)p_1(x) = 1 => p_2(x), p_1(x) in F^x`</p></li>
              <li><p>From now on, "the greatest common divisor" means the <b>unique</b> polynomial `h(x)` satisfying these conditions of the definition which is <b>monic</b></p></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>
