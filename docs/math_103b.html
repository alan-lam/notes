<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
    -->
    <title>Abstract Algebra II</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="math_103b.css" rel="stylesheet">
  </head>
  <body>
    <a href="index.html"><i id="back" class="fas fa-long-arrow-alt-left fa-2x"></i></a>
    <div class="toc">
      <ul>
        <a class="toc_link" href="#rings"><li>Rings</li></a>
        <a class="toc_link" href="#integral_domains"><li>Integral Domains</li></a>
        <a class="toc_link" href="#ideals"><li>Ideals</li></a>
        <a class="toc_link" href="#quotient_rings"><li>Quotient Rings</li></a>
        <a class="toc_link" href="#ring_homomorphisms"><li>Ring Homomorphisms</li></a>
        <a class="toc_link" href="#field_of_fractions"><li>Field of Fractions</li></a>
        <a class="toc_link" href="#polynomial_rings"><li>Polynomial Rings</li></a>
        <a class="toc_link" href="#return_to_integral_domains"><li>Return to Integral Domains</li></a>
        <a class="toc_link" href="#vector_spaces"><li>Vector Spaces</li></a>
        <a class="toc_link" href="#extension_fields"><li>Extension Fields</li></a>
      </ul>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-12 col-sm-8">
          <h1>Abstract Algebra II</h1>
          <div class="proof">
            <p>A <b>ring</b> is a set `R` with two operations `+, *` such that `(R, +)` is an abelian group, `*` is associative, and `+,*` follow distributivity rules</p>
            <p>Subring Test: `a, b in S => a-b in S, ab in S` where `S sube R`</p>
            <p>An <b>integral domain</b> is a commutative ring with unity and no zero-divisors</p>
            <p>Check if S is an integral domain: `ab = 0 => a = 0` or `b = 0` for `a, b in S`</p>
            <p>A <b>field</b> is a commutative ring with unity in which every nonzero element has a multiplicative inverse (`i.e.` every nonzero element is a unit)</p>
            <p>Subfield Test: `a, b (b != 0) in K => a-b in K, ab^(-1) in K` where `K sube F`</p>
            <p>An <b>ideal</b> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</p>
            <p>Ideal Test: `a, b in A => a-b in A` and `a in A, r in R => ra in A` and `ar in A` where `A sube R`</p>
            <p>A <b>prime ideal</b> `A` of a ring `R` is a proper ideal of `R` `s.t.` `ab in A => a in A` or `b in A` `AA a, b in R`</p>
            <p>A <b>maximal ideal</b> of a ring `R` is a proper ideal of `R` `s.t.` whenever `B` is an ideal of `R` and `A sube B sube R`, then `B = A` or `B = R`</p>
            <p>A polynomial `f(x)` is <b>irreducible</b> if whenever `f(x) = g(x)h(x)` for some `g(x), h(x) in R[x]`, either `g(x)` or `h(x)` is a unit</p>
            <p>Elements `a, b` in an integral domain `D` are <b>associates</b> if `a = ub` where `u` is a unit in `D`</p>
            <p>A nonzero element `a` is <b>irreducible</b> if `a` is not a unit and whenever `a = bc`, then `b` or `c` is a unit</p>
            <p>A nonzero element `a` is <b>prime</b> if `a` is not a unit and `a|bc` `=>` `a|b` or `a|c`</p>
          </div>
          <div class="proof">
            <p>the kernel of a ring homomorphism is an ideal</p>
            <p>First Isomorphism Theorem: Let `phi: R -> S` be a ring homomorphism. Then `R//ker(phi) ~= phi(R)`. If `phi` is surjective, then `R//ker(phi) ~= S`
            </p>
            <p>`p` prime ideal `<=>` `R//p` is an integral domain</p>
            <p>`m` maximal ideal `<=> R//m` is a field</p>
            <p>degree is additive when taking products of polynomials in `K[x]` where `K` is a field</p>
            <p>`K[x]` is a `PID` when `K` is a field</p>
            <p>`(f(x))` is maximal in `K[x]` if and only if `f(x)` is irreducible</p>
            <p>Gauss's Lemma: If `f(x) in ZZ[x]` is irreducible over `QQ`, then `f(x)` is irreducible over `ZZ`</p>
            <p>Eisenstein's Criterion: Let `f(x) = a_nx^n + a_(n-1)x^(n-1) + ... + a_0`. `f(x)` is irreducible over `QQ` if there exists a prime `p` such that `p cancel(|) a_n`, `p | a_(n-1), ..., p|a_0`, and `p^2 cancel(|) a_0`</p>
            <p>prime implies irreducible in an integral domain</p>
          </div>
          <div class="content" id="rings">
            <h3>Rings</h3>
            <ul>
              <li><p>Rings are modeled on the integers</p></li>
              <li><p>(`ZZ`, +) is an abelian group</p></li>
              <li><p>`ZZ` also has multiplication which satisfies</p></li>
              <li style="list-style-type: none";><p>`a*(b + c) = a*b + a*c`</p></li>
              <li style="list-style-type: none";><p>`(b + c)*a = b*a + c*a`</p></li>
              <li style="list-style-type: none";><p>`a*(b*c) = (a*b)*c`</p></li>
              <li><p><b>Def: A <u>ring</u> is a set `R` with two operations `+`, `*` such that (`R`, `+`) is an abelian group and</b></p></li>
              <li style="list-style-type: none";><p><b>1) `a*(b*c) = (a*b)*c` (`*` is associative)</b></p></li>
              <li style="list-style-type: none";><p><b>2) `a*(b + c) = a*b + a*c`, `(b + c)*a = b*a + c*a` for all `a, b, c in R`</b></p></li>
              <li><p>Ex: the set of integer multiples of 3 is a ring, `3ZZ`</p></li>
              <li><p>Ex: the real numbers, `RR`</p></li>
              <li><p>Ex: the set of real valued functions `f:[a,b]->ZZ`</p></li>
              <li><p>Ex: let V be a finite dimensional real vector space. Then `End_RR (V) = {phi: V -> V}` forms a ring</p></li>
              <li style="list-style-type: none";><p>the multiplication operation is function composition</p></li>
            </ul>
            <h5>Properties of Rings</h5>
            <ul>
              <li><p>The second 3 rings (`1in RR`; `f(x) = 1, AA x in [a,b]`; `i``d_v`) have a <u>multiplicative identity</u></p></li>
              <li style="list-style-type: none";><p>`a*1 = 1*a = a` (1 is the multiplicative identity)</p></li>
              <li style="list-style-type: none";><p>But `3a*3b != 3a`</p></li>
              <li><p>In `RR` and `{f:[a,b]->RR}`, multiplication is commutative</p></li>
              <li><p>`RR` is the only one of these rings with the property that every nonzero element of `RR` has a multiplicative inverse</p></li>
              <li><p>`AA a in RR`, `EE b in RR` `s.t. a*b = b*a = 1`</p></li>
              <li><p>Rings with a `1` element are said to be <u>unital</u></p></li>
              <li><p>`1` is called a "unity"</p></li>
              <li><p>Given a ring `R`, the elements of `R` which have a multiplicative inverse (2-sided) are called the <u>units</u> of `R`</p></li>
            </ul>
            <h5>Terminology</h5>
            <ul>
              <li><p>Given a commutative ring `R`, `a, b in R`, we say `a` divides `b` `a`|`b` if `EE c in R` `s.t. a*c = b`</p></li>
              <li><p>Since rings are additive groups under addition, given `n in ZZ^+`, we can make sense of `n*a = sum_(i=1)^n a`</p></li>
              <li><p>We define `-n*a = -sum_(i=1)^n a` when `n` is positive</p></li>
              <li><p>`0*a = 0`</p></li>
            </ul>
            <h5>Propositions</h5>
            <ul>
              <li><p>Suppose `a, b, c in R`. Then we have the following properties of multiplication</p></li>
              <li><p>`a*0 = 0*a = 0` (`0 in R`, the additive identity)</p></li>
              <li><p>`a*(-b) = -a*b`</p></li>
              <li><p>`(-a)(-b) = a*b`</p></li>
              <li><p>`a*(b-c) = a*b-a*c`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m+n)*a = (m*a) + (n*a)`</p></li>
              <li><p>given any integer `m in ZZ`, `m*(a*b) = (m*a)*b = (a)*(m*b)`</p></li>
              <li><p>given any integers `m, n in ZZ`, `(m*a)*(n*b) = (m*n)*(a*b)`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(a+b) = n*a + n*b`</p></li>
              <li><p>given any integer `n in ZZ`, `n*(-a) = -(n*a)`</p></li>
              <li style="list-style-type: none";><p>If `R` is unital, then</p></li>
              <li><p>`(-1)*a = -a` where `-1 in R`</p></li>
              <li><p>`(-1)(-1) = 1`</p></li>
              <li><p>unity is unique</p></li>
              <li><p>if `a` has a left multiplicative inverse and a right multiplicative inverse, then they are equal</p></li>
              <li><p>multiplicative inverses are unique</p></li>
            </ul>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*0 = 0*a = 0`</b></p></li>
                <li><p>`0+0 = 0`</p></li>
                <li><p>`a*(0 + 0 = 0)`</p></li>
                <li><p>`= a*0 + a*0 = a*0`</p></li>
                <li><p>`=> a*0 = 0`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(-b) = -a*b`</b></p></li>
                <li><p>`a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`a*(b + (-b)) = a*b + a(-b) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `a*(-b) = -(a*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(-a)(-b) = a*b`</b></p></li>
                <li><p>`-a*(b + (-b)) = a*0 = 0`</p></li>
                <li><p>`-a*(b + (-b)) = -a*b + (-a)*(-b)`</p></li>
                <li><p>By uniqueness of the additive inverse, `(-a)*(-b) = a*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `a*(b - c) = a*b - b*c`</b></p></li>
                <li><p>`a*(b - c) = a*(b + (-c))`</p></li>
                <li><p>`= a*b + a*(-c)`</p></li>
                <li><p>`= a*b + (-a*c) = a*b - a*c`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m + n)*a = (m*a) + (n*a)`</b></p></li>
                <li><p>When `m, n > 0, (m*a) + (n*a) = sum_(i=1)^m a + sum_(j=1)^n a = sum_(k=1)^(m+n) a = (m + n)*a`</p></li>
                <li><p>Suppose `n < 0`, then we can write `n = -n'` where `n' > 0`. `(m + n)*a = (m - n') * a`</p></li>
                <li style="list-style-type: none";><p>1) When `m > n'`, we can write `m - n' = m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m - n')*a = sum_(i = 1)^(m-n') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a = (m*a) - (n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (-n'*a)`</p></li>
                <li style="list-style-type: none";><p>`= (m*a) + (n*a)`</p></li>
                <li style="list-style-type: none";><p>2) If `m < n'`, we can write `m - n' = -m'` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`(m + n)*a = (m - n')*a = (-m')*a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>Notice: `sum_(i = 1)^(m') a = sum_(i = 1)^(n') a - sum_(j = 1)^m a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^(m') a + (- sum_(i=1)^(m') a) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `- sum_(i = 1)^(m') a = sum_(i = 1)^m a - sum_(j = 1)^(n') a`</p></li>
                <li style="list-style-type: none";><p>`sum_(i = 1)^m a - sum_(j = 1)^(n') a = - sum_(i = 1)^(m') a`</p></li>
                <li style="list-style-type: none";><p>`(m*a) - (n*a) = (m*a) + (-n'*a) = (m*a) + (n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `m*(a*b) = (m*a)*b = (a)*(m*b)`</b></p></li>
                <li><p>If `m = 0,`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*b = 0*b = 0`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b) = 0*a*b = 0`</p></li>
                <li style="list-style-type: none";><p>`(a)*(m*b) = (a)*(0*b) = 0`</p></li>
                <li><p>Suppose `m` is positive. Then `m*(a*b) = sum_(i = 1)^m a*b = (sum_(i = 1)^m a)*b = (m*a)*b`</p></li>
                <li><p>If `m` is negative, we can write `m = -m` where `m' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (m + m')*(a*b) = m*(a*b) + m'*(a*b) = m*(a*b) + a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`m*(a*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b)` is the additive inverse of `a*(m'*b)`</p></li>
                <li style="list-style-type: none";><p>`a*(m*b) + a(m'*b) = a*(m*b + m'*b) = a*((m+m')*b)) = 0`</p></li>
                <li style="list-style-type: none";></li><p>By uniqueness of the additive inverse, `a*(m*b) = m*(a*b)`</p>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `(m*a)*(n*b) = (m*n)*(a*b)`</b></p></li>
                <li><p>If `m, n` are both positive, `(m*a)*(n*b) = (sum_(i = 1)^m a)*(sum_(j = 1)^n b) = sum_(k = 1)^(m*n) a*b = (m*n)*(a*b)`</p></li>
                <li><p>If `m, n` are both negative, `EE m', n' > 0` `s.t. m = -m', n = -n'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) = (-m'*a)*(-n'*b) = -(m'*a)*(-(n'*b)) = (m'*a)*(n'*b)`</p></li>
                <li style="list-style-type: none";><p>`= (m'*n')*(a*b) = ((-m')*(-n'))*(a*b) = (m*n)*(a*b)`</p></li>
                <li><p>If `m` is negative and `n` is positive, there exists `m' > 0` `s.t. m = -m'`</p></li>
                <li style="list-style-type: none";><p>`(m*a)*(n*b) + (m'*a)*(n*b) = ((m*a) + (m'*a))*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*a)*(n*b)) = 0`</p></li>
                <li style="list-style-type: none";><p>`(m'*a)*(n*b) = (m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) + (m'*n)*(a*b) = (m*n + m'*n)*(a*b)`</p></li>
                <li style="list-style-type: none";><p>`= ((m + m')*n)*(a*b) = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `(m*n)*(a*b) = -(m'*a)*(n*b)`</p></li>
                <li style="list-style-type: none";><p>`(m*n)*(a*b) = (-m'*a)*(n*b) = (m*a)*(n*b)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(a + b) = n*a + n*b`</b></p></li>
                <li><p>If `n` is positive, `n*(a + b) = sum_(i = 1)^n (a + b) = sum_(i = 1)^n a + sum_(i = 1)^n b = (n*a) = (n*b)`</p></li>
                <li><p>If `n` is negative, we can write it as `-n'` where `n' > 0`</p></li>
                <li style="list-style-type: none";><p>`0 = (n + n')*(a + b) = n*(a + b) + n'*(a + b) = n*(a + b) + n'*a + n'*b`</p></li>
                <li style="list-style-type: none";><p>But `n*a + n*b + n'*a + n'*b = 0`</p></li>
                <li style="list-style-type: none";><p>By uniqueness of the additive inverse, `n*(a + b) = n*a + n*b`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS `n*(-a) = -(n*a)`</b></p></li>
                <li><p>`0 = n*(a + (-a)) = (n*a) + n*(-a)`</p></li>
                <li><p>Also know `(n*a) + (-n*a) = 0`</p></li>
                <li><p>By uniqueness of the additive inverse, `n*(-a) = (-n*a) = -(n*a)`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS unity is unique</b></p></li>
                <li><p>Suppose `1, 1'` are both unity elements of `R`</p></li>
                <li><p>On one hand, `1` is a mult. identity `=> 1*1' = 1'`</p></li>
                <li><p>On the other hand, `1'` is a mult. identity `=> 1*1' = 1`</p></li>
                <li><p>`=> 1 = 1'`</p></li>
              </ul>
            </div>
            <div class="proof">
              <h5>Proof</h5>
              <ul>
                <li><p><b>WTS if `a` has a left mult. inverse and a right mult. inverse, then they are equal</b></p></li>
                <li><p>Suppose `b` is a left mult. inverse of `a` and `c` is a right mult. inverse of `a`</p></li>
                <li><p>`b*a = 1, a*c = 1`</p></li>
                <li><p>`b = b*1 = b*(a*c) = (b*a)*c = 1*c = c`</p></li>
              </ul>
            </div>
            <h5>Subrings</h5>
            <ul>
              <li><p><b>Def: A <u>subring</u> of a ring `R` is a subset `S sube R` which is a ring with the operations of `+` and `*` restricted to `S`</b></p></li>
              <li><p>Unwinding this definition, we see that `+: SxxS->R`, `(s_1, s_2)|->s_1 + s_2` must have image contained in `S` (closed under addition) and `*: SxxS->R`, `(s_1, s_2)|->s_1*s_2` must have image contained in `S` (closed under multiplication)</p></li>
              <li><p>We must have `0 in S` and for every `s in S, -s in S` (closed under taking additive inverses)</p></li>
              <li><p><b>In fact, we see that `S` is a subring if and only if `s_1 - s_2 in S` and `s_1*s_2 in S`, `AA s_1, s_2 in S`</b></p></li>
              <li><p>Ex: `3ZZ sube ZZ` is a subring of `ZZ`</p></li>
              <li><p>Ex: `QQ sube RR` is a subring of `RR`</p></li>
              <li><p>Ex: `{lambda Id}_(lambda in R) sube End_RR(V)` where `V` is a finite dimensional real vector space</p></li>
            </ul>
            <h5>Exercises</h5>
            <ul>
              <li><p>Let `R_1, ..., R_n` be rings. The direct sum of `R_1, ..., R_n`, `R_1 o+ R_2 o+ ... o+ R_n` is the set which is the Cartesian product `prod_(i = 1)^n R_i` with ring operations performed component-wise</p></li>
              <li><p>`(a_1, ..., a_n) + (b_1, ..., b_n) = (a_1 + b_1, ..., a_n + b_n)`</p></li>
              <li><p>`(a_1, ..., a_n) * (b_1, ..., b_n) = (a_1 * b_1, ..., a_n * b_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R_1, ..., R_n` are rings with nonzero elements. Show that `R = R_1 o+ ... o+ R_n` has unity `<=>` each `R_i` has a unity</b></p></li>
                <li><p>(`=>`) Assume `R` has unity, say `(e_1, ..., e_n)`. We want to show that each `R_i` has a unity element. We need to show that `e_i` is the mult. identity of `R_i` for each `i`.</p></li>
                <li><p>Need to show: given `r_i in R_i`, `e_i*r_i = r_i*e_i = r_i`</p></li>
                <li><p>Consider a function `f:R_j->R_1 o+ ... o+ R_n, r_j |-> (0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>We know that `(0, ..., 0, r_j, 0, ..., 0) * (e_1, ..., e_n) = (0, ..., 0, r_j, 0, ..., 0) = (e_1, ..., e_n)*(0, ..., 0, r_j, 0, ..., 0)`</p></li>
                <li><p>`=> (0*e_1, ..., r_j*e_j, ..., 0*e_n) = (e_1*0, ..., e_j*r_j, ..., 0*e_n)`</p></li>
                <li><p>`=> (0, ..., 0, r_j*e_j, 0, ..., 0) = (0, ..., 0, e_j*r_j, 0, ..., 0)`</p></li>
                <li><p>This shows that `e_j*r_j = r_j = r_j*e_j, AA r in R_j => e_j` is a mult identity of `R_j`</p></li>
                <li><p>(`lArr`) Assume that each `R_i` has a mult. identity. We need to show that `R` does too.</p></li>
                <li><p>Say `e_i` is the mult. identity of `R_i`. We claim that `(e_1, ..., e_n)` is the mult. identity of `R`. We must show that `(e_1, ..., e_n)*(r_1, ..., r_n) = (r_1, ..., r_n)*(e_1, ..., e_n) = (r_1, ..., r_n), AA (r_1, ..., r_n) in R`</p></li>
                <li><p>`(e_1, ..., e_n)*(r_1, ..., r_n) = (e_1*r_1, ..., e_n*r_n) = (r_1, ..., r_n)`</p></li>
                <li><p>`(r_1, ..., r_n)*(e_1, ..., e_n) = (r_1*e_1, ..., r_n*e_n) = (r_1, ..., r_n)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is a positive even integer `n` `s.t. a^n = a` for all `a in R`. Show that `-a = a` for all `a in R`.</b></p></li>
                <li><p>We can write `n = 2k` for some positive integer `k`</p></li>
                <li style="list-style-type: none";><p>`-a = (-a)^n = (-a)^(2k) = ((-a)^2)^k = (a^2)^k = a^(2k) = a^n = a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Suppose that there is an integer `n > 1` such that `x^n = x, AA x in R`. If `m` is a positive integer such that `a^m = 0` for some `a`, show that `a = 0`</b></p></li>
                <li><p>Case 1: `m <= n`</p></li>
                <li style="list-style-type: none";><p>`a = a^n = a^m * a^(n-m) = 0 * a^(n-m) = 0`</p></li>
                <li><p>Case 2: `m > n`</p></li>
                <li style="list-style-type: none";><p>Choose `m` to be the smallest positive integer `s.t. a^m = 0`</p></li>
                <li style="list-style-type: none";><p>Suppose for a contradiction `m > n`</p></li>
                <li style="list-style-type: none";><p>`0 = a^m = a^n * a^(m-n) = a*a^(m-n) = a^(m-n+1)`</p></li>
                <li style="list-style-type: none";><p>Since m was chosen to be the smallest positive integer with this property, `m-n+1 >= m => -n + 1 >= 0 => 1 >= n`</p></li>
                <li style="list-style-type: none";><p>This contradicts the assumption that `n > 1`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="integral_domains">
            <h3>Integral Domains</h3>
            <ul>
              <li><p>`ZZ` has more structure than an arbitrary ring does</p></li>
              <li><p>`ZZ` is a commutative ring</p></li>
              <li><p>`ZZ` has a mult. identity</p></li>
              <li><p>`ZZ` has the property that if `a, b != 0`, then `ab != 0`</p></li>
              <li><p><b>Def: A <u>zero-divisor</u> in a commutative ring is a nonzero element `z in R` `s.t.` there exists a nonzero element `y in R` `s.t.` `zy = 0`</b></p></li>
              <li><p><b>Def: An <u>integral domain</u> is a unital commutative ring `R` `s.t.` if `a, b in R` `s.t. ab = 0`, then either `a = 0` or `b = 0`</b></p></li>
              <li><p>We almost have division in integral domains: we have cancellation</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `R` be a domain. Suppose that `a != 0 in R`. Then `ab = ac => b= c`</b></p></li>
                <li><p>`ab = ac => ab - ac = 0 => a(b-c) = 0`</p></li>
                <li><p>Since `a != 0`, `b-c = 0 => b = c`</p></li>
              </div>
              <li><p>Ex: `QQ` is a domain</p></li>
              <li><p>Ex: the Gaussian integers `ZZ[i] = {a + bi | a, b in ZZ}` is a domain</p></li>
              <li><p>Ex: `CC[x]` - the ring of polynomials in a single indeterminate `x` with coefficients `in CC` is a domain</p></li>
              <li><p>NonEx: `ZZ // (4ZZ)` is not a domain because `[2]_4 * [2]_4 = [4]_4 = [0]_4`</p></li>
              <li><p><b>Def: A <u>field</u> is a domain `F` `s.t.` every nonzero element of `F` has a mult. inverse</b></p></li>
              <li><p>Ex: `RR` is a field</p></li>
              <li><p>Ex: `CC(t) = {f(t)/g(t) | f(t), g(t) in CC(t)}` the ring of rational functions whose coefficients are in `CC` is a field</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `D` be a finite integral domain. Then `D` is a field.</b></p></li>
                <li><p>Need to show that every nonzero element has a mult. inverse</p></li>
                <li><p>Let `a != 0 in D`. Consider the function `phi_a: D->D`, `y |-> ay`</p></li>
                <li><p>If we show that `phi_a` is surjective, then we are done</p></li>
                <li><p>Since `D` is finite, by the pigeonhole principle, `phi_a` is surjective `<=> phi_a` is injective</p></li>
                <li><p>Therefore, it suffices to show that `phi_a` is injective</p></li>
                <li><p>Suppose `b, c in D` `s.t.` `phi_a(b) = phi_a(c) => ab = ac`</p></li>
                <li><p>Since `a != 0` and `D` is a domain, we conclude that `b = c => phi_a` is injective</p></li>
                <li><p>Since `phi_a` is surjective, if we fix `1 in D`, we can find an element `b in D` `s.t.` `phi_a(b) = ab = 1 => b` is the mult. inverse of `a`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Corollary: `ZZ // pZZ` is a field `<=> p` is prime</b></p></li>
                <li><p>(`=>`) Suppose `ZZ // pZZ` is a field but `p` is not prime</p></li>
                <li><p>Then `p = qr`, `1 < q, r < p`</p></li>
                <li><p>Then `[q]_p*[r]_p = [p]_p = [0]_p => ZZ // pZZ` has zero-divisors, which contradicts `ZZ // pZZ` is a field</p></li>
                <li><p>(`lArr`) If `p` is prime, then we must show `ZZ // pZZ` is a domain by the previous result</p></li>
                <li><p>Suppose `[a]_p * [b]_p = [0]_p <=> ab = pk` for some integer `k`</p></li>
                <li><p>`p` prime `=> p|ab <=> p|a` or `p|b <=> [a]_p = [0]_p` or `[b]_p = [0]_p => ZZ // pZZ` is a domain</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain and `S` is a subring of `R` which contains `1 in R`, then `S` itself is an integral domain</b></p></li>
                <li><p>`S` is commutative &#10003;</p></li>
                <li><p>`S` has a mult. identity &#10003;</p></li>
                <li><p>If `s_1, s_2 in S` `s.t.` `s_1*s_2 = 0 in S`, this same equation holds in `R`</p></li>
                <li><p>Since `R` is a domain, `s_1s_2 = 0 => s_1 = 0 or s_2 = 0`</p></li>
              </div>
              <li><p>Ex: Notice that in `ZZ // nZZ`, `n[a]_n = [na]_n = [0]_n`</p></li>
              <li style="list-style-type: none";><p>Multiplication by `n` kills all elements of `ZZ // nZZ`</p></li>
              <li><p>Ex: Consider `CC` (along with all subrings `R` of `CC` containing `1`). There does not exist a positive integer `n` `s.t.` `n*z = 0` `AA z in CC` and `n*z = 0` `AA z in R`</p></li>
              <li style="list-style-type: none";><p>The only integer which kills all of `CC` (or `R`) is `0`</p></li>
              <li><p>The integer `n` in these examples is called the characteristic of the ring</p></li>
              <li><p><b>Def: the <u>characteristic</u> of a ring `R` is the least nonnegative integer `n` `s.t.` `n*r = 0` `AA r in R`</b></p></li>
              <li><p>`char(ZZ // nZZ) = n`, `char(CC) = 0`</p></li>
              <li><p>When `R` is a unital commutative ring, we can relate `char(R)` to the order of `1 in R` (as an abelian group under `+`)</p></li>
              <li><p>If `1` has infinite order in `R`, then `char(R) = 0`</p></li>
              <li><p>If `1` has finite order, say `n`, then `char(R) = n`</p></li>
              <li style="list-style-type: none";><p>Since `o``rd(1) = n, n*1 = 0`</p></li>
              <li style="list-style-type: none";><p>`n*r = (n*1)r = 0` `AA r in R`</p></li>
              <li style="list-style-type: none";><p>`=> n` kills everything in `R`</p></li>
              <li style="list-style-type: none";><p>Therefore, `n >= char(R)`</p></li>
              <li style="list-style-type: none";><p>We know that `char(R)*1 = 0 => n|char(R) => n <= char(R)`</p></li>
              <li style="list-style-type: none";><p>So `n = char(R)`</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `char(R) = 0` or `char(R) = p` for some prime number `p`</b></p></li>
                <li><p>Suppose that `R` is an integral domain and `char(R) != 0`. Suppose for a contradiction `char(R)` is not prime.</p></li>
                <li><p>If `char(R)` is not prime, `EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Notice that `(n*1)*(q*1) = (nq)*1 = p*1 = 0` where `(n*1)` and `(q*1)` are not equal to `0`</p></li>
                <li><p>This contradicts the fact that `R` is a domain</p></li>
              </div>
              <li><p>If `char(R) = n`, then the subring generated by `1` in `R` is isomorphic to `ZZ // nZZ`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Suppose `R` is a commutative ring without zero divisors. (`R` is not necessarily unital.) Show that `char(R)` is `0` or prime.</b></p></li>
                <li><p>Suppose `R` is commutative with no zero divisors. Let `p = char(R)` and suppose `p != 0`. Suppose for a contradiction that `p` is not prime.</p></li>
                <li><p>`=> EE n, q in ZZ^+` `s.t.` `p = nq`, `1 < n, q < p`</p></li>
                <li><p>Claim: we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>Suppose not. Then for all `r in R`, `n*r = 0` and `q*r = 0`</p></li>
                <li><p>But `1 < n, q < p = char(R)`</p></li>
                <li><p>This contradicts the fact that `p` is the least nonnegative integer `s.t.` `p*r = 0` `AA r in R`</p></li>
                <li><p>Thus, we can find `a, b in R` `s.t.` `n*a != 0` and `q*b != 0`</p></li>
                <li><p>`(n*a) * (q*b) = (n*q)*(a*b) = p*(a*b) = 0`</p></li>
                <li><p>This contradicts the assumption that `R` does not have zero divisors</p></li>
              </div>
              <div class="proof">
                <li><p><b>Suppose `R` is a commutative ring with prime characteristic `p`. Show that `(x + y)^p = x^p + y^p, AA x, y in R` and `(x + y)^(p^n) = x^(p^n) + y^(p^n)`, for all positive integers `n`</b></p></li>
                <li><p>`(x + y)^p = sum_(i = 0)^p ((p), (i)) x^iy^(p-i)`</p></li>
                <li><p>`= ((p), (0))x^0y^(p) + ((p), (1))xy^(p-1) + ... + ((p), (p-1))x^(p-1)y + ((0), (p))x^p`</p></li>
                <li><p>`= y^p + pxy^(p-1) + ((p), (2))x^2y^(p-2) + ... + ((p), (p-2))x^(p-2)y^2 + px^(p-1)y + x^p`</p></li>
                <li><p>It suffices to show that `((p), (i))` is divisible by `p`</p></li>
                <li><p>`((p), (i)) = (p!) / ((p-i)!p!) = (p * ... * (p-i+1) * (p-i) * ... * 1) / ((p-i)*...*1*i!)`</p></li>
                <li><p>` = (p*...*(p-i+1)) / (i!) = p(((p-1)*...*(p-i+1)) / (i!))`</p></li>
                <li><p>`=> p` divides `((p), (i))`</p></li>
                <li><p>So `y^p + p(_) + ... + p(_) + x^p = y^p + x^p`</p></li>
                <li><p>Base Case: We just proved `(x+y)^(p^1) = x^(p^1) + y^(p^1)` for all `x, y in R`</p></li>
                <li><p>Inductive Hypothesis: Assume that for some integer `k >= 1`, `(x+y)^(p^k) = x^(p^k) + y^(p^k)`</p></li>
                <li><p>`(x+y)^(p^(k+1)) = ((x+y)^(p^k))^p = (x^(p^k) + y^(p^k))^p = ((x^(p^k))^p + (y^(p^k))^p)`</p></li>
                <li><p>`= x^(p^(k+1)) + y^(p^(k+1))`</p></li>
                <li><p>By induction, `(x+y)^(p^n) = x^(p^n) + y^(p^n), AA n in ZZ^+`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a finite commutative ring with unity. Prove that every nonzero element of `R` is either a zero-divisor or a unit</b></p></li>
                <li><p>Let `a != 0` be a non zero-divisor. We claim that `a` is a unit</p></li>
                <li><p>Define `phi_a: R -> R`, `x |-> ax`. We claim that `phi_a` is injective</p></li>
                <li><p>Suppose `x, y in R` `s.t.` `phi_a (x) = phi_a (y)`</p></li>
                <li><p>Then `ax = ay <=> a(x-y) = 0`</p></li>
                <li><p>Since `a` is not a zero divisor and `a != 0`, `x-y = 0 <=> x = y`</p></li>
                <li><p>By the Pigeonhole Principle, `phi_a` is also surjective</p></li>
                <li><p>If we fix `1 in R`, we can find `b in R` `s.t.` `phi_a (b) = 1 <=> ab = 1 => a` is a unit</p></li>
              </div>
              <li><p>Let `R` be an integral domain. A subdomain `S` of `R` is a subring of `R` `s.t.` `S` contains the `1` element of `R`.</p></li>
              <div class="proof">
                <li><p><b>Exercise: Let `P = {n*1 | n in ZZ} sube R`. Show that `P` is contained in every subdomain. What is the order of `P`?</b></p></li>
                <li><p>Let `S` be a subdomain of `R`. We claim that `P sube S`</p></li>
                <li><p>Any element of `P` has the form `n*1` for some integer `n`</p></li>
                <li><p>Case 1 `(n = 0)`: `0*1 = 0 in S`</p></li>
                <li><p>Case 2 `(n > 0)`: `n*1 = sum_(i = 1)^n 1 in S` because `S` is closed under addition</p></li>
                <li><p>Case 3 `(n < 0)`: `n = -n', n' > 0`. `n'*1 in S => -n'*1 in S` so `S` is closed under taking additive inverses</p></li>
                <li><p>Therefore `P sube S`</p></li>
                <li><p>Claim: the order of `P = char(R)`</p></li>
                <li><p>If `n*1 = 0 in R, n*1 = 0 in P`</p></li>
                <li><p>`n = char(R), o rd(P) | char(R) => o rd(P) <= char(R)`</p></li>
                <li><p>`o rd(P)*1 = 0 in P => o rd(P)*1 = 0 in R => char(R) <= o rd(P)`</p></li>
              </div>
              <li><p>A ring element `a` is idempotent if `a^2 = a`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Prove that the only idempotent elements of an integral domain are `0` and `1`</b></p></li>
                <li><p>If `a` is idempotent, then `a^2 = a <=> a^2 - a = 0 <=> a(a-1) = 0`</p></li>
                <li><p>`<=> a = 1` or `a = 0`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ideals">
            <h3>Ideals</h3>
            <ul>
              <li><p>From group theory, the cosets of a normal subgroup `N` in a group `G` form a group themselves</p></li>
              <li><p>It turns out that, with rings, the quotient of a ring by an arbitrary subring need not be a ring itself</p></li>
              <li><p><b>Definition: A (two-sided) <u>ideal</u> of a ring `R` is a subring `I sube R` `s.t.` `rI sube I, Ir sube I` `AA r in R`</b></p></li>
              <li><p><b>Definition: An <u>ideal</u> of a commutative ring `R` is a subset `I sube R` `s.t.` `I` is a subgroup of the additive group of `R` and `rI sube I` for all `r in R`</b></p></li>
              <li><p>Ex: Fix a ring `R`. The set consisting of `{0}` is an ideal generated by a single element</p></li>
              <li><p>Ex: `I = {f in CC[t]` `|` `t|f} = (t) = {tf}`</p></li>
              <li style="list-style-type: none";><p>Let `f, g in I => EE f', g' in CC[t]` `s.t.` `f = f't, g = g't`</p></li>
              <li style="list-style-type: none";><p>`f + g = f't + g't = t(f' + g')`</p></li>
              <li style="list-style-type: none";><p>Let `h in CC[t], f in I => EE f' in CC[t]` `s.t.` `f = f't`</p></li>
              <li style="list-style-type: none";><p>Then `hf = h*f't = t(hf') in I`</p></li>
              <li><p>This is an example of a principal ideal: an ideal generated by a single element</p></li>
              <li><p>Ex: Given a ring `R` and elements `a_1, ..., a_n in R`, we can consider the set of all `R`-linear combinations of `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>`{r_1a_1 + ... + r_na_n | r_i in R} = (a_1, ..., a_n)` is the ideal generated by `a_1, ..., a_n`</p></li>
              <li style="list-style-type: none";><p>Let `sum_(i = 1)^n r_ia_i, sum_(i = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`sum_(i = 1)^n r_ia_i - sum_(i= = 1)^n s_ia_i = sum_(i = 1)^n (r_i-s_i)a_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>Let `r in R, sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>We claim that `r*sum_(i = 1)^n r_ia_i in (a_1, ..., a_n)`</p></li>
              <li style="list-style-type: none";><p>`r*sum_(i = 1)^n r_ia_i = sum_(i = 1)^n rr_ia_i in (a_1, ..., a_n)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Given two ideals `I, J in R`, let `I+J = {i + j | i in I, j in J}`. Show that `I+J` is an ideal</b></p></li>
                <li><p>Let `i_1 + j_1 in I + J` and `i_2 + j_2 in I + J` for `i_1, i_2 in I` and `j_1, j_2 in J`</p></li>
                <li><p>`(i_1 + j_1) - (i_2 + j_2) = (i_1 - i_2) + (j_1 - j_2) in I + J`</p></li>
                <li><p>Let `i + j in I + J`. Let `r in R`.</p></li>
                <li><p>`r(i + j) = ri + rj in I + J` and `(i + j)r = ir + ij in I + J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be ideals of a ring `R`. Let `IJ = {sum_(k = 1)^n i_kj_k | i_k in I, j_k in J, n in ZZ^+}`. Show that `IJ` is an ideal</b></p></li>
                <li><p>Let `sum_(k = 1)^n i_kj_k, sum_(l = 1)^m i'_lj'_l in IJ`</p></li>
                <li><p>Then `sum_(k = 1)^n i_kj_k - sum_(l = 1)^m i'_lj'_l = sum_(k = 1)^n i_kj_k + sum_(l = 1)^m (-i'_l)(j'_l) in IJ`</p></li>
                <li><p>Let `r in R`. Let `sum_(k = 1)^n i_kj_k in IJ`</p></li>
                <li><p>`r*sum_(k = 1)^n i_kj_k = sum_(k = 1)^n ri_kj_k = sum_(k = 1)^n (ri_k)j_k in IJ`</p></li>
                <li><p>`(sum_(k = 1)^n i_kj_k)*r = ... = sum_(k = 1)^n i_k(j_kr) in IJ`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `I, J` be two ideals of `R`. Show that `I nn J` is an ideal</b></p></li>
                <li><p>From group theory, since `I, J` are subgroups of `(R, +)`, `I nn J` is a subgroup of `(R, +)`</p></li>
                <li><p>Let `z in I nn J`. Let `r in R`. We claim that `rz, zr in I nn J`</p></li>
                <li><p>`z in I nn J => z in I => rz in I`</p></li>
                <li><p>`z in I nn J => z in J => rz in J`</p></li>
                <li><p>`=> rz in I nn J` (similarly for `zr`)</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: If `I` and `J` are two ideals in a unital commutative ring, show that `IJ sube I nn J`</b></p></li>
                <li><p>Let `i in I, j in J`</p></li>
                <li><p>`ij = (i)j in J` (`i in R, j in J`)</p></li>
                <li><p>`ij = i(j) in I` (`i in I, j in R`)</p></li>
                <li><p>`=> ij in I nn J`</p></li>
              </div>
              <div class="proof">
                <li><p><b>If `I` and `J` are two ideals in a unital commutative ring `R` `s.t.` `I + J = R`, show that `IJ = I nn J`</b></p></li>
                <li><p>Since `I + J = R`, given any `r in R`, we can write `r = i + j` for some `i in I, j in J`</p></li>
                <li><p>In particular, `1 = i + j` for some `i in I, j in J`</p></li>
                <li><p>Let `z in I nn J`. We claim `z in IJ`</p></li>
                <li><p>`z = 1*z = (i + j)*z = iz + jz`</p></li>
                <li><p>`z in I nn J => z in I, z in J`</p></li>
                <li><p>Since `i in I, z in J, iz in IJ`</p></li>
                <li><p>Since `j in J, z in I, jz in IJ`</p></li>
                <li><p>So `iz + jz in IJ`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="quotient_rings">
            <h3>Quotient Rings</h3>
            <ul>
              <li><p>Let `R` be a ring and let `I` be an ideal</p></li>
              <li><p>Let `R//I = {r + I | r in R}`. We will put a ring structure on `R//I`</p></li>
              <li><p>From group theory, `R` is an abelian group under `+` and `I` is a subgroup</p></li>
              <li><p>Therefore, `R//I` is a group under `+`, which is defined as `(r_1 + I) + (r_2 + I) = (r_1 + r_2 + I)`</p></li>
              <li><p>We define multiplication by `(r_1 + I) * (r_2 + I) = (r_1r_2 + I)`</p></li>
              <div class="proof">
                <li><p>We claim that this is well-defined</p></li>
                <li><p>Suppose `r_1 + I = s_1 + I, r_2 + I = s_2 + I`</p></li>
                <li><p>We need to show that `r_1r_2 + I = s_1s_2 + I`</p></li>
                <li><p>`r_1 + I = s_1 + I <=> r_1 - s_1 in I`</p></li>
                <li><p>`r_2 + I = s_2 + I <=> r_2 - s_2 in I`</p></li>
                <li><p>Notice that `r_1r_2 + I = s_1s_2 + I <=> r_1r_2 - s_1s_2 in I`</p></li>
                <li><p>Since `r_1-s_1, r_2-s_2 in I`, we see that `(r_1-s_1)(r_2-s_2) = r_1r_2 - s_1r_2 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2`</p></li>
                <li><p>`= r_1r_2 - r_2s_1 - r_1s_2 + s_1s_2 + (s_1s_2 - s_1s_2)`</p></li>
                <li><p>`= (r_1r_2 - s_1s_2) - s_1(r_2-s_2) - s_2(r_1-s_1)`</p></li>
                <li><p>`=> r_1r_2 - s_1s_2 in I`</p></li>
              </div>
              <li><p>Ex: `ZZ // nZZ` is the quotient of `ZZ` by the ideal `nZZ`</p></li>
              <li><p>Ex: Let's determine what the cosets of `(t)` in `CC[t]` are. What is `(CC[t])/((t))`?</p></li>
              <li style="list-style-type: none";><p>Given `f(t) in CC[t]`, we can consider the polynomial `f(t) - f(0)` which lies in `(t)`</p></li>
              <li style="list-style-type: none";><p>Therefore, `f(t) + (t) = f(0) + t` as cosets</p></li>
              <div class="proof" id="inzz">
                <li><p>Ex: Classify all ideals in `ZZ`. We claim that every ideal has the form `nZZ` for some `n in ZZ^+`</p></li>
                <li><p>Let `I != (0)` be an ideal of `ZZ`. Let `n` be the least positive integer in `I`</p></li>
                <li><p>We claim `I = nZZ`. It suffices to show that `n | m`, `AA m in I`</p></li>
                <li><p>Let `m != 0 in I`. Assume that `m > 0`. Consider `gcd(m,n)`</p></li>
                <li><p>By the Euclidean algorithm, we can write `gcd(m,n) = am + bn` for some `a, b in ZZ^+`</p></li>
                <li><p>`m, n in I => gcd(m,n) = am + bn in I`</p></li>
                <li><p>Therefore, `gcd(m,n) in I` but `0 < gcd(m,n) <= n => gcd(m,n) = n` (since `n` is the least positive integer in `I`) `=> n|m`</gcd></p></li>
                <li><p>If `m < 0`, then `-m in I` and the argument we just proved shows that `n|-m =>n|m`</0> </p></li>
              </div>
              <div id="prime_ideal" class="proof">
                <li><p>`pZZ` where `p` is prime is a "special type" of ideal</p></li>
                <li><p>Let `a, b in ZZ` `s.t.` `p|ab`. Then `p|a` or `p|b`</p></li>
                <li><p>`ab in pZZ <=> p|ab => p|a` or `p|b <=> a in pZZ` or `b in pZZ`</p></li>
                <li><p>So `ab in pZZ => a in pZZ` or `b in pZZ`</p></li>
              </div>
                <li><p>If `aZZ, bZZ` are two ideals of `ZZ`, then `aZZ * bZZ sube pZZ => aZZ sube pZZ` or `bZZ sube pZZ`</p></li>
              <li><p>Such ideals with this property are called prime ideals</p></li>
              <li><p><b>Definition: An ideal `p sube R` is a <u>prime ideal</u> if `p` is a proper ideal and whenever `ab in p`, we must have `a in p` or `b in p` `AA a, b in R`</b></p></li>
              <div class="proof">
                <li><p><b>`pZZ` is a prime ideal `<=> p` is prime</b></p></li>
                <li><p>(`lArr`)<a href="#prime_ideal"> We've already seen that if `p` is prime, then `pZZ` is a prime ideal</a></p></li>
                <li><p>(`=>`) Suppose `pZZ` is a prime ideal. It suffices to show that if `p = ab` where `a, b > 0`, then `p = a` or `p = b`</p></li>
                <li><p>If `p = ab`, then `ab in pZZ`</p></li>
                <li><p>Since `pZZ` is a prime ideal, we must have either `a in pZZ` or `b in pZZ`</p></li>
                <li><p>`a in pZZ <=> p|a` and `b in pZZ <=> p|b`</p></li>
                <li><p>Either `p|a` or `p|b`</p></li>
                <li><p>Since `a, b, p > 0`, `p|a` and `a|p` `=> a = p`</p></li>
                <li><p>`p|b` and `b|p` `=> b = p`</p></li>
                <li><p>`=> p` is a prime number</p></li>
              </div>
              <li><p><b>Definition: An ideal `m` of a commutative ring `R` is said to be <u>maximal</u> if `m sub R` (`m` is a proper ideal) and, whenever `I` is an ideal `s.t.` `m sube I`, we must have `I = m` or `I = R`</b></p></li>
              <li><p>Ex: Returning to `ZZ`, it turns out that `pZZ` is not only prime, but also maximal when `p` is prime</p></li>
              <div class="proof">
                <li><p><b>We claim `pZZ` is maximal</b></p></li>
                <li><p>Suppose `pZZ sube I` where `I` is an ideal of `ZZ`</p></li>
                <li><p><a href="#inzz">We've already seen that `I = nZZ` for some positive integer `n`</a></p></li>
                <li><p>Therefore, `pZZ sube nZZ`</p></li>
                <li><p>In particular, `p in pZZ sube nZZ => p in nZZ <=> n|p`</p></li>
                <li><p>Since `p` is prime, we either have `n = p` (`=> nZZ = pZZ`) or `n = 1` (`=> nZZ = ZZ`)</p></li>
                <li><p>So `pZZ` is maximal</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a commutative ring with unity, then the following are equivalent</b></p></li>
                <li><p><b>1) `p` is a prime ideal</b></p></li>
                <li><p><b>2) `R // p` is an integral domain</b></p></li>
                <li><p><b>and</b></p></li>
                <li><p><b>3) `M` is a maximal ideal</b></p></li>
                <li><p><b>4) `R // M` is a field</b></p></li>
                <li><p>(`1 => 2`): Suppose `p` is a prime ideal. We already know that `R // p` is a commutative ring with unity. We must show that `R // p` has no zero-divisors</p></li>
                <li><p>Suppose `(x + p)(y + p) = (0 + p) => (xy + p) = (0 + p) <=> xy in p`</p></li>
                <li><p>Since `p` is a prime ideal, `xy in p <=> x in p` or `y in p`</p></li>
                <li><p>If `x in p`, then `x + p = 0 + p`</p></li>
                <li><p>If `y in p`, then `y + p = 0 + p`</p></li>
                <li><p>Then `R // p` is an integral domain</p></li>
                <li><p>(`2 => 1`): Suppose `R // p` is an integral domain. Let `x, y in R` `s.t.` `xy in p`</p></li>
                <li><p>We claim that `x in p` or `y in p`</p></li>
                <li><p>Consider `(x + p)*(y + p) = (xy + p)`</p></li>
                <li><p>Since `xy in p, (xy + p) = (0 + p)`</p></li>
                <li><p>Since `R // p` is an integral domain, we must have either `x + p = 0 + p <=> x in p` or `y + p = 0 + p <=> y in p`</p></li>
                <li><p>Therefore `p` is prime</p></li>
                <li><p>(`3 => 4`): Assume that `M` is a maximal ideal</p></li>
                <li><p>Let `x + M != 0 + M in R // M`</p></li>
                <li><p>We claim that there exists `y + M in R // M` `s.t.` `(x + M)*(y + M) = 1 + M => xy + M = 1 + M`</p></li>
                <li><p>We need to show that we can find `y in R` `s.t.` `xy = 1 (mod M)`</p></li>
                <li><p>Consider the ideal `(x) + M sube R`</p></li>
                <li><p>We know that `(x) + M != M` since `x notin M`</p></li>
                <li><p>Since `(x) + M sup M` and `M` is maximal, `(x) + M = R`</p></li>
                <li><p>We need to use the fact that `(x) + M = R` to produce an element `y` `s.t.` `xy - 1 in M`</p></li>
                <li><p>Since `(x) + M = R`, we can find `y in R, m in M` `s.t.` `xy + m = 1 => xy - 1 = m in M`</p></li>
                <li><p>So `xy = 1 (mod M) <=> y + M` is the multiplicative inverse of `x + M`</p></li>
                <li><p>(`4 => 3`): Suppose `R // M` is a field</p></li>
                <li><p>Let `I` be an ideal of `R` `s.t.` `M sube I`</p></li>
                <li><p>We must show that `I = R <=> 1 in I`</p></li>
                <li><p>Consider `(I + M) // M = {i + M | i in I}`</p></li>
                <li><p>It turns out that `(I + M) // M` is an ideal of `R // M`</p></li>
                <li><p>Let `i_1 + M, i_2 + M in (I + M) // M`</p></li>
                <li><p>Notice that `(i_1 + M) - (i_2 + M) = ((i_1 - i_2) + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M` is a subgroup of `R // M`</p></li>
                <li><p>Let `i + M in (I + M) // M, r + M in R // M`</p></li>
                <li><p>Notice that `(r + M)*(i + M) = (ri + M) in (I + M) // M`</p></li>
                <li><p>Therefore, `(I + M) // M = {i + M | i in I}` is an ideal of `R // M`</p></li>
                <li><p>This is not the zero ideal since `I sup M`</p></li>
                <li><p>Therefore, there exists `i + M != 0 + M in (I + M) // M`</p></li>
                <li><p>`R // M` is a field `=> EE j + M in R // M` `s.t.` `(i + M)(j + M) = 1 + M = ij + M`</p></li>
                <li><p>Since `(I + M) // M` is an ideal containing `i + M`, `(i + M)(j + M) = 1 + M in (I + M) // M`</p></li>
                <li><p>Since `(ij + M) = (1 + M), 1 - ij in M`</p></li>
                <li><p>Remember `i in I => ij in 1` and `m sub I => 1 - ij in I`</p></li>
                <li><p>Therefore, `1 - ij = i' in I`, so `1 = ij + i' in I => 1 in I => I = R`</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="ring_homomorphisms">
            <h3>Ring Homomorphisms</h3>
            <ul>
              <li><p>In group theory, we saw that group homomorphisms allow us to translate data from one group to another</p></li>
              <li><p>`phi(g_1 **_1 g_2) = phi(g_1) **_2 phi(g_2)`</p></li>
              <li><p><b>Definition: Let `R, S` be rings. A <u>ring homomorphism</u> `phi: R -> S` is a function from `R` to `S` `s.t.` `AA r_1, r_2 in R`</b></p></li>
              <li style="list-style-type: none";><p>1) `phi(r_1 + r_2) = phi(r_1) + phi(r_2)`</p></li>
              <li style="list-style-type: none";><p>2) `phi(r_1r_2) = phi(r_1)phi(r_2)`</p></li>
              <li><p><b>Definition: Suppose `R, S` have unity elements. A ring homomorphism is <u>unital</u> if `phi(1_R) = 1_S`</b></p></li>
              <li><p><b>Definition: A <u>ring isomorphism</u> is a ring homomorphism which is both one-to-one and onto</b></p></li>
              <div class="proof">
                <li><p><b>Ex: Let `n` be a positive integer. Then reduction modulo `n` is a ring homomorphism: `pi_n: ZZ -> ZZ // nZZ, a |-> [a]_n`</b></p></li>
                <li><p>Let `a, b in ZZ`</p></li>
                <li><p>Then `pi_n(a + b) = [a + b]_n = [a]_n + [b]_n = pi_n(a) + pi_n(b)`</p></li>
                <li><p>Also `pi_n(ab) = [ab]_n = [a]_n[b]_n = pi_n(a)pi_n(b)`</p></li>
                <li><p>Since `pi_n(1) = [1]_n, pi_n` is also unital</p></li>
              </div>
              <li><p>This is a special case of the natural projection homomorphism:</p></li>
              <li><p>Given a ring `R` and a two-sided ideal `I`, `pi_I: R -> R // I, r |-> r + I`</p></li>
              <div id="ev_hom" class="proof">
                <li><p><b>Ex: Let `z in CC`. Consider the map `ev_z: CC[t] -> CC, f |-> f(z)`. This is a ring homomorphism</b></p></li>
                <li><p>Let `f, g in CC[t]`.</p></li>
                <li><p>Then `ev_z(f+g) = (f+g)(z) = f(z) + g(z) = ev_z(f) + ev_z(g)`</p></li>
                <li><p>`ev_z(fg) = (fg)(z) = f(z)g(z) = ev_z(f)ev_z(g)`</p></li>
              </div>
              <li><p><b>Definition: Let `phi: R -> S` be a homomorphism of rings. Define the <u>kernel</u> of `phi` to be `ker(phi) = {r in R | phi(r) = 0}`</b></p></li>
              <div id="ev_ker" class="proof">
                <li><p><b>Find the kernel of `ev_0: CC[t] -> CC, f |-> f(0)`</b></p></li>
                <li><p>We claim that `ker(ev_0) = (t)`</p></li>
                <li><p>Let `f in ker(ev_0) => ev_0(f) = 0 <=> f(0) = 0 => f` has no constant term, so `t|f <=> f in (t)`</p></li>
                <li><p>Let `f in (t)`. Then there exists `f' in CC[t]` `s.t.` `f = tf'`</p></li>
                <li><p>Notice that `ev_0(f) = ev_0(tf') = 0*f'(0) = 0 => tf' = f in ker(ev_0)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Propositions: Let `R, S` be rings. Let `phi: R -> S` be a ring homomorphism. Let `A sube R` be a subring and let `B sube S` be an ideal</b></p></li>
                <li><p><b>`phi(0) = 0`</b></p></li>
                <li><p><b>`phi(r^n) = (phi(r))^n` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>`phi(nr) = n*phi(r)` `AA r in R, n in ZZ^+`</b></p></li>
                <li><p><b>If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p><b>The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p><b>If `R` is commutative, so is `phi(R)`</b></p></li>
                <li><p><b>If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p><b>`phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p><b>If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi(0) = 0`</b></p></li>
                <li><p>`0 + 0 = 0 => phi(0 + 0) = phi(0)`</p></li>
                <li><p>Since `phi` is a ring homomorphism, `phi(0 + 0) = phi(0) + phi(0)`</p></li>
                <li><p>`=> phi(0) + phi(0) = phi(0) => phi(0) = 0`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is onto, then if `A` is an ideal, then `phi(A)` is an ideal</b></p></li>
                <li><p>Suppose `A` is an ideal and `phi` is onto</p></li>
                <li><p>Let `s_1, s_2 in phi(A) sube S`</p></li>
                <li><p>Then we can find `a_1, a_2 in A` `s.t.` `phi(a_1) = s_1, phi(a_2) = s_2`</p></li>
                <li><p>Notice that `s_1 - s_2 = phi(a_1) - phi(a_2) = phi(a_1 - a_2)`</p></li>
                <li><p>Since `A` is an ideal, `a_1 - a_2 in A => s_1 - s_2 = phi(a_1 - a_2) in phi(A)`</p></li>
                <li><p>Let `s in phi(A)`. Let `s' in S`. We claim `s's in phi(A)`</p></li>
                <li><p>Since `s in phi(A), EE a in A` `s.t.` `phi(a) = s`</p></li>
                <li><p>Since `phi` is onto, `EE r in R` `s.t.` `phi(r) = s'`</p></li>
                <li><p>Notice that `s's = phi(r)*phi(a) = phi(r*a)`</p></li>
                <li><p>`A` is an ideal and `a in A => ra in A => s's = phi(ra) in phi(A)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS The preimage of `B`, `phi^-1(B) = {r in R | phi(r) in B}` is an ideal</b></p></li>
                <li><p>Let `r_1, r_2 in phi^-1(B)`. We need to show that `r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>`r_1, r_2 in phi^-1(B) => phi(r_1), phi(r_2) in B`</p></li>
                <li><p>Notice that `phi(r_1) - phi(r_2) in B` since `B` is an ideal</p></li>
                <li><p>But `phi(r_1) - phi(r_2) = phi(r_1 - r_2) in B <=> r_1 - r_2 in phi^-1(B)`</p></li>
                <li><p>Let `r in phi^-1(B), r' in R`. We claim `r'r in phi^-1(B)`</p></li>
                <li><p>Notice that `phi(r'r) = phi(r')*phi(r) in B` since `B` is an ideal and `phi(r) in B`</p></li>
                <li><p>`phi(r'r) in B <=> r'r in phi^-1(B)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `R` is unital, `S` is not the zero ring, and `phi` is onto, then `S` is unital and `phi(1)` is the unity of `S`</b></p></li>
                <li><p>Suppose `phi: R -> S` is onto, `1 in R`</p></li>
                <li><p>We claim that `phi(1)` is a unity of `S <=>` given any `s in S, phi(1)*s = s = s*phi(1)`</p></li>
                <li><p>Let `s in S`. Since `phi` is onto, we can find `r in R` `s.t.` `phi(r) = s`</p></li>
                <li><p>Then `phi(1)*s = phi(1)*phi(r) = phi(1*r) = phi(r) = s`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS `phi` is one-to-one `<=> ker(phi) = 0`</b></p></li>
                <li><p>`(=>)` Suppose `phi` is one-to-one. Since `0` is an element of `R` which maps to `0 in S`, `phi` is one-to-one `=>` if `phi(r) = 0`, then `r = 0`</p></li>
                <li><p>`(lArr)` Suppose `ker(phi) = 0`. Let `r_1, r_2 in R` `s.t.` `phi(r_1) = phi(r_2)`</p></li>
                <li><p>Then `phi(r_1) - phi(r_2) = 0 => phi(r_1 - r_2) = 0 => r_1 - r_2 in ker(phi)` so `r_1 - r_2 = 0 <=> r_1 = r_2`</p></li>
              </div>
              <div class="proof">
                <li><p><b>WTS If `phi` is an isomorphism from `R` to `S`, then `phi^-1` is an isomorphism from `S` to `R`</b></p></li>
                <li><p>Suppose `phi` is an isomorphism. Then `phi` is a one-to-one and onto homomorphism</p></li>
                <li><p>Since `phi` is one-to-one and onto, `EE phi^-1: S -> R` `s.t.` `phi @ phi^-1 =` `i``d_s`, `phi^-1 @ phi =` `i``d_r`</p></li>
                <li><p>We claim that `phi^-1(s_1 + s_2) = phi^-1(s_1) + phi^-1(s_2)` and `phi^-1(s_1s_2) = phi^-1(s_1)phi^-1(s_2) AA s_1, s_2 in S`</p></li>
                <li><p>Let `s_1, s_2 in S`. Then we can find `r_1, r_2 in R` `s.t.` `phi(r_1) = s_1, phi(r_2) = s_2`</p></li>
                <li><p>`phi^-1(s_1 + s_2) = phi^-1(phi(r_1) + phi(r_2)) = phi^-1(phi(r_1 + r_2))`</p></li>
                <li><p>`= r_1 + r_2 = phi^-1(s_1) + phi^-1(s_2)`</p></li>
                <li><p>`phi^-1(s_1s_2) = phi^-1(phi(r_1)phi(r_2)) = phi^-1(phi(r_1r_2))`</p></li>
                <li><p>`= r_1r_2 = phi^-1(s_1)phi^-1(s_2)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `phi: R -> S` is a ring homomorphism, then `ker(phi)` is an ideal of `R`</b></p></li>
                <li><p>Let `r_1, r_2 in ker(phi)`. We claim `r_1 - r_2 in ker(phi)`</p></li>
                <li><p>`phi(r_1 - r_2) = phi(r_1) - phi(r_2) = 0 - 0 = 0 => r_1 - r_2 in ker(phi)`</p></li>
                <li><p>Let `r' in R, r in ker(phi)`. We claim that `r'r in ker(phi)`</p></li>
                <li><p>`phi(r'r) = phi(r')phi(r) = phi(r')*0 = 0 => r'r in ker(phi)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Show that if `I` is a two-sided ideal of `R`, then `I` is the kernel of some ring homomorphism</b></p></li>
                <li><p>Consider `pi_I: R -> R // I`. We claim that `ker(pi_I) = I`</p></li>
                <li><p>`(supe)` If `i in I => pi_I(i) = i + I = 0 + I` since `i in I`</p></li>
                <li><p>`(sube)` Suppose `r in ker(pi_I) => pi_I(r) = 0 + I`</p></li>
                <li><p>`pi_I(r) = r + I = 0 + I <=> r in I`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Ideal Correspondence Theorem: Let `R` be a commutative ring with unity and let `I` be an ideal. Then there is a one-to-one order-preserving correspondence between ideals of `R` which contain `I` and ideals of `R // I`</b></p></li>
                <img class="img-fluid" src="./pictures/ideal_correspondence_theorem.jpg">
                <li><p>Since `pi_I` is surjective, given any ideal `J sube R` which contains `I`, `pi_I(J)` is an ideal of `R // I`</p></li>
                <li><p>`pi_I(J) = {j + I | j in J} = (J + I) // I`</p></li>
                <li><p>We claim that `pi_I^-1(pi_I(J)) = J`</p></li>
                <li><p>`(supe)` If `j in J`, then `pi_I(j) = j + I in pi_I(J) => j in pi_I^-1(pi_I(j))`</p></li>
                <li><p>`(sube)` Suppose `r in pi_I^-1(pi_I(J)) => pi_I(r) in pi_I(J) => r + I in pi_I(J)`</p></li>
                <li><p>`EE j in J` `s.t.` `r + I = j + I <=> r - j in I`</p></li>
                <li><p>Since `I sube J, r - j in J => r in J`</p></li>
                <li><p>Let `H sube R // I`. Consider `pi_I^-1(H) sube R`. We claim that `pi_I^-1(H) supe I`</p></li>
                <li><p>Let `i in I => pi_I(i) = i + I = 0 + I`</p></li>
                <li><p>Since `H` is an ideal, `0 + I in H => i in pi_I^-1(H) => I in pi_I^-1(H)`</p></li>
                <li><p>We claim that `pi_I(pi_I^-1(H)) = H`</p></li>
                <li><p>Since `pi_I` is surjective, this is true.</p></li>
                <li><p>Therefore, `pi_I: {I sube J sube R} -> {(0 + I) // I sube H sube R // I}` is a bijection</p></li>
                <li><p>Suppose `I sube J_1 sube J_2`. We claim that `pi_I(J_1) sub pi_I(J_2)`</p></li>
                <li><p>We always have `J_1 sube J_2 => pi_I(J_1) sube pi_I(J_2)`</p></li>
                <li><p>If `pi_I(J_1) = pi_I(J_2) => J_1 = J_2` since correspondence is one-to-one</p></li>
                <li><p>So we must have `pi_I(J_1) sub pi_I(J_2)`</p></li>
                <li><p>Suppose `H_1 sub H_2 sube R // I`. We claim that `pi_I^-1(H_1) sub pi_I^-1(H_2)`</p></li>
                <li><p>We always have `pi_I^-1(H_1) sube pi_I^-1(H_2)`</p></li>
                <li><p>If `pi_I^-1(H_1) = pi_I^-1(H_2)`, then since `pi_I^-1` is a bijection, we must have `H_1 = H_2`</p></li>
                <li><p>Therefore, `pi_I^-1(H_1) sub pi_I^-1(H_2)`</p></li>
              </div>
              <li><p>Through this order-preserving correspondence, we can think of the set of ideals of `R // I` as a subset of the set of ideals of `R`</p></li>
              <li><p>In particular, the set of prime ideals of `R // I` can be viewed as a subset of the set of prime ideals of `R`</p></li>
              <div class="proof">
                <li><p><b>First Isomorphism Theorem: If `phi: R -> S` is a ring homomorphism, then there is an isomorphism of rings `bar phi: R // ker(phi) -> phi(R), r + ker(phi) |-> phi(r)`</b></p></li>
                <li><p>We need to prove that `bar phi` is well-defined.</p></li>
                <li><p>Let `r_1 + ker(phi) = r_2 + ker(phi) in R // ker(phi)`</p></li>
                <li><p>We claim `bar phi(r_1 + ker(phi)) = bar phi(r_2 + ker(phi))`</p></li>
                <li><p>`bar phi(r_1 + ker(phi)) = phi(r_1) and bar phi(r_2 + ker(phi)) = phi(r_2)`</p></li>
                <li><p>Therefore, we must show that if `r_1 + ker(phi) = r_2 + ker(phi)`, then `phi(r_1) = phi(r_2)`</p></li>
                <li><p>Suppose `r_1 + ker(phi) = r_2 + ker(phi) <=> r_1 - r_2 in ker(phi)`</p></li>
                <li><p>`=> phi(r_1 - r_2) = 0 => phi(r_1) - phi(r_2) = 0 => phi(r_1) = phi(r_2)`</p></li>
                <li><p>Next we check that `bar phi` is a ring homomorphism</p></li>
                <li><p>Let `r_1 + ker(phi), r_2 + ker(phi) in R // ker(phi)`</p></li>
                <li><p>Consider `bar phi((r_1 + ker(phi)) + (r_2 + ker(phi)))`</p></li>
                <li><p>`= bar phi(r_1 + r_2 + ker(phi)) = phi(r_1 + r_2) = phi(r_1) + phi(r_2)`</p></li>
                <li><p>`= bar phi(r_1 + ker(phi)) + bar phi(r_2 + ker(phi))`</p></li>
                <li><p>`bar phi((r_1 + ker(phi)) * (r_2 + ker(phi))) = bar phi(r_1r_2 + ker(phi)) = phi(r_1r_2)`</p></li>
                <li><p>`= phi(r_1)phi(r_2) = bar phi(r_1 + ker(phi)) bar phi(r_2 + ker(phi))`</p></li>
                <li><p>We must check that `bar phi` is onto. Fix `s in phi(R)`</p></li>
                <li><p>Then we can find `r in R` `s.t.` `phi(r) = s`</p></li>
                <li><p>Notice that `bar phi(r + ker(phi)) = phi(r)`, so `bar phi` is onto</p></li>
                <li><p>Suppose that `r + ker(phi) in ker(bar phi) => bar phi(r + ker(phi)) = 0`</p></li>
                <li><p>But `bar phi(r + ker(phi)) = phi(r) = 0 <=> r in ker(phi) => r + ker(phi) = 0 + ker(phi)`</p></li>
                <li><p>So `bar phi` is injective</p></li>
              </div>
              <li><p>Last time we defined `ev_0: CC[t] -> CC, f |-> f(c)`</p></li>
              <li><p><a href="#ev_hom">We saw that this is a ring homomorphism which maps onto `CC`</a></p></li>
              <li><p><a href="#ev_ker">We saw that `ker(ev_0) = (t)`</a></p></li>
              <li><p>Therefore, by the First Isomorphism Theorem, `CC[t] // (t) ~= CC`</p></li>
              <li><p>Suppose `I` is an ideal of a commutative ring `R`. Then we can use the First Isomorphism Theorem to determine what `R // I` is isomorphic to</p></li>
              <li style="list-style-type: none;"><p>Suppose we have a hunch that `R // I ~= S`. To prove this, we can exhibit a surjective ring homomorphism `phi: R -> S` whose kernel is `I`</p></li>
              <li style="list-style-type: none;"><p>First Isomorphism Theorem `=> R // I ~= S`</p></li>
              <li><p>If `char(R) = n` and `R` is unital, then `R` contains a subring `~= ZZ // nZZ`</p></li>
              <li style="list-style-type: none;"><p>`varepsilon_R: ZZ -> R, m |-> m*1`</p></li>
              <li style="list-style-type: none;"><p>Since `char(R) = n`, the additive order of `1` in `(R,+)` is `n => ker(varepsilon_R) = nZZ`</p></li>
              <li style="list-style-type: none;"><p>By the First Isomorphism Theorem, `ZZ // nZZ ~= ZZ // ker(varepsilon_R) ~= im(varepsilon_R)`</p></li>
              <li><p>If `F` is a field of `char(p)` where `p` is prime, then `F` has a subfield isomorphic to `ZZ // pZZ`, called the prime subfield of `F`</p></li>
              <li><p>What is the prime subfield of a field of characteristic `0`?</p></li>
              <li style="list-style-type: none;"><p>By the First Isomorphism Theorem, we have a subring `~= ZZ`</p></li>
              <li style="list-style-type: none;"><p>`varepsilon_R: ZZ -> F`</p></li>
              <li style="list-style-type: none;"><p>Since `char(R) = 0`, the additive order of `1` in `F` is `oo`</p></li>
              <li style="list-style-type: none;"><p>Therefore, `varepsilon_R` is injective, so `ZZ` is a subring of `F`</p></li>
            </ul>
          </div>
          <div class="content" id="field_of_fractions">
            <h3>Field of Fractions</h3>
            <ul>
              <li><p>Rational numbers can be thought of as tuples `(a,b)` where `a in ZZ, b in ZZ \\ {0}`</p></li>
              <li><p>For instance, `6/3 = 2/1`, so `(6,3) ~ (2,1)`</p></li>
              <li><p>We have to put an equivalence relation on `ZZ oplus ZZ \\ {0}`</p></li>
              <li><p>The relation is `(a,b) ~ (c,d) <=> ad - bc = 0`</p></li>
              <div class="proof">
                <li><p>Let's check that `~` defines an equivalence relation on `ZZ oplus ZZ \\ {0}`</p></li>
                <li><p>Reflexive: We must check that `(a,b) ~ (a,b)` `AA a,b in ZZ oplus ZZ \\ {0}`</p></li>
                <li><p>`(a,b) ~ (a,b) <=> ab - ba = 0`</p></li>
                <li><p>Since `ab - ba = 0 => (a,b) ~ (a,b)`</p></li>
                <li><p>Symmetric: We must check that if `(a,b) ~ (c,d)`, then `(c,d) ~ (a,b)`</p></li>
                <li><p>Assume `(a,b) ~ (c,d) <=> ad - bc = 0`</p></li>
                <li><p>`(c,d) ~ (a,b) <=> cb - da = 0`</p></li>
                <li><p>Since `ad - bc = 0 => (c,d) ~ (a,b)`</p></li>
                <li><p>Transitive: Suppose `(a,b) ~ (c,d)` and `(c,d) ~ (e,f)`</p></li>
                <li><p>We claim `(a,b) ~ (e,f)`. We must show `af - be = 0`</p></li>
                <li><p>`(a,b) ~ (c,d) => ad - bc = 0 => ad = bc`</p></li>
                <li><p>`(c,d) ~ (e,f) => cf - de = 0 => cf = de`</p></li>
                <li><p>`=> adcf = bcde => cd(af - be) = 0`</p></li>
                <li><p>Either `cd = 0 or cd != 0`</p></li>
                <li><p>If `cd = 0, d != 0 => c = 0`</p></li>
                <li><p>`ad = bc = b*0 = 0`</p></li>
                <li><p>`d != 0 => a = 0`</p></li>
                <li><p>`0*f = cd = de = 0`</p></li>
                <li><p>`d != 0 => e = 0`</p></li>
                <li><p>`af - be = 0 - 0 = 0`</p></li>
              </div>
              <li><p>We now define addition and multiplication on `ZZ oplus ZZ \\ {0} // ~`</p></li>
              <div class="proof">
                <li><p>We define addition by `(a,b) + (c,d) = (ad + bc, bd)`</p></li>
                <li><p>We must check that this is well-defined</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2)` and `(c_1,d_1) ~ (c_2,d_2)`</p></li>
                <li><p>We claim `(a_1d_1 + b_1c_1, b_1d_1) ~ (a_2d_2 + b_2c_2, b_2d_2)`</p></li>
                <li><p>`<=> a_1d_1b_2d_2 + b_1c_1b_2d_2 - (a_2d_2b_1d_1 + b_2c_2b_1d_1) = 0`</p></li>
                <li><p>`(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 - b_1a_2 = 0`</p></li>
                <li><p>`(c_1,d_1) ~ (c_2,d_2) <=> c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>Since `a_1b_2 - b_1a_2 = 0` and `c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>`=> d_1d_2(a_1b_2 - b_1a_2) + b_1b_2(c_1d_2 - c_2d_1) = 0`</p></li>
                <li><p>Therefore, `(a_1d_1 + b_1c_1, b_1d_1) ~ (a_2d_2 + b_2c_2, b_2d_2)`</p></li>
                <li><p>Now we check that multiplication is well-defined</p></li>
                <li><p>We define `(a,b) * (c,d) = (ac,bd)`</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2)` and `(c_1,d_1) ~ (c_2,d_2)`</p></li>
                <li><p>We claim `(a_1c_1, b_1d_1) ~ (a_2c_2, b_2d_2) <=> a_1c_1b_2d_2 - b_1d_1a_2c_2 = 0`</p></li>
                <li><p>Since `(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 - b_1a_2 = 0`</p></li>
                <li><p>`(c_1,d_1) ~ (c_2,d_2) <=> c_1d_2 - c_2d_1 = 0`</p></li>
                <li><p>`(a_1b_2 - b_1a_2)(c_1d_2 - c_2d_1) = 0`</p></li>
                <li><p>`a_1b_2c_1d_2 - b_1a_2c_1d_2 + b_1a_2c_2d_1 - a_1b_2c_2d_1 + (b_1a_2c_2d_1 - b_1a_2c_2d_1) = 0`</p></li>
                <li><p>`(a_1b_2c_1d_2 - b_1a_2c_2d_1) + b_1a_2(c_2d_1 - c_1d_2) + c_2d_1(b_1a_2 - a_1b_2) = 0`</p></li>
                <li><p>`=> (a_1b_2c_1d_2 - b_1a_2c_2d_1) = 0`</p></li>
              </div>
              <li><p>Given any integral domain, we define the field of fractions, `Q(A)` to be `A oplus A \\ {0} // ~`</p></li>
              <div class="proof">
                <li><p><b>Proposition: Given an integral domain `R` and an injective unital ring homomorphism `phi: R -> K` where `K` is a field, the map `phi` extends uniquely to a unital ring homomorphism `bar phi: Q(R) -> K, bar phi((r,1)``) = phi(r)`</b></p></li>
                <li><p>We first prove uniqueness of `bar phi`</p></li>
                <li><p>Suppose `bar phi, psi` are ring homomorphisms extending `phi`. We claim `bar phi = psi`</p></li>
                <li><p>`bar phi((r,1)``) = phi(r) = ``psi((r,1)``)`</p></li>
                <li><p>Since both are ring homomorphisms,</p></li>
                <li><p>`bar phi((a,b)``) = bar phi((a,1)``, (1,b)) = bar phi((a,1)``) * bar phi((1,b)``) = phi(a) * bar phi((1,b)``)`</p></li>
                <li><p>`psi((a,b)``) = psi((a,1)``, (1,b)) = psi((a,1)``) * psi((1,b)``) = phi(a) * psi((1,b)``)`</p></li>
                <li><p>Therefore, it suffices to show that `psi((1,b)``) = bar phi((1,b)``)` `AA b in ZZ \\ {0}`</p></li>
                <li><p>We show that both are multiplicative inverses of `phi(b)`</p></li>
                <li><p>Notice `psi((1,b)``) * psi((b,1)``) = psi((1,b)(b,1)) = psi((b,b)``) = 1`</p></li>
                <li><p>`=> psi((1,b)``)` is the multiplicative inverse of `psi((b,1)``) = phi(b)`</p></li>
                <li><p>`bar phi((1,b)``) * bar phi((b,1)``) = bar phi((1,b)(b,1)) = bar phi((b,b)``) = 1`</p></li>
                <li><p>`=> bar phi((1,b)``)` is the multiplicative inverse of `bar phi((b,1)``) = phi(b)`</p></li>
                <li><p>`=> psi((1,b)``) = bar phi((1,b)``)`` = phi(b)^-1`</p></li>
                <li><p>Therefore, `bar phi` is unique</p></li>
                <li><p>Now we prove existence</p></li>
                <li><p>If `bar phi` exists, it must be defined as `bar phi((a,b)``)`` = phi(a)phi(b)^-1`</p></li>
                <li><p>Let's show that `bar phi` is well-defined</p></li>
                <li><p>Suppose `(a_1,b_1) ~ (a_2,b_2) <=> a_1b_2 = b_1a_2`</p></li>
                <li><p>We claim `bar phi((a_1,b_1)``) = bar phi((a_2,b_2)``)` `<=> phi(a_1)phi(b_1)^-1 = phi(a_2)phi(b_2)^-1`</p></li>
                <li><p>Since `a_1b_2 = b_1a_2 => phi(a_1b_2) = phi(b_1a_2) => phi(a_1)phi(b_2) = phi(b_1)phi(a_2)`</p></li>
                <li><p>`b_1, b_2 != 0, phi` injective `=> phi(b_1), phi(b_2) != 0 =>` they are units</p></li>
                <li><p>Multiply `phi(a_1)phi(b_2) = phi(a_2)phi(b_1)` by `phi(b_1)^-1phi(b_2)^-1`</p></li>
                <li><p>to get `phi(a_1)phi(b_1)^-1 = phi(a_2)phi(b_2)^-1`</p></li>
                <li><p>We must check that `bar phi` is a ring homomorphism</p></li>
                <li><p>Let `(a,b), (c,d) in Q(R)`</p></li>
                <li><p>`bar phi((a,b) + (c,d)) = bar phi((ad + bc, bd)``)`</p></li>
                <li><p>`= phi(ad + bc)phi(bd)^-1 = phi(a)phi(d)phi(b)^-1phi(d)^-1 + phi(b)phi(c)phi(b)^-1phi(d)^-1`</p></li>
                <li><p>`= phi(a)phi(b)^-1 + phi(c)phi(d)^-1 = bar phi((a,b)``) + bar phi((c,d)``)`</p></li>
                <li><p>`bar phi((a,b)(c,d)``) = phi((ac,bd)``)`` = phi(ac)phi(bd)^-1 = phi(a)phi(c)phi(b)^-1phi(d)^-1`</p></li>
                <li><p>`= (phi(a)phi(b)^-1)(phi(c)phi(d)^-1) = bar phi((a,b)``) bar phi((c,d)``)`</p></li>
                <li><p>`a != 0, bar phi((a,a)``)`` = phi(a)phi(a)^-1 = 1 => bar phi` is a unital ring homomorphism</p></li>
                <li><p>`bar phi((a,b)``)`` = 0 => phi(a)phi(b)^-1 = 0 => phi(a) = 0 => a = 0 => bar phi` is injective</p></li>
              </div>
              <li><p>Suppose `F` is a field of characteristic `0`. What is the prime subfield of `F`?</p></li>
              <li><p>We've seen that we have an injective unital ring homomorphism `varepsilon_F: ZZ -> F`</p></li>
              <li><p>By the proposition, `EE!` `phi: Q(ZZ) ~= QQ -> F =>` the prime subfield of `F` when `char(F) = 0` is `QQ`</p></li>
              <li><p>Every field either contains `QQ` or `ZZ // pZZ` for some prime `p`</p></li>
            </ul>
          </div>
          <div class="content" id="polynomial_rings">
            <h3>Polynomial Rings</h3>
            <ul>
              <li><p><b>Definition: Let `R` be a commutative ring. The polynomial ring `R[x]` of polynomials over `R` in the indeterminate `x` is defined to be the ring consisting of all expressions of the form `sum_(i=0)^n a_ix^i = a_nx^n + a_(n-1)x^(n-1) + ... + a_1x + a_0`, `a_i in R, n in ZZ^(>= 0)`</b></p></li>
              <li><p>We can always write an element of `R[x]` as `sum_(i=0)^n a_ix^i` where `a_n != 0`</p></li>
              <li><p>If we have two polynomials `sum_(i = 0)^n a_ix^i, sum_(j = 0)^m b_jx^j` written in this form then `sum_(i = 0)^n a_ix^i = sum_(j = 0)^m b_jx^j <=> n = m` and `a_k = b_k` `AA 1 <= k <= n`</p></li>
              <li><p>Note: `x` and `x^2` take on the same values at all elements of `ZZ // 2ZZ` but `x != x^2` as elements of `ZZ // 2ZZ [x]`</p></li>
              <li><p>Addition and multiplication are defined exactly as how they were in grade school, except if the coefficient ring `R` has `char(R) = n`, then we have to reduce `mod n`</p></li>
              <li><p>`(3x^2 + 2x + 1) + (x + 4) = 3x^2 + 3x + 5`</p></li>
              <li><p>`= 3x^2 + 3x + 0` if in `[ZZ]_5`</p></li>
              <li><p><b>Definition: Let `f(x) = sum_(i = 0)^n a_ix^i in R[x]`. If `a_n != 0`, then the <u>degree</u> of `f`, denoted by `deg(f(x))`, is `n`. The <u>leading term</u> is `a_n`. If `a_n = 1`, then `f(x)` is said to be <u>monic</u>. If `f(x) = r in R`, then `f(x)` is <u>constant</u>. `R` is called the <u>coefficient ring</u>.</b></p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is an integral domain, then `R[x]` is an integral domain</b></p></li>
                <li><p>Let `sum_(i = 0)^n a_ix^i, sum_(j = 0)^m b_jx^j in R[x]` be nonzero elements `s.t.` the leading terms are `a_n, b_m != 0`</p></li>
                <li><p>Then the product has leading term `a_nb_m`</p></li>
                <li><p>`a_nb_m != 0` since `R` is a domain and `a_n, b_m != 0`</p></li>
                <li><p>Therefore, the product is nonzero</p></li>
              </div>
              <li><p>For a unital commutative ring `R`, if every ideal of `R` is finitely generated `<=>` every ideal of `R[x]` is finitely generated</p></li>
              <li><p>Degree adds under taking products in `R[x]` when `R` is a domain</p></li>
              <li><p>`ZZ // 4ZZ: f(x) = [2]_4x + [1]_4, g(x) = [2]_4x^2 + [2]_4x`</p></li>
              <li style="list-style-type: none"><p>`f(x)g(x) = [4]_4x^3 + [4]_4x^2 + [2]_4x^2 + [2]_4x = [2]_4x^2 + [2]_4x`</p></li>
              <li style="list-style-type: none"><p>`deg(fg) != deg(f)deg(g)`</p></li>
              <li><p>Unexpected things happen in `R[x]` when `R` is not a domain</p></li>
              <li><p>However, when `F` is a field, none of this occurs</p></li>
              <li><p>Even better, we have a division algorithm in `F[x]` like the one in `ZZ`</p></li>
              <li><p>We can order collections of elements in `F[x]` by their degrees</p></li>
              <li><p>In `ZZ`: If `a in ZZ, b != 0 in ZZ`, then `EE q, r in ZZ` `s.t.` `a = bq + r` `0 <= r < |b|`</p></li>
              <div class="proof">
                <li><p><b>Division Algorithm in `F[x]`: Let `F` be a field. Let `f(x) in F[x]`. Let `g(x) != 0 in F[x]`. Then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where either `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</b></p></li>
                <li><p>First we prove existence</p></li>
                <li><p>If `f(x) = 0`, take `q(x) = 0` and `r(x) = 0`</p></li>
                <li><p>If `deg(g(x)) > deg(f(x))`, let `q(x) = 0, r(x) = f(x)`</p></li>
                <li><p>`f(x) = g(x)*0 + f(x), 0 <= deg(r(x)) = deg(f(x)) < deg(g(x))`</p></li>
                <li><p>We've reduced to the case where `deg(f(x)) >= deg(g(x))`</p></li>
                <li><p>We induct on `deg(f(x)) = n`</p></li>
                <li><p>Base Case: `n = 0`. In this case `f(x)` is constant, and since `deg(g(x)) <= deg(f(x)) = 0 => deg(g(x)) = 0 => g(x)` is a constant</p></li>
                <li><p>`f(x)` is constant `=> f(x) = a in F \\ {0}`</p></li>
                <li><p>`g(x)` is constant `=> g(x) = b in F \\ {0}`</p></li>
                <li><p>`a = b*(a/b)`. Let `q(x) = a/b`. Let `r(x) = 0`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `n >= 0, k <=n` `AA k in ZZ^(>= 0).` If `f(x)` is a polynomial of degree `k`, then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</p></li>
                <li><p>WTS: If `f(x)` is a polynomial of degree `n+1` in `F[x]`, then `EE q(x), r(x)` `s.t.` `f(x) = g(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(g(x))` or `r(x) = 0`</p></li>
                <li><p>Let `a_n` be the leading term of `f(x)`, `b_m` be the leading term of `g(x)`</p></li>
                <li><p>The leading monomial of `f(x)` is `a_nx^n` and the leading monomial of `g(x)` is `b_mx^m`, `m <= n`</p></li>
                <li><p>Consider `f(x) - a_nb_m^-1x^(n-m)g(x)`. This has degree `< deg(f(x)) = n+1`</p></li>
                <li><p>So the inductive hypothesis applies to `f(x) - a_nb_m^-1x^(n-m)g(x)`</p></li>
                <li><p>`EE q_1(x), r_1(x) in F[x]` `s.t.` `(f(x) - a_nb_m^-1x^(n-m)g(x)) = g(x)q_1(x) + r_1(x)` where `0 <= deg(r_1(x)) < deg(g(x))` or `r_1(x) = 0`</p></li>
                <li><p>Rearranging this, we find `f(x) = g(x)(a_nb_m^-1x^(n-m) + q_1(x)) + r_1(x)` where `0 <= deg(r_1(x)) < deg(g(x))` or `r_1(x) = 0`</p></li>
                <li><p>Now we prove uniqueness</p></li>
                <li><p>Suppose `f(x) = g(x)q_1(x) + r_1(x) = g(x)q_2(x) + r_2(x)`</p></li>
                <li><p>`g(x)q_1(x) + r_1(x) - g(x)q_2(x) - r_2(x) = 0`</p></li>
                <li><p>`g(x)(q_1(x) - q_2(x)) = (r_2(x) - r_1(x)) => g(x) | (r_2(x) - r_1(x))`</p></li>
                <li><p>`deg(r_2(x) - r_1(x)) <= max{deg(r_1(x)), deg(r_2(x))} < deg(g(x))`</p></li>
                <li><p>If `r_2(x) - r_1(x) != 0`, then that is a contradiction</p></li>
                <li style="list-style-type: none"><p>`deg(g(x)) > deg(f(x))`</p></li>
                <li style="list-style-type: none"><p>If `g(x) | f(x) => EE q(x) in F[x]` `s.t.` `g(x)q(x) = f(x)`</p></li>
                <li style="list-style-type: none"><p>`deg(g(x)) + deg(q(x))` (which is `>= 0`) `= deg(f(x)) < deg(g(x))`, a contradiction</p></li>
                <li><p>So we must have `r_1(x)- r_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is an integral domain, we see that `q_1(x) = q_2(x)`</p></li>
              </div>
              <li><p>If `R` is an integral domain, then we can make sense of `f(x) | g(x).` This means that `EE q(x) in R[x]` `s.t.` `f(x)q(x) = g(x)`</p></li>
              <li><p>`f(x)` is called a <u>factor</u> of `g(x)`. `a in R` is called the <u>root</u> of `f(x)` if `f(a) = 0`</p></li>
              <li><p>Let `a in R`. Then `a` is called a zero of multiplicity `n` of `f(x)` if `(x-a)^n | f(x)` and `(x-a)^(n+1) cancel(|) f(x)`</p></li>
              <div class="proof">
                <li><p><b>Exercise: Show that if `R` is an integral domain, the only units of `R[x]` are the units of `R`</b></p></li>
                <li><p>Suppose `f(x) != 0` is a unit in `R[x]`. Then there exists `g(x) != 0` in `R[x]` `s.t.` `f(x)g(x) = 1`</p></li>
                <li><p>`deg(f(x)g(x)) = deg(f(x)) + deg(g(x)) = deg(1) = 0`</p></li>
                <li><p>`=> deg(f(x)) = 0 => f(x) in R`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: A polynomial of degree `n` over a field `F` has at most `n` roots in `F`</b></p></li>
                <li><p>Base Case: If `n = 0`, then `f(x) in F \\ {0}`, so it has `0` roots</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `n >= 0, k <= n` `AA k in ZZ^(>= 0)` If `f(x)` is a polynomial of degree `k`, then `f(x)` has at most `k` roots in `F`</p></li>
                <li><p>WTS: If `f(x)` is a polynomial of degree `n+1`, then `f(x)` has at most `n+1` roots in `F`</p></li>
                <li><p>Let `f(x)` be a polynomial of degree `n+1`. If `f(x)` has no roots in `F`, then the statement is proven</p></li>
                <li><p>Therefore we can assume `f(x)` has a root, call it `alpha in F`</p></li>
                <li><p>Let `h` be the multiplicity of `alpha`. We can write `f(x) = (x-alpha)^hq(x)` where `(x-alpha) cancel(|) q(x)`</p></li>
                <li><p>If `alpha` is the only root, then `h <= n + 1` and the statement is proven</p></li>
                <li><p>Suppose that `beta` is a root of `f(x), beta != alpha`</p></li>
                <li><p>`0 = f(beta) = (beta - alpha)^hq(beta) => q(beta) = 0`</p></li>
                <li><p>Therefore, `beta` is a root of `q(x)`</p></li>
                <li><p>We claim that the multiplicity of `beta` as a root of `q(x)` is equal to the multiplicity of `beta` as a root of `f(x)`</p></li>
                <li><p>Since `beta` is a root of `q(x) => (x - beta) | q(x)`</p></li>
                <li><p>Let `m_1` be the multiplicity of `beta` as a root of `q(x)` (So `(x-beta)^(m_1) | q(x)` and `(x - beta)^(m_1+1) cancel(|) q(x)`)</p></li>
                <li><p>Since `beta` is a root of `f(x)`, we can write `f(x) = (x - beta)^(m_2)q_2(x)`</p></li>
                <li><p>`m_2`: the multiplicity of `beta` as a root of `f(x)`</p></li>
                <li><p>`q(x) = (x - beta)^(m_1)q_1(x)`</p></li>
                <li><p>Notice `f(x) = (x - alpha)^nq(x) = (x - alpha)^h(x - beta)^(m_1)q_1(x)`</p></li>
                <li><p>`f(x) = (x - beta)^(m_2)q_2(x)`. We claim `m_1 = m_2`</p></li>
                <li><p>Case 1: `m_1 > m_2`. `(x - alpha)^h(x - beta)^(m_1)q_1(x) - (x - beta)^(m_2)q_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is a domain, `(x - alpha)^h(x - beta)^(m_2 - m_1)q_1(x) - q_2(x) = 0`</p></li>
                <li><p>Plugging in `beta` gives `q_2(beta) = 0`, which is a contradiction</p></li>
                <li><p>Case 2: `m_1 < m_2`. (x - alpha)^h(x - beta)^(m_1)q(x) = (x - beta)^(m_2)q_2(x)`</p></li>
                <li><p>`(x - alpha)^h(x- beta)^(m_1)q_1(x) - (x - beta)^(m_2)q_2(x) = 0`</p></li>
                <li><p>Since `F[x]` is a domain, `(x - alpha)^hq_1(x) - (x - beta)^(m_2 - m_1)q_2(x) = 0`</p></li>
                <li><p>Plugging in `beta => q_1(beta) = 0`, which is a contradiction</p></li>
                <li><p>Therefore, `m_1 = m_2`</p></li>
                <li><p>By the induction hypothesis, since `deg(q(x)) < deg(f(x)) = n + 1, q(x)` has at most `deg(q(x)) = n + 1 - h` roots counted with multiplicity</p></li>
                <li><p>Since the remaining roots of `f(x)` are exactly the roots of `q(x)` with the same multiplicity, since `f(x) = (x - alpha)^hq(x)` we see that `f(x)` has at most `h + deg(q(x)) = h + n + 1 - h = n + 1` roots in `F`</p></li>
              </div>
              <li><p>Why "at most"? Ex: `x^2 + 1 in RR[x]` has no roots</p></li>
              <div class="proof">
                <li><p><b>Theorem: `F[x]` is a principal ideal domain</b></p></li>
                <li><p>Let `I` be a nonzero proper ideal of `F[x]`. Let `f(x) != 0` be an element of minimal degree in `I`</p></li>
                <li><p>Since `I` is proper, the degree of `f(x)` must be positive</p></li>
                <li style="list-style-type: none"><p>(If `deg(f(x)) = 0 => f(x) in F \\ {0} => f(x)` is a unit in `I => I = F[x]`)</p></li>
                <li><p>Let `g(x) in I`. By the division algorithm, `EE q(x), r(x) in F[x]` `s.t` `g(x) = f(x)q(x) + r(x)` where `0 <= deg(r(x)) < deg(f(x))` or `r(x) = 0`</p></li>
                <li><p>We can rewrite this as `r(x) = g(x) - f(x)q(x) in I`</p></li>
                <li><p>Since `F` was chosen to have minimal degree, `r(x) = 0 => I sube (f(x))`</p></li>
                <li><p>Since `f(x) in I => (f(x)) sube I => (f(x)) = I`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Exercise: Let `R` be a commutative ring with unity. Let `I sube R` be an ideal. Show that `I[x]` = the set of polynomials in `R[x]` whose coefficients lie in `I` is an ideal of `R[x]`</b></p></li>
                <li><p>We must show that `I[x]` is a subgroup. Let `f(x) = sum_(i = 0)^n a_ix^i, g(x) = sum_(j = 0)^m b_jx^j in I[x]`</p></li>
                <li><p>WLOG, `n >= m`</p></li>
                <li><p>`f(x) - g(x) = sum_(k = 0)^n c_kx^k` where `c_k = {(a_k - b_k if k <= m), (a_k if m < k <= n):}`</p></li>
                <li><p>`a_k - b_k in I` since `a_k, b_k in I` and `I` is an ideal (for `0 <= k <= m`)</p></li>
                <li><p>`a_k in I` if `m < k <= n =>` By definition, `f(x) - g(x) in I[x]`</k></p></li>
                <li><p>It suffices to show that `AA` monomials `r_hx^h in R[x]`, `AA f(x) in I[x], r_hx^h - f(x) in I[x]`</p></li>
                <li><p>Let `f(x) = sum_(i = 0)^n a_ix^i`. Then `r_hx^h(sum_(i = 0)^n a_ix^i) = sum_(j = h)^(n+1) r_ha_j - hx^j in I[x]`</p></li>
                <li><p>Let `sum_(k = 0)^m r_kx^k in R[x], f(x) in I[x]`</p></li>
                <li><p>Then `sum_(k = 0)^m r_kx^k*f(x) = sum_(k = 0)^m (r_kx^kf(x)) in I[x]`</p></li>
                <li><p>Since `I[x]` is a subgroup `=> sum_(k = 0)^m r_kx^kf(x) in I[x]`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Ex: If `p` is a prime ideal in `R`, then `p[x]` is a prime ideal in `R[x]`</b></p></li>
                <li><p>We show that `R[x] // p[x]` is an integral domain</p></li>
                <li><p>To do this, we exhibit an isomorphism `R[x] // p[x] ~= R // p [x]`</p></li>
                <li><p>`pi_p: R -> R // p`</p></li>
                <li><p>There is a map of rings `bar pi_p: R[x] -> R // p [x], sum_(i = 0)^n a_ix^i |-> sum_(i = 0)^n pi_p(a_i)x^i`</p></li>
                <li><p>(Surjective): Fix `sum_(j = 0)^m (b_i + p)x^i in R // p [x]`</p></li>
                <li><p>Notice `bar pi_p(sum_(j = 0)^m b_jx^j) = sum_(j = 0)^m pi_p(b_j)x^j = sum_(j=  0)^m (b_j + p)x^j`</p></li>
                <li><p>`bar pi` is onto `R[x] -> R // p [x]`</p></li>
                <li><p>We claim `ker(bar pi_p) = p[x]`</p></li>
                <li><p>`(sube)` Let `sum_(i = 0)^n a_ix^i in ker(bar pi_p) => bar pi_p(sum_(i = 0)^n a_ix^i) = sum_(i = 0)^n pi_p(a_i)x^i = 0`</p></li>
                <li><p>`=> pi_p(a_i) = 0` `AA i`</p></li>
                <li><p>`a_i + p = 0 + p => a_i in p` `AA i =>` since all `a_i in p => sum_(i = 0)^n a_ix^i in p[x]`</p></li>
                <li><p>`(supe)` Suppose `sum_(i = 0)^m c_ix^i in p[x] => c_i in p` `AA i`</p></li>
                <li><p>`bar pi_p(sum_(i = 0)^m c_ix^i) = sum_(i = 0)^m pi_p(c_i)x^i = sum_(i = 0)^m (c_i + p)x^i = sum_(i = 0)^m (0 + p)x^i = 0`</p></li>
                <li><p>`=> sum_(i = 0)^m c_ix^i in ker(bar pi_p)`</p></li>
                <li><p>Since `bar pi_p: R[x] -> R // p [x]` is surjective and `ker(bar pi_p) = p[x]`, by the First Isomorphism Theorem, `R[x] // p[x] ~= R // p [x]`</p></li>
                <li><p>`R // p [x]` is a domain `<=> R[x] // p[x]` is a domain `<=> p[x]` is prime</p></li>
              </div>
              <div class="proof">
                <li><p><b>However, if `m` is a maximal ideal of `R`, `m[x]` need not be a maximal ideal of `R[x]`</b></p></li>
                <li><p>Let `R = ZZ, m = pZZ`, `p` prime</p></li>
                <li><p>Then `ZZ[x] // pZZ[x] ~= ZZ // pZZ [x]`</p></li>
                <li><p>We know that `ZZ // pZZ [x]` is not a field `<=> pZZ[x]` is not maximal</p></li>
              </div>
              <li><p>What is the right generalization of a prime number in `F[x]`?</p></li>
              <li><p>`p in ZZ` is prime `<=>` whenever `p = ab, a = +- p, b = +- p` or vice versa</p></li>
              <li><p><b>Definition: Let `R` be an integral domain. Let `f(x) in R[x]` which is nonzero and not a unit. `f(x)` is <u>irreducible</u> if whenever `f(x) = g(x)h(x)` for some `g(x), h(x) in R[x]`, either `g(x)` or `h(x)` must be a unit. If an element is not a unit, nonzero, and not irreducible, it is <u>reducible</u></b></p></li>
              <li><p>Re-examining the definition of irreducible polynomials, since `R` is a domain, the units of `R[x]` are the units of `R` itself, so we can rephrase the definition as:</p></li>
              <li><p><b>`f(x)` is irreducible if whenever `f(x) = g(x)h(x)` for some `g(x), h(x) in R[x]` we must have `g(x)` or `h(x)` is a unit in `R`</b></p></li>
              <li><p>When `R` is a field, we can say even more</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `F` be a field. Then an element `f(x) in F[x]` (nonzero, non-unit) is irreducible if and only if we cannot express `f(x)` as a product of two polynomials whose degrees are `< deg(f(x))`</b></p></li>
                <li><p>`(=>)` Suppose that `f(x)` is irreducible. Suppose for a contradiction that `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`</p></li>
                <li><p>Since `f(x)` is irreducible, one of `g(x)` or `h(x)` must be a unit in `F`</p></li>
                <li><p>If `g(x) in F^x`, then `deg(g(x)) = 0`</p></li>
                <li><p>`f(x) = g(x)h(x) => deg(f(x)) = cancel(deg(g(x))) + deg(h(x)) => deg(f(x)) = deg(h(x))`, which is a contradiction</p></li>
                <li><p>`(lArr)` Suppose that `f(x)` is such that `f(x)` cannot be factored as a product `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`</p></li>
                <li><p>We claim that `f` is irreducible</p></li>
                <li><p>Suppose `f(x) = p(x)q(x)`</p></li>
                <li><p>By assumption, either `deg(p(x)) = deg(f(x))` or `deg(q(x)) = deg(f(x))`</p></li>
                <li><p>In the first case, `deg(q(x)) = 0 <=> q(x) in F^x`</p></li>
                <li><p>In the second case, `deg(p(x)) = 0 <=> p(x) in F^x`</p></li>
                <li><p>Therefore, `f` is irreducible</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a principal ideal domain, then every prime ideal is maximal</b></p></li>
                <li><p>`(lArr)` maximal ideals are always prime in integral domains</p></li>
                <li><p>`(=>)` Suppose that `p` is a prime ideal. Let `p in I` where `I` is an ideal</p></li>
                <li><p>We claim that `I = p` or `I = R`</p></li>
                <li><p>Since `R` is a principal ideal domain, `EE x, z in R` `s.t.` `(x) = p, (z) = I, (x) sube (z)` where `(x)` is prime</p></li>
                <li><p>Since `(x) sube (z), EE y in R` `s.t.` `x = yz => yz in (x)`</p></li>
                <li><p>Since `(x)` is a prime ideal, either `y in (x)` or `z in (x)`</p></li>
                <li><p>If `y in (x) => EE r in R` `s.t.` `y = rx`</p></li>
                <li><p>Then `x = yz = rxz = (rz)x`</p></li>
                <li><p>Since `R` is a domain `=> rz = 1 => z in R^x => (z) = R`</p></li>
                <li><p>If `z in (x)`, then `(z) sube (x)` and therefore `(z) = (x)`</p></li>
                <li><p>`=> p = (x)` is maximal</p></li>
              </div>
              <li><p>Since `F(x)` is a principal ideal domain, to show that irreducible polynomials generate maximal ideals, it suffices to show that irreducible polynomials generate prime ideals</p></li>
              <li><p>To do this, we must establish some properties of irreducible polynomials</p></li>
              <li><p>The property we want is: If `f(x)` is irreducible, then `f(x) | g(x)h(x) => f(x)|g(x)` or `f(x)|h(x)`</p></li>
              <li><p><b>Definition: Let `f(x), g(x) in F[x]`. A polynomial `h(x)` is a <u>greatest common divisor</u> of `f(x)` and `g(x)` if</b></p></li>
              <li style="list-style-type: none"><p><b>1) `h(x) | f(x)` and `h(x) | g(x)`</b></p></li>
              <li style="list-style-type: none"><p><b>2) If `q(x)` is any other common divisor of `f(x)` and `g(x)`, then `q(x) | h(x)`</b></p></li>
              <li><p>We used "a" and not "the" because if `h(x)` satisfies these conditions, so does `c*h(x)` `AA c in F^x`</p></li>
              <li><p>Suppose `h_1(x), h_2(x)` both satisfy these conditions.</p></li>
              <li><p>Then `h_1(x) | h_2(x) => EE p_1(x) in F[x]` `s.t.` `h_1(x)p_1(x) = h_2(x)`</p></li>
              <li><p>And `h_2(x) | h_1(x) => EE p_2(x) in F[x]` `s.t.` `h_2(x)p_2(x) = h_1(x)`</p></li>
              <li><p>`h_2(x) = h_1(x)p_1(x) = h_2(x)p_2(x)p_1(x)`</p></li>
              <li><p>Since `F[x]` is a domain, `p_2(x)p_1(x) = 1 => p_2(x), p_1(x) in F^x`</p></li>
              <li><p>From now on, "the greatest common divisor" means the <b>unique</b> polynomial `h(x)` satisfying these conditions of the definition which is <b>monic</b></p></li>
              <div class="proof">
                <li><p><b>The greatest common divisor of `f(x)` and `g(x)` is the monic generator of `(f(x), g(x))`</b></p></li>
                <li><p>Let `f(x), g(x) in F[x]` `s.t.` at least one of them is nonzero</p></li>
                <li><p>Consider `(f(x), g(x)) sube F[x]`</p></li>
                <li><p>Since `F[x]` is a principal ideal domain, `(f(x), g(x))` is generated by a single element</p></li>
                <li><p>Let `h(x)` be the monic generator of `(f(x), g(x))`</p></li>
                <li><p>Notice that since `f(x), g(x) in (h(x)) => h(x)|f(x), h(x)|g(x)`</p></li>
                <li><p>Since `h(x) in (f(x), g(x)) => EE r(x), s(x) in F[x]` `s.t.` `h(x) = r(x)f(x) + s(x)g(x)`</p></li>
                <li><p>Let `q(x)` be a common divisor of `f(x)` and `g(x)`</p></li>
                <li><p>Then `EE p_1(x), p_2(x) in F[x]` `s.t.` `q(x)p_1(x) = f(x), q(x)p_2(x) = g(x)`</p></li>
                <li><p>Substituting, we find `h(x) = r(x)q(x)p_1(x) + s(x)q(x)p_2(x) => q(x)|h(x)`</p></li>
                <li><p>Therefore, `h(x)` is the gcd of `f(x)` and `g(x)`</p></li>
              </div>
              <li id="gcd_lin_comb"><p>We've shown that `gcd(f(x), g(x))` can be written as an `F[x]` linear combination of `f(x)` and `g(x)`</p></li>
              <div id="f_irreducible" class="proof">
                <li><p><b>Proposition: Suppose that `f(x)` is irreducible in `F[x]`. Then `f(x)|g(x)h(x) => f(x)|g(x)` or `f(x)|h(x)`, `AA g(x), h(x) in F[x]`</b></p></li>
                <li><p>Suppose that `f(x)` is irreducible and `f(x) cancel(|) g(x)`. We claim `f(x)|h(x)`</p></li>
                <li><p>First we show `gcd(f(x), g(x)) = 1`</p></li>
                <li><p>Suppose `q(x)|f(x)` and `q(x)|g(x)`</p></li>
                <li><p>If `q(x)|f(x)` then since `f(x)` is irreducible, `q(x) = c*f(x)` for some unit `c in F^x`, or `q(x) in F^x`</p></li>
                <li><p>If `q(x) = c*f(x)` and `q(x)|g(x)`, then `c*f(x)|g(x) => f(x)|g(x)`, which is a contradiction</p></li>
                <li><p>`=> q(x) in F^x`</p></li>
                <li><p>Therefore, `gcd(f(x), g(x)) = 1`</p></li>
                <li><p><a href="#gcd_lin_comb">By what we just proved</a>, `EE r(x), s(x) in F[x]` `s.t.` `1 = r(x)f(x) + s(x)g(x)`</p></li>
                <li><p>Since `f(x)|g(x)h(x) => EE q'(x) in F[x]` `s.t.` `f(x)q'(x) = g(x)h(x)`</p></li>
                <li><p>`f(x)q'(x)*1 = f(x)q'(x)*(r(x)f(x) + s(x)g(x)) = g(x)h(x)`</p></li>
                <li><p>`g(x)h(x) = f(x)q'(x)r(x)f(x) + f(x)q'(x)s(x)g(x)`</p></li>
                <li><p>`= g(x)h(x)r(x)f(x) + f(x)q'(x)s(x)g(x)`</p></li>
                <li><p>`=> h(x) = f(x)*(h(x)r(x) + q'(x)s(x)) => f(x)|h(x)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: If `f(x) in F[x]` is irreducible, then `(f(x))` is prime</b></p></li>
                <li><p>Let `g(x), h(x) in F[x]` `s.t.` `g(x)h(x) in (f(x)) => f(x)|g(x)h(x)`</p></li>
                <li><p><a href="#f_irreducible">By what we just showed</a>, `f(x)` is irreducible implies `f(x)|g(x)h(x) => f(x)|g(x)` `(g(x) in (f(x)))` or `f(x)|h(x)` `(h(x) in (f(x))`</p></li>
              </div>
              <li><p>We care about irreducible polynomials because they generate the maximal ideals of `F[x]`</p></li>
              <div class="proof">
                <li><p>We just have to show that having the property `f(x)|g(x)h(x) => f(x)|g(x)` or `f(x)|h(x)` is equivalent to being irreducible</p></li>
                <li><p>Suppose `f(x) in F[x]` `s.t.` whenever `g(x), h(x) in F[x]` `s.t.` `f(x)|g(x)h(x) => f(x)|g(x)` or `f(x)|h(x)`</p></li>
                <li><p>We claim `f(x)` is irreducible</p></li>
                <li><p>Suppose `f(x) = p(x)q(x)`. We claim that either `p(x) in F^x` or `q(x) in F^x`</p></li>
                <li><p>Since `f(x)*1 = p(x)q(x) => f(x)|p(x)q(x)`</p></li>
                <li><p>By assumption, `f(x)|p(x)` or `f(x)|q(x)`</p></li>
                <li><p>`f(x)|p(x) => EE p'(x) in F[x]` `s.t.` `f(x)p'(x) = p(x)`</p></li>
                <li><p>`f(x) = f(x)p'(x)q(x) => q(x) in F^x`</p></li>
                <li><p>`f(x)|q(x) => EE q'(x) in F[x]` `s.t.` `f(x)q'(x) = q(x)`</p></li>
                <li><p>`f(x) = f(x)p(x)q'(x) => p(x) in F^x`</p></li>
              </div>
              <li id="f_maximal"><p>Every maximal ideal is of the form `(f(x))` where `f(x)` is irreducible `// F`</p></li>
              <li><p>There are conditions that imply irreducibility or reducibility</p></li>
              <li><p>The first condition applies to any field, but only to degree `2` or degree `3` polynomials</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `F` be a field. `f(x) in F[x]` is irreducible `// F <=> f(x)` has no roots</b></p></li>
                <li><p>`(=>)` Suppose `f(x)` is irreducible. Then since `cancel(EE)` a factorization `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`, `f` has no linear factors `<=> f(x)` has no roots in `F`</p></li>
                <li><p>`(lArr)` Suppose `f(x)` has no roots in `F <=> f(x)` has no linear factors</p></li>
                <li><p>Suppose `deg(f(x)) = 2`</p></li>
                <li><p>Suppose for a contradiction that `f(x)` is reducible `=> EE g(x), h(x) in F[x]` `s.t.` `f(x) = g(x)h(x) in F[x]` where `deg(g(x)), deg(h(x)) < 2`</p></li>
                <li><p>`=> deg(g(x)) = deg(h(x)) = 1`, which is a contradiction*</p></li>
                <li><p>Suppose `deg(f(x)) = 3`</p></li>
                <li><p>Suppose for a contradiction that `f(x)` is reducible `=> EE g(x), h(x) in F[x]` `s.t.` `f(x) = g(x)h(x) in F[x]` where `deg(g(x)), deg(h(x)) < 3`</p></li>
                <li><p>`=>` either `deg(g(x)) = 2` and `deg(h(x)) = 1`, which is a contradiction*, or vice versa, which is also a contradiction*</p></li>
                <li><p>*contradiction because `f(x)` has no linear factors</p></li>
              </div>
              <li><p><b>Definition: Let `f(x) in ZZ[x]`. The <u>content</u> of `f(x)` is the greatest common divisor of the coefficients of `f(x)`. If the content is `1`, then `f(x)` is <u>primitive</u></b></p></li>
              <li><p>Ex: Monic polynomials are primitive</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `f(x), g(x)` are primitive, then `f(x)g(x)` is primitive</b></p></li>
                <li><p>We prove the contrapositive. Suppose `f(x), g(x) in ZZ[x]` `s.t.` `f(x)g(x)` is not primitive</p></li>
                <li><p>Then `EE p in ZZ^+` prime such that `p|content(f(x)g(x)) => EE q(x) in ZZ[x]` `s.t.` `f(x)g(x) = p(q(x)) in pZZ[x]`</p></li>
                <li><p><a href="#prime_ideal">We've already seen that `pZZ` is a prime ideal of `ZZ[x]`</a></p></li>
                <li><p>Thus `f(x)g(x) in pZZ[z] => f(x) in pZZ[x]` or `g(x) in pZZ[x]`</p></li>
                <li><p>`=> p|content(f(x))` or `p|content(g(x)) =>` either `f(x)` or `g(x)` is not primitive</p></li>
              </div>
              <div class="proof">
                <li><p><b>Gauss's Lemma: If `f(x) in ZZ[x]` is reducible over `QQ`, then `f(x)` is reducible over `ZZ`</b></p></li>
                <li><p>Suppose that `f(x)` is reducible over `QQ`</p></li>
                <li><p>Then `EE g(x), h(x) in QQ[x]` `s.t.` `f(x) = g(x)h(x)`</p></li>
                <li><p>We can harmlessly divide through by the content of `f(x)` to assume that `f(x)` is primitive</p></li>
                <li><p>Let `alpha` be the least common multiple of the denominators in `g(x)`. Let `beta` be the least common  multiple of the denominators in `h(x)`</p></li>
                <li><p>Thus, `alpha*g(x) in ZZ[x], beta*h(x) in ZZ[x]`</p></li>
                <li><p>So we have a factorization `alpha beta f(x) = alpha g(x) * beta h(x) in ZZ[x]`</p></li>
                <li><p>Notice that the content of `alpha beta f(x)` is `alpha beta`</p></li>
                <li><p>Let `c_g` be the content of `alpha g(x)`, `c_h` be the content of `beta h(x)`</p></li>
                <li><p>Notice that `(alpha g(x)) / c_g` and `(beta h(x)) / c_h` are primitive</p></li>
                <li><p>We can write `alpha beta f(x) = c_(g) ((alpha g(x)) / c_g) * c_h ((beta h(x)) / c_h)`</p></li>
                <li><p>Since `(alpha g(x)) / c_g, (beta h(x)) / c_h` are primitive, the content of the right side is `c_g*c_h`</p></li>
                <li><p>The content of the left side is `alpha beta => alpha beta = c_gc_h`</p></li>
                <li><p>Therefore `(alpha beta)/(c_gc_h) f(x) = f(x) = (alpha g(x)) / c_g * (beta h(x)) / c_h` where `(alpha g(x)) / c_g, (beta h(x)) / c_h in ZZ[x]`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: Suppose that `f(x) in ZZ[x]` `s.t.` `deg(f(x)) >= 1`. Let `p` be a prime number. Let `bar pi_p: ZZ[x] -> ZZ // pZZ[x]` be the ring homomorphism which reduces coefficients modulo `p`. If `bar pi_p(f(x))` is irreducible over `ZZ // pZZ` and `deg(bar pi_p(f(x))) = deg(f(x))`, then `f(x)` is irreducible over `QQ`</b></p></li>
                <li><p>Let `f(x) in ZZ[x]` and let `p` be a prime number `s.t.` `bar pi_p(f(x))` is irreducible and `deg(bar pi_p(f(x))) = deg(f(x))`</p></li>
                <li><p>Suppose for a contradiction that `f` is reducible over `QQ`</p></li>
                <li><p>`=> EE g(x), h(x) in QQ[x]` `s.t.` `f(x) = g(x)h(x)` where `deg(g(x)), deg(h(x)) < deg(f(x))`</p></li>
                <li><p>Divide through by `content(f)`. Then if `alpha` is the `lcm` of the denominators of `g(x)` and `beta` is the `lcm` of the denominators of `h(x)`, then `alpha g(x), beta h(x) in ZZ[x]`</p></li>
                <li><p>Let `c_g, c_h` denote the content of `alpha g(x), beta h(x)`</p></li>
                <li><p>Then `f(x) = (alpha g(x)) / c_g * (beta h(x)) / c_h`</p></li>
                <li><p>Notice that `deg((alpha g(x)) / c_g) = deg(g(x))` and `deg((beta h(x)) / c_h) = deg(h(x))`</p></li>
                <li><p>Reducing `mod p`, we see that `bar pi_p(f(x)) = bar pi_p((alpha g(x)) / c_g) bar pi_p((beta h(x)) / c_h)`</p></li>
                <li><p>By assumption, `bar pi_p(f(x))` is irreducible `=>` either `deg(bar pi_p((alpha g(x)) / c_g)) = 0` or `deg(bar pi_p((beta h(x)) / c_h)) = 0`</p></li>
                <li><p>`=> deg(bar pi_p((beta h(x)) / c_h)) = deg(bar pi_p(f(x)))` or `deg(bar pi_p((alpha g(x)) / c_g))) = deg(bar pi_p(f(x)))`</p></li>
                <li><p>Since we assumed `deg(bar pi_p(f(x))) = deg(f(x))`, either `deg(bar pi_p((beta h(x)) / c_h)) = deg(f(x))` or `deg(bar pi_p((alpha g(x)) / c_g)) = deg(f(x))`</p></li>
                <li><p>Since degree only drops or stays the same when reducing `mod p`,</p></li>
                <li><p>1) `deg(h(x)) >= deg(bar pi_p((beta h(x)) / c_h)) = deg(f(x))`, which is a contradiction</p></li>
                <li><p>2) `deg(g(x)) >= deg(bar pi_p((alpha g(x)) / c_g)) = deg(f(x))`, which is a contradiction</p></li>
                <li><p>Therefore, `f` is irreducible over `QQ`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Eisenstein's Criterion: Let `f(x) = sum_(i = 0)^n a_ix^i`. Let `p` be a prime number. Suppose that `p cancel(|) a_n`, `p|a_i AA 0 <= i <= n-1`, and `p^2 cancel(|) a_0`. Then `f` is irreducible `// QQ`</b></p></li>
                <li><p>Suppose `f(x) in ZZ[x]` and `p` is a prime `s.t.` `p cancel(|) a_n`, `p|a_i AA 0 <= i <= n-1`, `p^2 cancel(|) a_0`</p></li>
                <li><p>Suppose `f` is reducible over `QQ => EE g(x), h(x) in ZZ[x]` `s.t.` `deg(g(x), h(x)) < deg(f(x))` `s.t.` `f(x) = g(x)h(x)`</p></li>
                <li><p>Therefore, both have positive degree</p></li>
                <li><p>Let `g(x) = sum_(j = 0)^r b_jx_j, h(x) = sum_(k = 0)^s c_kx^k`</p></li>
                <li><p>Notice that `a_0 = b_0c_0`</p></li>
                <li><p>Since `p|a_0` but `p^2 cancel(|) a_0`, WLOG `p cancel(|) b_0, p|c_0`</p></li>
                <li><p>So `cc C = {l in {1, ..., s} | p cancel(|) c_l} != {0, ..., s}`</p></li>
                <li><p>Observe that `cc C` is nonempty since `p cancel(|) a_n, a_n = b_rc_s => p cancel(|) c_s`</p></li>
                <li><p>`cc C sub {0, ..., s}, ccC != O/`</p></li>
                <li><p>Let `l_0` be the minimum of `cc C => AA l < l_0, p|c_l`</p></li>
                <li><p>Notice that `a_(l_0) = b_0c_(l_0) + b_1c_(l_0-1) + ... + b_qc_(l_0-q)` where `q` is the largest index `<= r` `s.t.` `l_0-q >= 0`</p></li>
                <li><p>Since `p|b_1c_(l_0-1) + ... + b_qc_(l_0-q)` and `p|a_(l_0) => p|b_0c_(l_0)`, since `p cancel(|) b_0 => p|c_(l_0)`, which is a contradiction</p></li>
                <li><p>Therefore, `f` is irreducible over `QQ`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Let `p` be prime. The `p^(th)` cyclotomic polynomial, `Phi_p(x) = (x^p-1)/(x-1)` is irreducible `// QQ`</b></p></li>
                <li><p>Replace `x` with `(x+1) => Phi_p(x+1) = (((x+1)^p-1)/x) = (sum_(k = 0)^p ((p),(k)) x^k - 1)/x`</p></li>
                <li><p>`= (sum_(k = 1)^p ((p),(k)) x^k) / x = sum_(k = 1)^p ((p),(k)) x^(k-1) = sum_(k = 0)^(p-1) ((p),(k+1)) x^k`</p></li>
                <li><p>`= ((p),(1)) + ((p),(2))x + ... + ((p),(p-1))x^(p-2) + ((p),(p))x^(p-1)`</p></li>
                <li><p>`= p + ((p),(2))x + ... + px^(p-2) + x^(p-1)`</p></li>
                <li><p>Therefore `Phi_p(x+1)` is irreducible by Eisenstein's criterion</p></li>
                <li><p>If `Phi_p(x) = f(x)g(x)` where `deg(f(x)), deg(g(x)) < deg(Phi_p(x))`, then `Phi_p(x+1) = f(x+1)g(x+1)` where `deg(f(x+1)), deg(g(x+1)) < deg(Phi_p(x+1)) = deg(Phi_p(x))`</p></li>
                <li><p>Since `Phi_p(x+1)` is irreducible, this is a contradiction</p></li>
              </div>
              <div class="proof">
                <li><p>Constructing a finite field other `ZZ // pZZ`</p></li>
                <li><p>Let `f(x)` be an irreducible polynomial of degree `n` in `ZZ // pZZ [x]`</p></li>
                <li><p><a href="#f_maximal">We know that `(f(x)) sube ZZ // pZZ [x]` is a maximal ideal</a></p></li>
                <li><p>So `(ZZ // pZZ[x]) / (f(x))` is a finite field</p></li>
                <li><p>We claim that `| (ZZ // pZZ[x]) / (f(x)) | = p^n`</p></li>
                <li><p>Any element in `(ZZ // pZZ[x]) / (f(x))` can be written as a `ZZ // pZZ` linear combination of `{1 + (f(x)), x + (f(x)), ..., x^(n-1) + f(x)}`</p></li>
                <li><p>We're proving by induction that `x^k + (f(x)) in ZZ // pZZ` linear span of `{1 + (f(x)), ..., x^(n-1) + (f(x))}` `AA k >= n`</p></li>
                <li><p>Base Case: `k = n`. `f(x) = x^n + a_(n-1)x^(n-1) + ... + a_1x + a_0 in ZZ // pZZ[x]`</p></li>
                <li><p>`x_n + a_(n-1)x^(n-1) + ... + a_0 + (f(x)) = 0 + (f(x))`</p></li>
                <li><p>`x_n + (f(x)) = -a_(n-1)x^(n-1) - ... - a_0 + (f(x))`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `k >= n, AA j <= k, x^j + (f(x)) in span{1 + (f(x)), ..., x^(n-1) + (f(x))}`</p></li>
                <li><p>Consider `x^(k+1) + (f(x)) = -a_(n-1)x^(k+1-n+n-1) - ... - a_0x^(k+1-n) + (f(x))`</p></li>
                <li><p>`= -a_(n-1)x^k - ... - a_0x^(k+1-n) + (f(x))`</p></li>
                <li><p>`in span{1 + (f(x)), ..., x^(n-1) + (f(x))}` by inductive hypothesis (since `k+1-n <= k`)</p></li>
                <li><p>`=> x^k + (f(x)) in span{1 + (f(x)), ..., x^(n-1) + (f(x))}`</p></li>
                <li><p>Any element of `(ZZ // pZZ [x]) / (f(x))` can be written as `sum_(i = 0)^(n-1) b_ix^i + (f(x))`</p></li>
                <li><p>Therefore, `| (ZZ // pZZ[x]) / (f(x)) | <= p^n`</p></li>
                <li><p>There are no `ZZ // pZZ` relations among `{1 + (f(x)), ..., x^(n-1) + (f(x))}`</p></li>
                <li><p>Suppose `sum_(i = 0)^(n-1) c_ix^i + (f(x)) = 0 + (f(x))`</p></li>
                <li><p>`=> sum_(i = 0)^(n-1)c_ix^i in (f(x)) => f(x)|sum_(i = 0)^(n-1) c_ix^i`</p></li>
                <li><p>But `deg(f(x)) > n-1`, so that is a contradiction</p></li>
                <li><p>`{1 + (f(x)), ..., x^(n-1) + (f(x))}` form a basis for `(ZZ // pZZ [x]) / (f(x))` as a vector space over `ZZ // pZZ`</p></li>
                <li><p>Since the basis has `n` elements, the vector space has cardinality `p^n`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: `ZZ[x]` is a `UFD` (Unique Factorization Domain). Let `f(x) in ZZ[x]` which is not a unit and not zero. Then we can always write `f(x) = prod_(i = 1)^n p_i prod_(j = 1)^m q_j (x)` where `p_i` are primes in `ZZ` (not necessarily distinct) This factorization is unique: given `f(x) = prod_(i = 1)^n p_i prod_(j =1)^m q_j (x) = prod_(k = 1)^(n') p'_k prod_(l = 1)^(m') q'_l (x)`, we must have `n = n'`, `m = m'` and possibly after renumbering, `p_i = +- p'_i`, `q_j(x) = +- q'_j(x)`</b></p></li>
                <li><p>Existence: Induction on the degree of `f`</p></li>
                <li><p>If `deg(f) = 0`, this follows straight from the fundamental theorem of arithmetic</p></li>
                <li><p>We can factor out the content of a nonconstant polynomial `f` and apply the fundamental theorem of arithmetic</p></li>
                <li><p>Therefore, it suffices to prove the result in the case that `f(x)` is a primitive, non-constant polynomial</p></li>
                <li><p>Claim: Given a primitive polynomial of `deg > 0`, we can write the polynomial as a product of irreducible polynomials</p></li>
                <li><p>Let `n = deg(f)`</p></li>
                <li><p>Base Case: n = 1. In this case, `f` is a monic linear polynomial, which is automatically irreducible</p></li>
                <li><p>Inductive Hypothesis: Suppose that, for some `n >= 1`, `AA k <= n`, for any primitive polynomial `f(x) in ZZ[x]` of degree `k`, `f(x)` can be factored into a product of irreducible polynomials</p></li>
                <li><p>Suppose `f(x) in ZZ[x]` has degree `n+1` and is primitive</p></li>
                <li><p>If `f(x)` is irreducible, we are done</p></li>
                <li><p>Suppose `f(x)` is reducible `=> f(x) = g(x)h(x)` for some `g(x), h(x) in ZZ[x]` `s.t.` `g(x), h(x)` are primitive and neither is a unit</p></li>
                <li><p>Thus, `deg(g(x)), deg(h(x)) < n + 1`</p></li>
                <li><p>The inductive hypothesis applies to show that `g(x), h(x)` can be written as products of irreducible polynomials in `ZZ[x]`</p></li>
                <li><p>Uniqueness: Suppose that `f(x) = prod_(i = 1)^n p_i prod_(j = 1)^m q_j(x) = prod_(k = 1)^(n') p'_k prod_(l = 1)^(m') q'_l(x)`</p></li>
                <li><p>Since `q_i(x), q'_l(x)` are irreducible, `q_j(x), q'_l(x)` must be primitive</p></li>
                <li><p>`=>` By Gauss's Lemma, `prod_(j = 1)^m q_j(x)`, `prod_(l = 1)^(m') q'_l(x)` are primitive</p></li>
                <li><p>Taking the content of both sides, we see that `prod_(i = 1)^n p_i = +- prod_(k = 1)^(n') p'_k`</p></li>
                <li><p>The uniqueness statement for the `p_i`'s, `p_k`'s follows from the fundamental theorem of arithmetic</p></li>
                <li><p>Therefore, it suffices to show that given `prod_(j = 1)^m q_j(x) = prod_(l = 1)^(m') q'_l(x)`, then `m = m'`, `q_j(x), q'_l(x)` are irreducible, `q_j(x) = +- q'_l(x)` after reordering</p></li>
                <li><p>We prove the result by induction on `j`</p></li>
                <li><p>Base Case: `j = 1`. Since `q_j(x)` is irreducible in `ZZ[x]`, it is irreducible in `QQ[x]` `AA j` (and similarly for all `q'_l(x)`)</p></li>
                <li><p>From the equation `prod_(j = 1)^m q_j(x) = prod_(l = 1)^(m') q'_l(x)`, we see that `q_1(x) | prod_(l = 1)^(m') q'_l(x) in QQ[x]`</p></li>
                <li><p>Therefore, `q_1(x) | q'_l(x) in QQ[x]` for some `l => q'_l(x) = q_1(x)h(x)`</p></li>
                <li><p>Since `q'_l(x)` is irreducible `=> h(x) in QQ[x] \\ {0}`</p></li>
                <li><p>`q'_l(x) = q_1(x) * a/b => bq'_l(x) = aq_1(x)`</p></li>
                <li><p>Since `q'_l(x), q_1(x)` are primitive, `a = +- b => a/b = +- 1`</p></li>
                <li><p>Relabel `q'_l(x) = q'_1(x)`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `j AA i <= j`, `q_i(x) = +- q_i(x)` (after reordering)</p></li>
                <li><p>Given this, we can cancel the common terms on both sides</p></li>
                <li><p>`prod_(k = 1)^m q_k(x) = prod_(l = 1)^(m') q'_l(x)`</p></li>
                <li><p>This yields `prod_(k = j + 1)^m q_k(x) = prod_(l = j + 1)^(m') q'_l(x)`</p></li>
                <li><p>To show that `q_(j+1)(x) = q'_l(x)` for some `j+1 <= l <= m`, we use the same argument as in the base case</p></li>
                <li><p>We claim `m = m'`</p></li>
                <li><p>If `m > m', prod_(j = m' + 1)^m q_j(x) = +- 1`, which is a contradiction</p></li>
                <li><p>If `m < m'`, `prod_(l = m + 1)^(m') q'_l(x) = +- 1`, which is a contradiction</p></li>
              </div>
            </ul>
          </div>
          <div class="content" id="return_to_integral_domains">
            <h3>Return to Integral Domains</h3>
            <ul>
              <li><p><b>Definition: Let `a` and `b` be elements of an integral domain `R`. Then `a` and `b` are <u>associates</u> if `a = br` where `r` is a unit in `R`</b></p></li>
              <li><p>Ex: `x^2 + 1` and `x^2/3 + 1/3` are associates in `QQ[x]`</p></li>
              <li><p><b>Let `a` be an element of an integral domain `R`. `a` is <u>irreducible</u> if whenever `b in R` `s.t.` `b|a`, `a` and `b` are associates</b></p></li>
              <li><p><b>Definition: Let `p` be an element of an integral domain `R`. `p` is <u>prime</u> if whenever `a, b in R` `s.t.` `p|ab => p|a` or `p|b`</b></p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `R` be an integral domain. Let `p in R` be prime. Then `p` is irreducible</b></p></li>
                <li><p>Let `p in R` be prime. Suppose `p = ab` for some `a, b in R`</p></li>
                <li><p>Then `p|ab`, so since `p` is prime, `p|a` or `p|b`</p></li>
                <li><p>`p|a => EE r_1 in R` `s.t.` `pr_1 = a`</p></li>
                <li><p>Substituting, we find `p = ab = pr_1b => r_1b = 1` (since `R` is a domain) `=> b in R^x`</p></li>
                <li><p>`p|b => EE r_2 in R` `s.t.` `pr_2 = b`</p></li>
                <li><p>`p = ab = apr_2 => ar_2 = 1` (since R is a domain) `=> a in R^x`</p></li>
                <li><p>`=> p` is irreducible by definition</p></li>
              </div>
              <li><p>The rings which demonstrate that irreducible elements need not be prime are `ZZ[sqrt d]` where `d != 1` and `d` is not divisible by the square of a prime</p></li>
              <li><p>`ZZ[sqrt d] = {a + b sqrt d | a, b in ZZ}`</p></li>
              <li><p>Define a function `N: ZZ[sqrt d] -> ZZ^(>= 0)` (called the norm) by `a + b sqrt d |-> |a^2 - b^2d |`</p></li>
              <div class="proof">
                <li><p>We claim that `N(a + b sqrt d) = 0 <=> a, b = 0`</p></li>
                <li><p>`(lArr)` obvious</p></li>
                <li><p>`(=>)` Suppose `a + b sqrt d in ZZ[sqrt d] \\ {0}` such that `N(a + b sqrt d) = 0 <=> | a^2 - b^2d | = 0`</p></li>
                <li><p>`gcd(a, b)^2 | (a/gcd(a,b))^2 - (b/gcd(a,b))^2d | = 0`</p></li>
                <li><p>It suffices to prove this in the case that `a` and `b` are coprime</p></li>
                <li><p>If `d = -1`, then `a^2 + b^2 = 0 <=> a = b = 0`</p></li>
                <li><p>Suppose `d != -1`. Then some prime `p` must divide `d`</p></li>
                <li><p>Suppose `a, b` are coprime `s.t.` `a^2-db^2 = 0 => a^2db^2`</p></li>
                <li><p>`p|d => EE k in ZZ \\ {0}` `s.t.` `pk = d`</p></li>
                <li><p>`a^2 = pkb^2 => p|a^2`</p></li>
                <li><p>Since `p` is prime, `p|a => EE n in ZZ` `s.t.` `pn = a`</p></li>
                <li><p>`a^2 = p^2n^2 = pkb^2`</p></li>
                <li><p>We can cancel the `p`'s `=> pn^2 = kb^2`</p></li>
                <li><p>Since `gcd(a,b) = 1`, `p|a => p cancel(|) b <=> p cancel(|) b^2`</p></li>
                <li><p>Therefore, `p|k => EE m in ZZ \\ {0} k = mp`</p></li>
                <li><p>But then `d = pk = mpp = p^2m => p^2|d` where `p` is prime, which is a contradiction</p></li>
              </div>
              <li><p>`N(a + b sqrt d)*N(c + e sqrt d) = N((a + b sqrt d)*(c + e sqrt d))`</p></li>
              <div class="proof">
                <li><p>We claim that `x in ZZ[sqrt d]` is a unit `<=> N(x) = 1`</p></li>
                <li><p>`(=>)` Suppose `x in ZZ[sqrt d]` is a unit</p></li>
                <li><p>`=> EE y in ZZ[sqrt d]` `s.t.` `xy = 1`</p></li>
                <li><p>`N(xy) = N(1) = 1`</p></li>
                <li><p>`N(xy) = N(x)N(y) = 1`</p></li>
                <li><p>Since `N(x) in ZZ^(>= 0) => N(x) = 1`</p></li>
                <li><p>`(lArr)` Suppose `a + b sqrt d = x in ZZ[sqrt d]` is `s.t.` `N(x) = |a^2 - b^2d| = 1`</p></li>
                <li><p>`|a^2 - b^2d| = |(a + b sqrt d)(a - b sqrt d)| = 1`</p></li>
                <li><p>`=> (a + b sqrt d)(a - b sqrt d) = 1` or `(a + b sqrt d)(a - b sqrt d) = -1`</p></li>
                <li><p>`=> a + b sqrt d` is a unit</p></li>
              </div>
              <div class="proof">
                <li><p>We claim that if `N(x)` is prime, then `x` is irreducible</p></li>
                <li><p>Suppose `x = ab`. Then `N(x) = N(a)N(b)`</p></li>
                <li><p>Since `N(x)` is prime and `N(a), N(b) in ZZ^(>= 0)`, either `N(a) = N(x), N(b) = 1` or `N(a) = 1, N(b) = N(x)`</p></li>
                <li><p>From the previous proof, either `N(a) = 1` or `N(b) = 1 => a` or `b` is a unit `=> x` is irreducible</p></li>
              </div>
              <li><p>Norm: `N: ZZ[sqrt d] -> ZZ^(>= 0)`, `a + b sqrt d |-> | a^2 - db^2 |` where `d` is not `1` and `d` is divisible by the square of any prime number</p></li>
              <li><p>1) `N(x) = 0 <=> x = 0`</p></li>
              <li><p>2) `N(xy) = N(x)N(y)` `AA x, y in ZZ[sqrt d]`</p></li>
              <li><p>3) `N(x) = 1 <=> x` is a unit in `Z[sqrt d]`</p></li>
              <li><p>4) `N(x)` is prime `=> x` is irreducible</p></li>
              <div class="proof">
                <li><p>Ex: `ZZ[sqrt 5]` We claim that `2` is irreducible but `2` is not prime</p></li>
                <li><p>`2 = (a + b sqrt 5)(c + d sqrt 5) => N(2) = N(a + b sqrt 5)N(c + d sqrt 5)`</p></li>
                <li><p>`=> 4 = | a^2 - 5b^2 | * |c^2 - 5d^2|`</p></li>
                <li><p>We claim that `cancel(EE)` integers `a,b` `s.t.` `a^2 - 5b^2 = 2`</p></li>
                <li><p>`=> a^2 = 2 (mod 5)`</p></li>
                <li><p>`a = 0, 1, 2, 3, 4 (mod 5) => a^2 = 0, 1, 4, 4, 1 (mod 5)`</p></li>
                <li><p>`cancel(EE) a in ZZ` `s.t.` `a^2 = 2 (mod 5)`</p></li>
                <li><p>`=> cancel(EE) a, b in ZZ` `s.t.` `a^2 - 5b^2 =2`</p></li>
                <li><p>We also see that `cancel(EE) a, b in ZZ` `s.t.` `5b^2 - a^2 = 2`</p></li>
                <li><p>Therefore if `|a^2 - 5b^2|*|c^2 - 5d^2| = 4`, either `|a^2-5b^2| = 4, |c^2-5d^2| = 1` or `|a^2-5b^2| = 1, |c^2-5d^2| = 4`</p></li>
                <li><p>In either case, `a + b sqrt 5` or `c + d sqrt 5` is a unit of `ZZ[sqrt 5] => 2` is irreducible</p></li>
                <li><p>We claim that `2` is not prime</p></li>
                <li><p>`2|4`, yet `4 = (-1-sqrt 5)(1 - sqrt 5)` but `2 cancel(|) (-1-sqrt 5)` and `2 cancel(|) (1 - sqrt 5)`</p></li>
              </div>
              <li><p>In an arbitrary integral domain, irreducible does not imply prime</p></li>
              <div class="proof">
                <li><p><b>Proposition: If `R` is a `PID`, then `x in R` is irreducible `=> p` is prime</b></p></li>
                <li><p>Let `a, b in R` `s.t.` `x|ab` and `x` is irreducible</p></li>
                <li><p>Since `x|ab`, `EE y in R` `s.t.` `xy = ab`</p></li>
                <li><p>Since `x|ab, ab in (x)`</p></li>
                <li><p>Suppose `x cancel(|) a`. We claim `x|b`</p></li>
                <li><p>We claim `(x,a) = (1)`</p></li>
                <li><p>Since `R` is a `PID`, `(x,a) = (z)` for some `z != 0 in R`</p></li>
                <li><p>`x in (z)` and `a in (z) => z|x` and `z|a`</p></li>
                <li><p>Since `x` is irreducible and `x cancel(|) a => z` is a unit</p></li>
                <li><p>Since `(x,a) = (1), EE r_1, r_2 in R` `s.t.` `r_1x + r_2a = 1`</p></li>
                <li><p>Multiply both sides by `b => r_1xb + r_2ab = b`</p></li>
                <li><p>`=> r_1xb + r_2xy = b` (since `xy = ab`)</p></li>
                <li><p>`=> x(r_1b + r_2y) = b => x|b`</p></li>
              </div>
              <div class="proof">
                <li><p>Ex: `ZZ[x]` is not a `PID`</p></li>
                <li><p>Consider `(3,x) sube ZZ[x]`. We claim that this is not a principal ideal</p></li>
                <li><p>Suppose for contradiction `(3,x) = (f(x))`</p></li>
                <li><p>Then `f(x)|3` and `f(x)|x => f(x) = +- 1`</p></li>
                <li><p>Suppose `(3,x) = (1)`</p></li>
                <li><p>Then `EE g(x), h(x) in ZZ[x]` `s.t.` `3g(x) + xh(x) = 1`</p></li>
                <li><p>Consider `ev_0: ZZ[x] -> ZZ, q(x) |-> q(0)`</p></li>
                <li><p>Then `ev_0(1) = 1, ev_0(3g(x) + xh(x)) = 3*g(0) + 0*h(0)`</p></li>
                <li><p>`= 3*g(0) = 1 => 3|1 in ZZ`, a contradiction</p></li>
              </div>
              <li><p><b>Definition: Let `R` be an integral domain. Then `R` is a <u>unique factorization domain</u> if every nonzero, non-unit element of `R` can be written as a product of irreducible elements. This factorization is unique up to units</b></p></li>
              <div class="proof">
                <li><p><b>Lemma: In a `PID`, every ascending chain of ideals `I_1 sube I_2 sube ... sube I_n sube ...` must stabilize: `EE m in ZZ^+` `s.t.` `AA m' >= m, I_m = I_(m')`</b></p></li>
                <li><p>Let `R` be a `PID`. Let `I_1 sube, ..., sube I_n sube ...` be an ascending chain of ideals.</p></li>
                <li><p>We claim that `cc I = uuu_(n = 1)^oo I_n` is an ideal</p></li>
                <li><p>Let `x, y in cc I => EE` indices `n, m` `s.t.` `x in I_n, y in I_m`</p></li>
                <li><p>Let `n' = max{n, m}`. Then `x,y in I_(n')`</p></li>
                <li><p>Since `I_(n')` is an ideal, `x + y in I_(n') => x + y in cc I`</p></li>
                <li><p>Let `z in cc I, r in R`. Then `EE` an index `k` `s.t.` `z in I_k`</p></li>
                <li><p>Since `I_k` is an ideal, `rz in I_k => rz in cc I`</p></li>
                <li><p>Therefore, `cc I` is an ideal</p></li>
                <li><p>Since `R` is a `PID, cc I = (x)` for some `x in R`</p></li>
                <li><p>Since `(x) = uuu_(n= 1)^oo I_i, x in I_i` for some `i`</p></li>
                <li><p>Let `n` be the least integer `s.t.` `x in I_n`</p></li>
                <li><p>Then `(x) = cc I supe I_n`</p></li>
                <li><p>Since `x in cc I` and `x in I_n => (x) sube I_n => cc I = I_n`</p></li>
                <li><p>The chain stabilizes after `I_n`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: If `R` is a `PID`, then `R` is a `UFD`</b></p></li>
                <li><p>(Existence) Let `x in R`, not a unit, nonzero. If `x` is irreducible, then `x = x` is the factorization</p></li>
                <li><p>Suppose `x` is not irreducible. Then we can write `x = x_1y_1` where `x_1y_1 notin R^x`</p></li>
                <li><p>If `x_1` is irreducible, then at least `1` irreducible element divides `x`</p></li>
                <li><p>Suppose `x_1` is not irreducible, repeat the process `x_1|x, x_2|x_1, x_3|x_2, ...`</p></li>
                <li><p>If this process never terminates, we get an ascending chain `(x) sube (x_1) sube (x_2) sube ...`</p></li>
                <li><p>Since `R` is a `PID`, this chain must stabilize, so the process must terminate</p></li>
                <li><p>By definition, `EE n in ZZ^+` `s.t.` `x_n = x_(n+1) => x_n | x_(n+1) => EE z in R` `s.t.` `x_nz = x_(n+1)`</p></li>
                <li><p>Since `x_(n+1)|x_n => EE w in R` `s.t.` `x_(n+1)w = x_n`</p></li>
                <li><p>Putting the two together, we see that `x_(n+1) = x_nz = x_(n+1)wz`</p></li>
                <li><p>Since `x_(n+1) != 0` and `R` is a domain `=> wz = 1 => w in R^x`</p></li>
                <li><p>Therefore, `x_n` is irreducible</p></li>
                <li><p>We've established the existence of at least `1` irreducible factor of `x`</p></li>
                <li><p>Thus, every nonzero, non-unit element has at least `1` irreducible factor</p></li>
                <li><p>Let `x in R` be nonzero and not a unit. Then `EE q_1 in R` irreducible `s.t.` `x = q_1w_1`</p></li>
                <li><p>If `w_1` is irreducible, then we're done</p></li>
                <li><p>If not, then `w_1 = q_2w_2`</p></li>
                <li><p>By the same argument from before, the process cannot continue indefinitely</p></li>
                <li><p>`w_n = q_(n+1)w_(n+1)` where `w_(n+1)` or `q_(n+1)` is a unit</p></li>
                <li><p>`x = (prod_(i = 1)^n q_i)w_n` is a product of irreducibles</p></li>
                <li><p>(Uniqueness) We claim that the factorization of an element into a product of irreducibles is unique up to associates and reordering</p></li>
                <li><p>Suppose `x = prod_(i = 1)^r p_i = prod_(j = 1)^s q_j`</p></li>
                <li><p>We claim `p_i = u_iq_i` for some unit `u_i in R` after reordering for each `1 <= i <= r`</p></li>
                <li><p>Base Case: `i = 1`. `p_1 = prod_(j = 1)^s q_j`</p></li>
                <li><p>Since `p_1` is irreducible, `R` is a `PID => p_1` is prime</p></li>
                <li><p>So `p_1|q_j` for some `j`. Relabel this as `q_1`</p></li>
                <li><p>`p_1|q_1` and `q_1` is irreducible `=> p_1` is an associate of `q_1`</p></li>
                <li><p>Since `p_1` is not a unit `=> EE v_1 in R^x` `s.t.` `p_1 = q_1v_1`</p></li>
                <li><p>Set `v_1^-1 = u_1`, then `p_1u_1 = q_1`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `j >= 1` `AA 1 <= i <= j` `EE u_i in R^x` `s.t.` `p_iu_i = q_i`</p></li>
                <li><p>Now we can cancel out the common terms in `prod_(i = 1)^j p_i prod_(k = j+1)^r p_k = prod_(l = 1)^j q_l prod_(n = j+1)^s q_n` to get `prod_(k = j+1)^r p_k = prod_(i = 1)^j u_i prod_(n = j+1)^s q_n`</p></li>
                <li><p>Repeating the argument from the base case, `EE n'` `s.t.` `p_(j+1)|q_(n')` and `EE u_(j+1) in R^x` `s.t.` `p_(j+1)*u_(j+1) = q_(n')`</p></li>
                <li><p>Relabel `q_(n') = q_(j+1)`</p></li>
                <li><p>The same argument from the `F[x]` case proves `r = s`</p></li>
              </div>
              <li><p>Euclidean domains generalize `F[x]` and `ZZ` in that they have a division theorem</p></li>
              <li><p><b>Definition: Let `R` be an integral domain. Then `R` is a <u>Euclidean domain</u> if `EE` a function `d: R\\{0} -> ZZ^(>= 0)` `s.t.`</b></p></li>
              <li><p><b>1) `d(a) <= d(ab)` `AA a, b in R\\{0}`</b></p></li>
              <li><p><b>2) If `a, b in R` with `b != 0`, then `EE q, r in R` `s.t.` `a = bq + r` with `r = 0` or `d(r) < d(b)`</b></p></li>
              <li><p>Ex: `F[x]` and `ZZ` are Euclidean domains</p></li>
              <div class="proof">
                <li><p>`ZZ[i]` is a Euclidean domain with `d(a + bi) = a^2 + b^2`</p></li>
                <li><p>1) Let `a + bi, c + fi in ZZ[i] \\ {0}`</p></li>
                <li><p>`d(a + bi) = a^2 + b^2`</p></li>
                <li><p>`d((a + bi)(c + fi)) = ||(a + bi)(c + fi)||^2 = ||a + bi||^2||c + fi||^2 = (a^2 + b^2)(c^2 + f^2)`</p></li>
                <li><p>`a^2 + b^2 <= (a^2 + b^2)(c^2 + f^2)` since `c^2 + f^2 > 1`</p></li>
                <li><p>So `d(a + bi) <= d((a + bi)(c + fi))`</p></li>
                <li><p>2) Let `a + bi, c + fi in ZZ[i]` `s.t.` `c + fi != 0`</p></li>
                <li><p>Want `q_1, q_2i, r_1, r_2i` `s.t.` `a + bi = (c + fi)(q_1 + q_2i) + (r_1 + r_2i)` where `d(r_1 + r_2i) < d(c + fi) => r_1^2 + r_2^2 < c^2 + f^2`</p></li>
                <li><p>Notice that `(a + bi)/(c + fi) = (a + bi)/(c^2 + f)*(c - fi) = (ac + bf)/(c^2 + f^2) + (bc - af)/(c^2 + f^2)*i in CC`</p></li>
                <li><p>Let `q_1` be the closest integer to `(ac + bf)/(c^2 + f^2)`. Let `q_2` be the closest integer to `(bc - af)/(c^2 + f^2)`</p></li>
                <li><p>`|q_1 - (ac + bf)/(c^2 + f^2)| <= 1/2, |q_2 - (bc - af)/(c^2 + f^2)| <= 1/2`</p></li>
                <li><p>We've defined `q_1, q_2`</p></li>
                <li><p>Let `r_1 + r_2i = a + bi - (c + fi)(q_1 + q_2i)`</p></li>
                <li><p>We claim that `r_1 + r_2i` is `s.t.` `||r_1 + r_2i||^2 < ||c + fi||^2`</p></li>
                <li><p>`||r_1^2 + r_2i||^2 = ||a + bi - (c + fi)(q_1 + q_2i)||^2`</p></li>
                <li><p>`= ||c^2 + fi||^2*||(a + bi)/(c + fi) - (q_1 + q_2i)||^2`</p></li>
                <li><p>`= ||c + fi||^2*||((ac + bf)/(c^2 + f^2) - q_1) + ((bc - af)/(c^2 + f^2) - q_2)i||^2`</p></li>
                <li><p>`||c + fi||^2*((ac + bf)/(c^2 + f^2) - q_1)^2 + ((bc - af)/(c^2 + f^2) - q_2)^2 <= 1/4||c + fi||^2 + 1/4||c + fi||^2 < ||c + fi||^2`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: Let `R` be a Euclidean domain. Then `R` is a `PID`</b></p></li>
                <li><p>Let `I != (0)` be an ideal of `R`. Let `x in I` `s.t.` `d(x)` is minimal. Such an `x` exists by the well ordering of the natural numbers</p></li>
                <li><p>We claim that `x` generates `I`, `(x) = I`</p></li>
                <li><p>`(sube) x in I` and `I` is an ideal `=> (x) sube I`</p></li>
                <li><p>`(supe)` Let `y in I`. Then `EE q, r in R` `s.t.` `y = xq + r` where `r = 0` or `d(r) < d(x)`</p></li>
                <li><p>Notice that `r = y - xq`, so `r in I`</p></li>
                <li><p>Therefore, `d(r)` cannot be less than `d(x)` by minimality of `d(x)`</p></li>
                <li><p>Thus `r = 0 => x|y => y in (x)`</p></li>
              </div>
              <li><p>`R` is a Euclidean domain `=> R` is a `PID => R` is a `UFD`</p></li>
            </ul>
          </div>
          <div class="content" id="vector_spaces">
            <h3>Vector Spaces</h3>
            <ul>
              <li><p><b>Definition: Let `k` be a field. A <u>vector space</u> over `k` is a set `V` equipped with a binary operator `+: V xx V -> V` such that `(V, +)` is an abelian group and another operation `*: k xx V -> V` called scalar multiplication such that</b></p></li>
              <li style="list-style-type: none";><p><b>1) `a*(x + y) = ax + ay` `AA a in k, x, y in V`</b></p></li>
              <li style="list-style-type: none";><p><b>2) `(a + b)*x = ax + bx` `AA a, b in k, x in V`</b></p></li>
              <li style="list-style-type: none";><p><b>3) `a*(bx) = (ab)*x` `AA a, b in k, x in V`</b></p></li>
              <li style="list-style-type: none";><p><b>4) `1*x = x` `AA x in V, 1 in k`</b></p></li>
              <li><p>Last time we showed that `(ZZ//pZZ [x]) / (f(x))` is a field and a vector space of dimension `= deg(f(x))` if `f(x)` is irreducible over `ZZ // pZZ`</p></li>
              <li><p><b>Definition: Let `V` be a vector space `// k`. A subset `W sube V` is a <u>subspace</u> of `V` if `W` is a `k`-vector space with the operations of `+, *` restricted to `W`</b></p></li>
              <li><p><b>Proposition: Let `V` be a `k`-vector space and let `W` be a subset of `V`. Then `W` is a subspace of `V` if and only if `cx + dy in W` `AA x, y in W, c, d in k`</b></p></li>
              <li><p><b>Definition: Let `V` be a vector space `// k`. A set `S sube V` is <u>linearly dependent</u> if `EE v_1, ..., v_n in S` and a linear combination `sum_(i = 1)^n c_iv_i = 0` where at least one `c_i` is nonzero. A set `S sube V` is <u>linearly independent</u> if whenever `v_1, ..., v_m in S` `s.t.` `sum_(i = 1)^m c_iv_i = 0`, we must have `c_i = 0` `AA 1 <= i <= m`</b></p></li>
              <li><p><b>Definition: Let `V` be a vector space `// k`. Then a set `S sube V` <u>spans</u> `V` if every element of `V` can be written as a `k`-linear combination of elements of `S`. A set `S sube V` is a <u>basis</u> for `V` if `S` spans `V` and `S` is linearly independent</b></p></li>
              <li><p><b>Definition: A set `S` is called a <u>partially ordered set</u> if `EE` a relation `<=` `s.t.`</b></p></li>
              <li style="list-style-type: none";><p><b>1) Reflexivity: `a <= a` `AA a in S`</b></p></li>
              <li style="list-style-type: none";><p><b>2) Anticommutativity: `AA a, b in S` if `a <= b` and `b <= a`, then `a = b`</b></p></li>
              <li style="list-style-type: none";><p><b>3) Transitivity: If `a <= b` and `b <= c => a <= c` `AA a, b, c in S`</b></p></li>
              <li><p><b>A <u>chain</u> in a partially ordered set `S` is a subset `cc C sube S` `s.t.` `AA x, y in cc C`, either `x <= y` or `y <= x`. Also known as a <u>totally ordered set</u> or a <u>linearly ordered set</u>. An <u>upper bound</u> for a chain `cc C` in `S` is an element `z in S` `s.t.` `x <= z` `AA x in cc C`</b></p></li>
              <li><p><b>Zorn's Lemma: Let `S` be a partially ordered set. If every chain in `S` has an upper bound in `S`, then `S` has at least one maximal element</b></p></li>
              <div class="proof">
                <li><p><b>Theorem: Let `V` be a vector space `// k`. Then `V` has a basis</b></p></li>
                <li><p>Let `S` be the partially ordered set consisting of all linearly independent subsets of `V`.</p></li>
                <li><p>If `V = 0`, the result is obvious, so suppose `V != {0}`.</p></li>
                <li><p>Since `V` is not the zero vector space, then `EE v in V \\ {0}`</p></li>
                <li><p>By definition, `{v}` is a linearly independent subset of `V` so `S != O/`</p></li>
                <li><p>Let `cc C = {S_i}_(i in I)` be a chain of elements of `S`. We claim `cc C` has an upper bound in `S`</p></li>
                <li><p>Let `cc S = uuu_(i in I) S_i`. We claim that `cc S` is linearly independent as well</p></li>
                <li><p>Suppose `v_1, ..., v_n in cc S` `s.t.` `sum_(j = 1)^n c_(alpha_j)v_(alpha_j) = 0` where `v_(alpha_j) in S_(alpha_j)`</p></li>
                <li><p>Let `alpha_k = max{alpha_1, ..., alpha_n}`. Then `v_alpha, ..., v_(alpha_n) in S_(alpha_k)`.</p></li>
                <li><p>Since `S_(alpha_k)` is linearly independent, `c_(alpha_j) = 0` `AA 1 <= j <= n`</p></li>
                <li><p>Thus `cc S` is linearly independent</p></li>
                <li><p>Since `S_i sube cc S` `AA i in I`, `cc S` is an upper bound for `cc C`</p></li>
                <li><p>Since every chain in `S` has an upper bound, `S` has a maximal element, call it `S'`</p></li>
                <li><p>We claim that `S'` is a basis for `V`</p></li>
                <li><p>It remains to show that `S'` spans `V`</p></li>
                <li><p>Suppose not, then `EE v in V` `s.t.` `v in span(S')`</p></li>
                <li><p>We claim that this implies `S' uu {v}` is linearly independent</p></li>
                <li><p>Suppose for a contradiction `S' uu {v}` is linearly dependent `=> EE` a linear combination `sum_(k = 1)^m c_(alpha_k)v_(alpha_k) + cv = 0` where `c != 0, v_(alpha_k) in S'`</p></li>
                <li><p>`V = sum_(k = 1)^m c^-1(-c_(alpha_k))v_(alpha_k) => v in span(S')`, which is a contradiction</p></li>
                <li><p>Thus, `S' uu {v}` is linearly independent, but this contradicts the fact that `S'` is a maximal linearly independent subset of `V`</p></li>
                <li><p>Therefore, `cancel(EE) v in V \\ span(S') => span(S') = V`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Proposition: Let `V` be a vector space `// k` that is spanned by a set `G` consisting of exactly `n` vectors and let `L` be a linearly independent subset of `V` containing exactly `m` vectors. Then `m <= n` and `EE` a subset `H sube G` containing exactly `n-m` vectors `s.t.` `L uu H` generates `V`</b></p></li>
                <li><p>Base Case: `m = 0`. `|L| = 0 => L != O/`. Take `H = G`</p></li>
                <li><p>Inductive Hypothesis: Suppose for some `m >= 0`, given any linearly independent subset `L sube V` of cardinality `m`, we must have `m <= n` and `EE H sube G` `s.t.` `|H| = n - m, H uu L` is a spanning set</p></li>
                <li><p>Let `L` be a linearly independent subset of `V` `s.t.` `|L| = m + 1`</p></li>
                <li><p>`L = {l_1, ..., l_m, l_(m+1)}`. Consider `L\\{l_(m+1)}`</p></li>
                <li><p>This is a linearly independent set of cardinality `m`, so the inductive hypothesis applies to show that `m <= n` and `EE H_0 sube G` `s.t.` `|H_0| = n - m` and `H_0 uu L\\{l_(m+1)}` spans `V`</p></li>
                <li><p>`H_0 = {z_1, ..., z_(n-m)}`</p></li>
                <li><p>`l_(m+1) in span(H_0 uu L\\{l_(m+1)})`</p></li>
                <li><p>`l_(m+1) = sum_(i = 1)^(n-m) c_i z_i + sum_(j = 1)^m d_j l_j`</p></li>
                <li><p>Since `L` is linearly independent, we cannot have `c_1 = ... = c_(n-m) = 0`. Therefore, at least one `c_i` must be nonzero, say `c_k != 0`</p></li>
                <li><p>Notice `l_(m+1) = sum_(i = 1)^(k-1) c_i z_i + c_k z_k + sum_(h = k + 1)^(n-m) c_h z_h + sum_(j = 1)^m d_j l_j`</p></li>
                <li><p>`-c_k z_k = sum_(i = 1)^(k-1) c_i z_i + sum_(h = k+1)^(n-m) c_h z_h + sum_(j = 1)^m d_j l_j - l_(m+1)`</p></li>
                <li><p>`z_k = sum_(i = 1)^(k-1) (-c_k)^-1 c_i z_i + sum_(h = k + 1)^(n+m) (-c_k)^-1 c_h z_k + sum_(j = 1)^m (-c_k)^-1 d_j l_j + (c_k)^-1 l_(m+1)`</p></li>
                <li><p>`z_k in span(H_0\\{z_k} uu L)`</p></li>
                <li><p>`{z_1, ..., z_(n-m)} uu {l_1, ..., l_m}` spans `V`</p></li>
                <li><p>We claim `{z_1, ..., z_(k-1), z_(k+1), ..., z_(n-m)} uu {l_1, ..., l_(m+1)}` spans `V`</p></li>
                <li><p>Since `z_k in span({z_1, ..., z_(k-1), z_(k+1), ..., z_(n-m)} uu {l_1, ..., l_(m+1)})`</p></li>
                <li><p>`=> span({z_1, ..., z_(k-1), z_(k+1), ..., z_(n-m)} uu {l_1, ..., l_(m+1)})` `>= span({z_1, ..., z_(k-1), z_k, z_(k+1), ..., z_(n-m)} uu {l_1, ..., l_(m+1)}) = V`</p></li>
                <li><p>We proved that `(L uu H_0\\{z_k})` spans `V`</p></li>
                <li><p>This set has cardinality `n` and the cardinality of `L` is `m + 1 => m + 1 <= n`</p></li>
              </div>
              <li><p>Suppose `beta_1, beta_2` are finite bases for `V`</p></li>
              <li style="list-style-type: none";><p>Let `G = beta_1, L = beta_2`. Then `|beta_2| <= |beta_1|`</p></li>
              <li style="list-style-type: none";><p>Let `G = beta_2, L = beta_1`. Then `|beta_1| <= |beta_2|`</p></li>
              <li><p>Thus, any two finite bases for `V` have the same cardinality</p></li>
              <li><p>The dimension of a vector space is the cardinality of a basis</p></li>
            </ul>
          </div>
          <div class="content" id="extension_fields">
            <h3>Extension Fields</h3>
            <ul>
              <li><p>We've seen that if `k` is a field and `f(x)` is a polynomial in `k[x]` which is irreducible over `k`, then `k[x] // (f(x))` is a field</p></li>
              <li><p>`k[x] // (f(x))` has a subfield isomorphic to `k: {a + (f(x)) | a in k}`</p></li>
              <li><p><b>Definition: Let `k` be a field. A field `L` is an <u>extension field</u> of `k` if `EE` an injective ring homomorphism `f: k -> L`. `L // k` is a <u>field extension</u></b></p></li>
              <li><p>`L // k` does not mean we are taking a quotient</p></li>
              <li><p><b>Definition: Let `phi_1: k -> L`, `phi_2: k -> L'` be field extensions of `k`. An <u>isomorphism of field extensions</u> is an isomorphism of fields `psi: L -> L'` `s.t.` `psi @ phi_1 = phi_2 <=> bar phi_2 @ psi|_(Im(phi_1)) @ bar phi_1 = i``d_k`</b></p></li>
              <img class="img-fluid" src="./pictures/extension_field.jpg">
              <div class="proof">
                <li><p><b>Theorem: Let `k` be a field. Let `f(x) in k[x]` be irreducible over `k`. Then there exists a field extension `L // k` `s.t.` `f(x)` has a root in `L`</b></p></li>
                <li><p>We've seen that `k(x) // (f(x))` is a field when `f(x) in k[x]` is irreducible over `k`</p></li>
                <li><p>We've also seen that `k[x] // (f(x))` contains a subfield which is isomorphic to `k`</p></li>
                <li><p>By definition, `k[x] // (f(x))` is an extension field of `k`</p></li>
                <li><p>Let `f(x) = sum_(i = 0)^n a_ix^i`. We claim that `f` has a root in `k[x] // (f(x))`</p></li>
                <li><p>We claim that `f(t) in (k[x])/(f(x)) [t]` has a root in `k[x]//(f(x))`</p></li>
                <li><p>`f(t) = sum_(i = 0)^n (a_i + (f(x))) t^i`</p></li>
                <li><p>Observe that `f(x + (f(x))) = sum_(i = 0)^n (a_i + (f(x)))(x + (f(x)))^i`</p></li>
                <li><p>`= sum_(i = 0)^n (a_i + (f(x)))(x^i + (f(x))) = sum_(i = 0)^n (a_ix^i + (f(x)))`</p></li>
                <li><p>`= sum_(i = 0)^n a_ix^i + (f(x)) = 0 + (f(x))`</p></li>
                <li><p>Therefore `L` is an extension field of `k` which has a root of `f`</p></li>
              </div>
              <li><p><b>Kronecker's Theorem: Let `f(x) in k[x]` be a nonconstant polynomial. Then there exists a field extension `L // k` `s.t.` `f(x)` has at least one root in `L`</b></p></li>
              <li><p>Definition: Let `k sube L` be fields. Let `z_1, ..., z_n in L`. Then `k(z_1, ..., z_n)` is the smallest field contained in `L` containing `z_1, ..., z_n` and `k`</p></li>
              <div class="proof">
                <li><p>Ex: Consider `x^3 - 2 in QQ[x]`. By Eisenstein's Criterion, `x^3 - 2` is irreducible over `QQ`</p></li>
                <li><p>Therefore, `x^3-2` has no roots in `QQ`. Consider `QQ(root(3)(2))`</p></li>
                <li><p>`QQ(root(3)(2)) = {a + b root(3)(2) + c root(3)(4) | a,b,c in QQ}`. This does not contain all the roots of `x^3-2`</p></li>
                <li><p>The roots of `x^3 - 2` are `root(3)(2), (e^(i*(2pi)/3))(root(3)(2)), (e^(i*(4pi)/3))(root(3)(2))`</p></li>
                <li><p>`QQ(e^(i*(2pi)/3), root(3)(2)) = {a_1 + a_2 root(3)(2) + a_3 e^(i*(2pi)/3) + a_4 e^(i*(2pi)/3) root(3)(2) + a_5 root(3)(4) + a_6 e^(i*(2pi)/3) root(3)(4) | a_1, ..., a_6 in QQ}`</p></li>
                <li><p>`e^(i*(4pi)/3), e^(i*(4pi)/3) root(3)(2), e^(i*(4pi)/3) root(3)(4), e^(i*(2pi)/3), 1, e^(i*(4pi)/3)` are the roots of `x^3 - 1`</p></li>
                <li><p>`QQ(e^(i*(2pi)/3), root(3)(2))` contains all the roots of `x^3 - 2`</p></li>
                <li><p>`x^3 - 1 = (x-1)(x-e^(i*(2pi)/3))(x-e^(i*(4pi)/3))`</p></li>
                <li><p>Notice that the coefficient on `x^2` on both sides have to be equal</p></li>
                <li><p>`=> 0 = -1-e^(i*(2pi)/3) - e^(i*(4pi)/3) => e^(i*(4pi)/3) = -1-e^(i*(2pi)/3)`</p></li>
              </div>
              <li><p><b>Definition: Let `k` be a field. Let `f(x) in k[x]`. Let `L // k` be a field extension. We say that `f(x)` <u>splits</u> in `L` if (the image of) `f(x)` factors into a product of linear terms in `L[x]`. `L` is called a <u>splitting field</u> for `f(x)` if `L` is equal to the subfield of `L` generated by the image of `k` and the roots `alpha_1, ..., alpha_n in L => L = phi(k)(alpha_1, ..., alpha_n)`. `phi: k -> L`. `L ~= k(alpha_1, ..., alpha_n)`</b></p></li>
              <div class="proof">
                <li><p>We claim that `QQ(root(3)(2), e^(i*(2pi)/3))` is a splitting field for `x^3 - 2`</p></li>
                <li><p>Certainly `x^3 - 2` splits in `QQ(root(3)(2), e^(i*(2pi)/3))`</p></li>
                <li><p>We've already seen that it is necesasary and sufficient to contain the first two roots</p></li>
                <li><p>If `L` is a field containing the first two roots, `root(3)(2)` and `e^(i*(2pi)/3) root(3)(2)`, then `(e^(i*(2pi)/3) root(3)(2))/root(3)(2) = e^(i*(2pi)/3) in L`</p></li>
                <li><p>This implies `QQ(root(3)(2), e^(i*(2pi)/3)) sube L`</p></li>
                <li><p>Notice that `QQ(root(3)(2)) sube RR`, so this cannot be a splitting field</p></li>
                <li><p>Also, `QQ(e^(i*(2pi)/3))` is not a splitting field</p></li>
                <li><p>`a + be^(i*(2pi)/3) = root(3)(2)`</p></li>
                <li><p>If this were the case, taking real and imaginary parts, we see that `b = 0 => a = root(3)(2) in QQ`, which is a contradiction</p></li>
                <li><p>A splitting field must contain `QQ(root(3)(2)), QQ(e^(i*(2pi)/3)) =>` it must contain `QQ(root(3)(2), e^(i*(2pi)/3)) => QQ(root(3)(2), e^(i*(2pi)/3))` is a splitting field</p></li>
              </div>
              <div class="proof">
                <li><p><b>Theorem: Let `f(x) in k[x]` be a nonconstant polynomial. Then there exists a splitting field for `f(x)`</b></p></li>
                <li><p>We prove the result by induction on `deg(f(x))`</p></li>
                <li><p>Base Case: `deg(f(x)) = 1`. Then `f(x)` has a single root and the root lies in `k`.</p></li>
                <li><p>Thus, `k` itself is a splitting field for `f(x)` over `k`</p></li>
                <li><p>Inductive Hypothesis: Suppose that for all fields `k`, for some integer `n >= 1`, for all polynomials `g(x)` `s.t.` `deg(g(x)) = n`, there exists a splitting field for `g(x)` over `k`</p></li>
                <li><p>Let `f(x)` be a polynomial of degree `n+1` in `k[x]`</p></li>
                <li><p>Notice that `f(x)` has a root in `k[x] // (f(x)) = L` by Kronecker's Theorem</p></li>
                <li><p>Therefore, in `L[t]`, we can use the Division Theorem to write `f(t) = (t - (x + (f(x))))q(t)`</p></li>
                <li><p>Notice that `deg(q(t)) = n`, so by the inductive hypothesis, there exists a splitting field for `q(t)` over `L, L'`</p></li>
                <li><p>From the definition, `L'` is a splitting field for `f(x)` over `k`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Let `f(x) in k[x]`. Suppose that `f` is irreducible over `k` and has a root in some field extension `L // k`, call the root `alpha in L`. Then there exists an isomorphism `k[x] // (f(x)) ~= phi(k)(alpha)` where `phi: k -> L` is injective</b></p></li>
                <li><p>We define `psi: k[x] -> phi(k)(alpha), g(x) |-> phi(g)(alpha)`. `psi` is surjective</p></li>
                <li><p>We claim that `ker(psi) = (f(x))`</p></li>
                <li><p>`(supe)` Notice that if `q(x) in (f(x))`, then `q(x) = h(x)f(x)` for some `h(x) in k[x]`</p></li>
                <li><p>`psi(q(x)) = psi(h(x))psi(f(x)) = phi(h)(alpha)phi(f)(alpha) = 0 => q(x) in ker(psi)`</p></li>
                <li><p>Method 1: Notice that there is a well-defined ring homomorphism `bar psi: k[x] // (f(x)) -> phi(k)(alpha), g(x) + (f(x)) |-> phi(g)(x) = psi(g(x))`</p></li>
                <li><p>This is well-defined since `(f(x)) in ker(psi)`. `bar psi` is surjective since `psi` is surjective</p></li>
                <li><p>Notice that since `bar psi` is not the zero map, it must be injective, for `ker(bar psi)` is either `0` or `k[x] // (f(x))` and it is not the latter</p></li>
                <li><p>Therefore `bar psi` is an isomorphism</p></li>
                <li><p>If `gamma: F -> G` is a map of fields, it is either the zero map or it is injective</p></li>
                <li><p>Method 2: `(sube)` Let `g(x) in ker(psi)`. We claim that `g(x) in (f(x))`</p></li>
                <li><p>It suffices to show that `(g(x), f(x)) = (f(x))`</p></li>
                <li><p>Since `k` is a field, `k[x]` is a `PID` `=> (g(x), f(x)) = (h(x))` for some `h(x) in k[x]`</p></li>
                <li><p>This implies that `g(x), f(x)` are divisible by `h(x)`</p></li>
                <li><p>Suppose for a contradiction `f(x) cancel(|) g(x)`</p></li>
                <li><p>Since `f(x)` is irreducible, `h(x)` must be an associate of `f(x)`, or `h(x)` must be a unit in `k[x]`</p></li>
                <li><p>Since `h(x)|g(x)`, then `h(x)` cannot be an associate of `f(x)`, otherwise `h(x)|g(x) => f(x)|g(x)`, which is a contradiction</p></li>
                <li><p>Thus, `h(x) in k^x`. Therefore `(g(x), f(x)) = (1)`</p></li>
                <li><p>Then `EE q_1(x), q_2(x) in k[x]` `s.t.` `g(x)q_1(x) + f(x)q_2(x) = 1`</p></li>
                <li><p>`psi(g(x)q_1(x) + f(x)q_2(x)) = psi(1)`</p></li>
                <li><p>`=> 0*psi(q_1(x)) + 0*psi(q_2(x)) = 1 => 0 = 1`, which is a contradiction</p></li>
                <li><p>Therefore, `(g(x), f(x)) = (f(x)) => f(x)|g(x) => g(x) in (f(x))`</p></li>
              </div>
              <li><p>In general, we see that given `phi: k -> L`, `alpha in L` a root of `f(x)` where `f(x)` is irreducible, `EE` an isomorphism `k[x]//(f(x)) ~= phi(k)(alpha)`</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `f(x) in k[x]` be nonconstant. Let `phi: k -> k'` be an isomorphism of fields. Let `L, L'` be splitting fields for `f(x)`, `phi(f(x))` over `k, k'` respectively. Let `alpha in L` be a root of `f(x)`, `beta in L'` be a root of `phi(f(x))`. Let `phi_1: k -> L, phi_2: k' -> L'` be injective ring homomorphisms exhibiting `L, L'` as extensions of `k, k'` respectively. Then `EE` an isomorphism `psi: phi_1(k)(alpha) ~= phi_2(k')(beta)` `s.t.` `psi|_(phi_1(k)) @ phi_1 = phi_2 @ phi`</b></p></li>
                <li><p>Notice that since `phi: k -> k'` is an isomorphism, there is an induced isomorphism `phi[x]: k[x] -> k'[x]`</p></li>
                <li><p>Since `phi[x]` is an isomorphism, `phi[x]^-1((phi(f(x)))) = (f(x))`</p></li>
                <li><p>Thus, there is an isomorphism `k[x] // (f(x)) ~= k[x] // (phi(f(x)))`</p></li>
                <li><p>Since `alpha, beta` are roots of `f(x)`, `phi(f(x))` in `L, L'` respectively, the previous result shows that `k[x] // (f(x)) ~= phi_1(k)(alpha)`, `k[x] // (phi(f(x))) ~= phi_2(k')(beta)`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Let `f(x)` be a nonconstant polynomial in `k[x]`. Then any two splitting fields for `f(x)` are isomorphic</b></p></li>
                <li><p>Let `phi_1: k -> L`, `phi_2: k' -> L'` be the injective ring homomorphisms exhibiting `L // k`, `L' // k'` as field extensions</p></li>
                <li><p>Let `H = phi_1(k)`, `H' = phi_2(k')`</p></li>
                <li><p>Base Case: Suppose `f(x)` has degree `1`. Then `f(x)` has a single root `alpha in k`, so `f(x) = cx + d, c,d in k`</p></li>
                <li><p>Then `0 = phi_1(0) = phi_1(f(alpha)) = phi_1(c)phi_1(alpha) + phi_1(d)` and `0 = phi_2(0) = phi_2(f(alpha)) = phi_2(c)phi_2(alpha) + phi_2(d)`</p></li>
                <li><p>Thus, `phi_1(alpha), phi_2(alpha)` are roots of `phi_1(f), phi_2(f)` respectively</p></li>
                <li><p>Since `phi_1(alpha) in H, phi_2(alpha) in H'`, we see that `H` and `H'` are splitting fields for `f` over `k` `=> H = L, H = L'`</p></li>
                <li><p>Notice that `phi_2|_(H') @ (phi_1|_H)^-1: H -> H'` is an isomorphism</p></li>
                <li><p>Inductive Hypothesis: Suppose for any field `k`, for some integer `n >= 1`, for any polynomial `f(x)` of degree `n`, any two splitting fields for `f(x)` are isomorphic</p></li>
                <li><p>Suppose that `f(x) in k[x]` has degree `n+1`. Let `L, L'` be splitting fields for `f(x) // k`</p></li>
                <li><p>Let `f_1(x)` be an irreducible factor of `f(x)`</p></li>
                <li><p>Since `L, L'` are splitting fields for `f(x)` over `k`, `EE alpha in L, beta in L'` `s.t.` `alpha` is a root of `phi_1(f_1(x))` and `beta` is a root of `phi_2(f_1(x))`</p></li>
                <li><p>By the previous result, there exists an isomorphism `psi_1: H(alpha) -> H'(beta)` which restricts to `phi_2 @ phi_1^1` on `H`</p></li>
                <li><p>Since `alpha` is a root of `phi_1(f(x))`, `beta` is a root of `phi_2(f(x))`, we can write `phi_1(f(x)) = (x - alpha)q_1(x) in H(alpha)(x)`, `phi_2(f(x)) = (x - beta)q_2(x) in H'(beta)(x)`</p></li>
                <li><p>Notice that `psi_1(q_1(x)) = q_2(x)`, `deg(q_1(x)) = n`</p></li>
                <li><p>`L, L'` are splitting fields for `q_1(x)` over `H(alpha)`</p></li>
                <li><p>By the inductive hypothesis, `L ~= L'`</p></li>
              </div>
              <li><p><b>Definition: Let `f(x) in k[x]`. Let `L` be a splitting field for `f` over `k`. Let `alpha` be a root of `f(x)` in L[x]`. `alpha` is a <u>root of multiplicity m</u> if `m` is the multiplicity of `x-alpha` as a factor in the factorization of `f(x)` as a product of linear terms in `L[x]`</b></p></li>
                <li><p>`f(x) = (x-alpha)^m q(x) in L[x]` where `(x - alpha) cancel(|) q(x)`</p></li>
              <li><p><b>Definition: Let `f(x) = sum_(i = 0)^n a_ix^i in k[x]`. The (formal) derivative of `f(x)` is the element `f'(x) = sum_(i = 1)^n ia_ix^(i-1)`</b></p></li>
              <li><p>This satisfies the same properties as it does in calculus</p></li>
              <div class="proof">
                <li><p><b>Proposition: Let `f(x) in k[x]`. Then `f(x)` has a root of multiplicity `> 1` if and only if `f(x)` and `f'(x)` have a nonconstant greatest common divisor in `k[x]`</b></p></li>
                <li><p>`(=>)` Let `L` be a splitting field for `f(x)` over `k`</p></li>
                <li><p>Let `alpha` be a root of multiplicity `> 1`, call the multiplicity `m`</p></li>
                <li><p>By definition, in `L[x]`, `f(x) = (x - alpha)^m q(x)` where `(x - alpha) cancel(|) q(x)`</p></li>
                <li><p>`f'(x) = m(x-alpha)^(m-1) q(x) + (x - alpha)^m q'(x)`</p></li>
                <li><p>`f'(alpha) = m(alpha-alpha)^(m-1) q(alpha) + (alpha-alpha)^m q(alpha)`</p></li>
                <li><p>`= 0*q(alpha) + 0*q'(alpha) = 0`</p></li>
                <li><p>Thus, `f(x)` and `f'(x)` have a common zero, `alpha`</p></li>
                <li><p>Suppose for a contradiction that `gcd(f(x), f'(x)) = 1 in k[x]`</p></li>
                <li><p>This implies that `EE q_1(x), q_2(x) in k[x]` `s.t.` `f(x)q_1(x) + f'(x)q_2(x) = 1` in `k[x]`</p></li>
                <li><p>This same formula holds in `L[x]`, so `f(x)q_1(x) + f'(x)q_2(x) = 1 in L[x]`</p></li>
                <li><p>Consider evaluating at `alpha`</p></li>
                <li><p>`ev_alpha: L[x] -> L`, `g(x) |-> g(alpha)`</p></li>
                <li><p>`ev_alpha(f(x)q_1(x) + f'(x)q_2(x)) = ev_alpha(1) = 1`</p></li>
                <li><p>`= f(alpha)q_1(alpha) + f'(alpha)q(alpha) = 1 = 0*q_1(x) + 0*q_2(x) = 0`, which is a contradiction</p></li>
                <li><p>`(&lArr;)` Suppose `EE g(x) in k[x]` which is a nonconstant such that `(g(x)) = (f(x), f'(x))`</p></li>
                <li><p>Let `alpha` be a root of `g(x)` in `L`. Then `x-alpha` divides `g(x)` in `L[x]`, so it divides both `f(x)` and `f'(x)` in `L[x]`</p></li>
                <li><p>Using the Division Theorem, we can write `f(x) = (x-alpha)q(x)`</p></li>
                <li><p>Using the properties of the formal derivative, `f'(x) = q(x) + (x-alpha)q'(x)`</p></li>
                <li><p>Since `alpha` is a root of `f'(x) => f'(alpha) = 0 = q(alpha) + (alpha-alpha)q'(alpha) => q(alpha) = 0 <=> (x-alpha)|q(x)`</p></li>
                <li><p>Since `(x-alpha)|q(x) => EE q_1(x) in L[x]` `s.t.` `(x-alpha)q_1(x) = q(x)`</p></li>
                <li><p>Plugging this back in to `f(x)`, we see that `f(x) = (x- alpha)^2q_1(x) => alpha` is a root of multiplicity `>= 2`</p></li>
              </div>
              <div class="proof">
                <li><p><b>Corollary: Let `f(x) in k[x]` be irreducible. If `char(k) = 0`, then `f(x)` cannot have multiple roots. If `char(k) = p`, then `f(x)` has a multiple root in a splitting field `L` if and only if `EE g(x) in k[x]` `s.t.` `f(x) = g(x^p)`</b></p></li>
              </div>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
